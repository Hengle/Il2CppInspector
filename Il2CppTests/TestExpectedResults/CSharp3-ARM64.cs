/*
 * Generated code file by Il2CppInspector - http://www.djkaty.com - https://github.com/djkaty
 */

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Xsl;

// Image 0: mscorlib.dll - Assembly: mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089 - Types 0-2871
[assembly: AllowPartiallyTrustedCallers] // 0x00A22AC4-0x00A22E2C
// [assembly: AssemblyCompany] // 0x00A22AC4-0x00A22E2C
// [assembly: AssemblyCopyright] // 0x00A22AC4-0x00A22E2C
// [assembly: AssemblyDefaultAlias] // 0x00A22AC4-0x00A22E2C
// [assembly: AssemblyDelaySign] // 0x00A22AC4-0x00A22E2C
// [assembly: AssemblyDescription] // 0x00A22AC4-0x00A22E2C
// [assembly: AssemblyFileVersion] // 0x00A22AC4-0x00A22E2C
// [assembly: AssemblyInformationalVersion] // 0x00A22AC4-0x00A22E2C
// [assembly: AssemblyKeyFile] // 0x00A22AC4-0x00A22E2C
// [assembly: AssemblyProduct] // 0x00A22AC4-0x00A22E2C
// [assembly: AssemblyTitle] // 0x00A22AC4-0x00A22E2C
// [assembly: CLSCompliant] // 0x00A22AC4-0x00A22E2C
// [assembly: ComCompatibleVersion] // 0x00A22AC4-0x00A22E2C
// [assembly: CompilationRelaxations] // 0x00A22AC4-0x00A22E2C
// [assembly: ComVisible] // 0x00A22AC4-0x00A22E2C
// [assembly: Debuggable] // 0x00A22AC4-0x00A22E2C
// [assembly: DefaultDependency] // 0x00A22AC4-0x00A22E2C
// [assembly: Guid] // 0x00A22AC4-0x00A22E2C
// [assembly: InternalsVisibleTo] // 0x00A22AC4-0x00A22E2C
// [assembly: InternalsVisibleTo] // 0x00A22AC4-0x00A22E2C
// [assembly: InternalsVisibleTo] // 0x00A22AC4-0x00A22E2C
// [assembly: InternalsVisibleTo] // 0x00A22AC4-0x00A22E2C
// [assembly: InternalsVisibleTo] // 0x00A22AC4-0x00A22E2C
// [assembly: NeutralResourcesLanguage] // 0x00A22AC4-0x00A22E2C
[assembly: RuntimeCompatibility] // 0x00A22AC4-0x00A22E2C
// [assembly: SatelliteContractVersion] // 0x00A22AC4-0x00A22E2C
[assembly: StringFreezing] // 0x00A22AC4-0x00A22E2C

// Image 1: System.Xml.dll - Assembly: System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e - Types 2872-4269
// [assembly: AssemblyCompany] // 0x00A34D94-0x00A35084
// [assembly: AssemblyCopyright] // 0x00A34D94-0x00A35084
// [assembly: AssemblyDefaultAlias] // 0x00A34D94-0x00A35084
// [assembly: AssemblyDelaySign] // 0x00A34D94-0x00A35084
// [assembly: AssemblyDescription] // 0x00A34D94-0x00A35084
// [assembly: AssemblyFileVersion] // 0x00A34D94-0x00A35084
// [assembly: AssemblyInformationalVersion] // 0x00A34D94-0x00A35084
// [assembly: AssemblyKeyFile] // 0x00A34D94-0x00A35084
// [assembly: AssemblyProduct] // 0x00A34D94-0x00A35084
// [assembly: AssemblyTitle] // 0x00A34D94-0x00A35084
// [assembly: CLSCompliant] // 0x00A34D94-0x00A35084
// [assembly: CompilationRelaxations] // 0x00A34D94-0x00A35084
// [assembly: ComVisible] // 0x00A34D94-0x00A35084
// [assembly: Debuggable] // 0x00A34D94-0x00A35084
// [assembly: InternalsVisibleTo] // 0x00A34D94-0x00A35084
// [assembly: InternalsVisibleTo] // 0x00A34D94-0x00A35084
// [assembly: InternalsVisibleTo] // 0x00A34D94-0x00A35084
// [assembly: InternalsVisibleTo] // 0x00A34D94-0x00A35084
// [assembly: InternalsVisibleTo] // 0x00A34D94-0x00A35084
// [assembly: NeutralResourcesLanguage] // 0x00A34D94-0x00A35084
[assembly: RuntimeCompatibility] // 0x00A34D94-0x00A35084
// [assembly: SatelliteContractVersion] // 0x00A34D94-0x00A35084

// Image 2: Mono.Security.dll - Assembly: Mono.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756 - Types 4270-4519
// [assembly: AssemblyCompany] // 0x00A35C58-0x00A35DF4
// [assembly: AssemblyCopyright] // 0x00A35C58-0x00A35DF4
// [assembly: AssemblyDelaySign] // 0x00A35C58-0x00A35DF4
// [assembly: AssemblyDescription] // 0x00A35C58-0x00A35DF4
// [assembly: AssemblyProduct] // 0x00A35C58-0x00A35DF4
// [assembly: AssemblyTitle] // 0x00A35C58-0x00A35DF4
// [assembly: CLSCompliant] // 0x00A35C58-0x00A35DF4
// [assembly: CompilationRelaxations] // 0x00A35C58-0x00A35DF4
// [assembly: ComVisible] // 0x00A35C58-0x00A35DF4
// [assembly: Debuggable] // 0x00A35C58-0x00A35DF4
// [assembly: InternalsVisibleTo] // 0x00A35C58-0x00A35DF4
// [assembly: NeutralResourcesLanguage] // 0x00A35C58-0x00A35DF4
[assembly: RuntimeCompatibility] // 0x00A35C58-0x00A35DF4

// Image 3: System.dll - Assembly: System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e - Types 4520-6315
// [assembly: AssemblyCompany] // 0x00A469B4-0x00A46C7C
// [assembly: AssemblyCopyright] // 0x00A469B4-0x00A46C7C
// [assembly: AssemblyDefaultAlias] // 0x00A469B4-0x00A46C7C
// [assembly: AssemblyDelaySign] // 0x00A469B4-0x00A46C7C
// [assembly: AssemblyDescription] // 0x00A469B4-0x00A46C7C
// [assembly: AssemblyFileVersion] // 0x00A469B4-0x00A46C7C
// [assembly: AssemblyInformationalVersion] // 0x00A469B4-0x00A46C7C
// [assembly: AssemblyKeyFile] // 0x00A469B4-0x00A46C7C
// [assembly: AssemblyProduct] // 0x00A469B4-0x00A46C7C
// [assembly: AssemblyTitle] // 0x00A469B4-0x00A46C7C
// [assembly: CLSCompliant] // 0x00A469B4-0x00A46C7C
// [assembly: CompilationRelaxations] // 0x00A469B4-0x00A46C7C
// [assembly: ComVisible] // 0x00A469B4-0x00A46C7C
// [assembly: Debuggable] // 0x00A469B4-0x00A46C7C
// [assembly: InternalsVisibleTo] // 0x00A469B4-0x00A46C7C
// [assembly: InternalsVisibleTo] // 0x00A469B4-0x00A46C7C
// [assembly: InternalsVisibleTo] // 0x00A469B4-0x00A46C7C
// [assembly: InternalsVisibleTo] // 0x00A469B4-0x00A46C7C
// [assembly: NeutralResourcesLanguage] // 0x00A469B4-0x00A46C7C
[assembly: RuntimeCompatibility] // 0x00A469B4-0x00A46C7C
// [assembly: SatelliteContractVersion] // 0x00A469B4-0x00A46C7C

// Image 4: System.Configuration.dll - Assembly: System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a - Types 6316-6426
[assembly: AllowPartiallyTrustedCallers] // 0x00A47330-0x00A47588
// [assembly: AssemblyCompany] // 0x00A47330-0x00A47588
// [assembly: AssemblyCopyright] // 0x00A47330-0x00A47588
// [assembly: AssemblyDefaultAlias] // 0x00A47330-0x00A47588
// [assembly: AssemblyDescription] // 0x00A47330-0x00A47588
// [assembly: AssemblyFileVersion] // 0x00A47330-0x00A47588
// [assembly: AssemblyInformationalVersion] // 0x00A47330-0x00A47588
// [assembly: AssemblyProduct] // 0x00A47330-0x00A47588
// [assembly: AssemblyTitle] // 0x00A47330-0x00A47588
// [assembly: CLSCompliant] // 0x00A47330-0x00A47588
// [assembly: ComCompatibleVersion] // 0x00A47330-0x00A47588
// [assembly: CompilationRelaxations] // 0x00A47330-0x00A47588
// [assembly: ComVisible] // 0x00A47330-0x00A47588
// [assembly: Debuggable] // 0x00A47330-0x00A47588
// [assembly: DefaultDllImportSearchPaths] // 0x00A47330-0x00A47588
// [assembly: NeutralResourcesLanguage] // 0x00A47330-0x00A47588
[assembly: RuntimeCompatibility] // 0x00A47330-0x00A47588
// [assembly: SatelliteContractVersion] // 0x00A47330-0x00A47588
// [assembly: SecurityRules] // 0x00A47330-0x00A47588

// Image 5: System.Core.dll - Assembly: System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e - Types 6427-7682
// [assembly: AssemblyCompany] // 0x00A52308-0x00A52540
// [assembly: AssemblyCopyright] // 0x00A52308-0x00A52540
// [assembly: AssemblyDefaultAlias] // 0x00A52308-0x00A52540
// [assembly: AssemblyDelaySign] // 0x00A52308-0x00A52540
// [assembly: AssemblyDescription] // 0x00A52308-0x00A52540
// [assembly: AssemblyFileVersion] // 0x00A52308-0x00A52540
// [assembly: AssemblyInformationalVersion] // 0x00A52308-0x00A52540
// [assembly: AssemblyKeyFile] // 0x00A52308-0x00A52540
// [assembly: AssemblyProduct] // 0x00A52308-0x00A52540
// [assembly: AssemblyTitle] // 0x00A52308-0x00A52540
// [assembly: CLSCompliant] // 0x00A52308-0x00A52540
// [assembly: CompilationRelaxations] // 0x00A52308-0x00A52540
// [assembly: ComVisible] // 0x00A52308-0x00A52540
// [assembly: Debuggable] // 0x00A52308-0x00A52540
// [assembly: NeutralResourcesLanguage] // 0x00A52308-0x00A52540
[assembly: RuntimeCompatibility] // 0x00A52308-0x00A52540
// [assembly: SatelliteContractVersion] // 0x00A52308-0x00A52540

// Image 6: CSharp3.dll - Assembly: CSharp3, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null - Types 7683-7688
// [assembly: CompilationRelaxations] // 0x00A52684-0x00A526E0
// [assembly: Debuggable] // 0x00A52684-0x00A526E0
[assembly: RuntimeCompatibility] // 0x00A52684-0x00A526E0

internal static class Interop // TypeDefIndex: 2
{
	// Nested types
	internal static class Libraries // TypeDefIndex: 3
	{
		// Fields
		internal const string CoreLibNative = "System.Private.CoreLib.Native"; // Metadata: 0x003BF948
	}
}

internal static class AssemblyRef // TypeDefIndex: 4
{
	// Fields
	internal const string SystemConfiguration = "System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003BF969
	internal const string System = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003BF9C4
	public const string EcmaPublicKey = "b77a5c561934e089"; // Metadata: 0x003BFA11
	public const string FrameworkPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9"; // Metadata: 0x003BFA25
	public const string FrameworkPublicKeyFull2 = "00240000048000009400000006020000002400005253413100040000010001008D56C76F9E8649383049F383C44BE0EC204181822A6C31CF5EB7EF486944D032188EA1D3920763712CCB12D75FB77E9811149E6148E5D32FBAAB37611C1878DDC19E20EF135D0CB2CFF2BFEC3D115810C3D9069638FE4BE215DBF795861920E5AB6F7DB2E2CEEF136AC23D5DD2BF031700AEC232F6C6B1C785B4305C123B37AB"; // Metadata: 0x003BFB69
	public const string MicrosoftPublicKey = "b03f5f7f11d50a3a"; // Metadata: 0x003BFCAD
	public const string MicrosoftJScript = "Microsoft.JScript, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003BFCC1
	public const string MicrosoftVSDesigner = "Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003BFD19
	public const string SystemData = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003BFD74
	public const string SystemDesign = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003BFDC6
	public const string SystemDrawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003BFE1A
	public const string SystemWeb = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003BFE6F
	public const string SystemWebExtensions = "System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003BFEC0
	public const string SystemWindowsForms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003BFF1C
}

internal static class Consts // TypeDefIndex: 5
{
	// Fields
	public const string MonoVersion = "5.11.0.0"; // Metadata: 0x003BFF77
	public const string MonoCompany = "Mono development team"; // Metadata: 0x003BFF83
	public const string MonoProduct = "Mono Common Language Infrastructure"; // Metadata: 0x003BFF9C
	public const string MonoCopyright = "(c) Various Mono authors"; // Metadata: 0x003BFFC3
	public const int MonoCorlibVersion = 1051100001; // Metadata: 0x003BFFDF
	public const string FxVersion = "4.0.0.0"; // Metadata: 0x003BFFE3
	public const string FxFileVersion = "4.0.30319.17020"; // Metadata: 0x003BFFEE
	public const string EnvironmentVersion = "4.0.30319.17020"; // Metadata: 0x003C0001
	public const string VsVersion = "0.0.0.0"; // Metadata: 0x003C0014
	public const string VsFileVersion = "11.0.0.0"; // Metadata: 0x003C001F
	private const string PublicKeyToken = "b77a5c561934e089"; // Metadata: 0x003C002B
	public const string AssemblyI18N = "I18N, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x003C003F
	public const string AssemblyMicrosoft_JScript = "Microsoft.JScript, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003C008A
	public const string AssemblyMicrosoft_VisualStudio = "Microsoft.VisualStudio, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003C00E2
	public const string AssemblyMicrosoft_VisualStudio_Web = "Microsoft.VisualStudio.Web, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003C013F
	public const string AssemblyMicrosoft_VSDesigner = "Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003C01A0
	public const string AssemblyMono_Http = "Mono.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x003C01FB
	public const string AssemblyMono_Posix = "Mono.Posix, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x003C024B
	public const string AssemblyMono_Security = "Mono.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x003C029C
	public const string AssemblyMono_Messaging_RabbitMQ = "Mono.Messaging.RabbitMQ, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x003C02F0
	public const string AssemblyCorlib = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003C034E
	public const string AssemblySystem = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003C039D
	public const string AssemblySystem_Data = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003C03EA
	public const string AssemblySystem_Design = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003C043C
	public const string AssemblySystem_DirectoryServices = "System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003C0490
	public const string AssemblySystem_Drawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003C04EF
	public const string AssemblySystem_Drawing_Design = "System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003C0544
	public const string AssemblySystem_Messaging = "System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003C05A0
	public const string AssemblySystem_Security = "System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003C05F7
	public const string AssemblySystem_ServiceProcess = "System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003C064D
	public const string AssemblySystem_Web = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003C06A9
	public const string AssemblySystem_Windows_Forms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003C06FA
	public const string AssemblySystem_2_0 = "System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003C0755
	public const string AssemblySystemCore_3_5 = "System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003C07A2
	public const string AssemblySystem_Core = "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003C07F4
	public const string WindowsBase_3_0 = "WindowsBase, Version=3.0.0.0, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003C0846
	public const string AssemblyWindowsBase = "WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003C0887
	public const string AssemblyPresentationCore_3_5 = "PresentationCore, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003C08D9
	public const string AssemblyPresentationCore_4_0 = "PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003C0930
	public const string AssemblyPresentationFramework_3_5 = "PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003C0987
	public const string AssemblySystemServiceModel_3_0 = "System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003C09E3
}

internal sealed class Locale // TypeDefIndex: 6
{
	// Constructors
	private Locale() {} // 0x013CA38C-0x013CA394

	// Methods
	public static string GetText(string msg) => default; // 0x013CA394-0x013CA398
	public static string GetText(string fmt, params /* 0x00A20F78-0x00A20F88 */ object[] args) => default; // 0x013CA398-0x013CA3A0
}

internal static class SR // TypeDefIndex: 7
{
	// Fields
	public const string Arg_AccessException = "Cannot access member."; // Metadata: 0x003C0A3D
	public const string Arg_AccessViolationException = "Attempted to read or write protected memory. This is often an indication that other memory is corrupt."; // Metadata: 0x003C0A56
	public const string Arg_ApplicationException = "Error in the application."; // Metadata: 0x003C0AC0
	public const string Arg_ArgumentException = "Value does not fall within the expected range."; // Metadata: 0x003C0ADD
	public const string Arg_ArgumentOutOfRangeException = "Specified argument was out of the range of valid values."; // Metadata: 0x003C0B0F
	public const string Arg_ArithmeticException = "Overflow or underflow in the arithmetic operation."; // Metadata: 0x003C0B4B
	public const string Arg_ArrayPlusOffTooSmall = "Destination array is not long enough to copy all the items in the collection. Check array index and length."; // Metadata: 0x003C0B81
	public const string Arg_ArrayTypeMismatchException = "Attempted to access an element as a type incompatible with the array."; // Metadata: 0x003C0BF0
	public const string Arg_ArrayZeroError = "Array must not be of length zero."; // Metadata: 0x003C0C39
	public const string Arg_BadImageFormatException = "Format of the executable (.exe) or library (.dll) is invalid."; // Metadata: 0x003C0C5E
	public const string Arg_BogusIComparer = "Unable to sort because the IComparer.Compare() method returns inconsistent results. Either a value does not compare equal to itself, or one value repeatedly compared to another value yields different results. IComparer: \'{0}\'."; // Metadata: 0x003C0C9F
	public const string Arg_CannotBeNaN = "TimeSpan does not accept floating point Not-a-Number values."; // Metadata: 0x003C0D85
	public const string Arg_CannotHaveNegativeValue = "String cannot contain a minus sign if the base is not 10."; // Metadata: 0x003C0DC5
	public const string Arg_CopyNonBlittableArray = "Arrays must contain only blittable data in order to be copied to unmanaged memory."; // Metadata: 0x003C0E02
	public const string Arg_CopyOutOfRange = "Requested range extends past the end of the array."; // Metadata: 0x003C0E58
	public const string Arg_CryptographyException = "Error occurred during a cryptographic operation."; // Metadata: 0x003C0E8E
	public const string Arg_DataMisalignedException = "A datatype misalignment was detected in a load or store instruction."; // Metadata: 0x003C0EC2
	public const string Arg_DateTimeRange = "Combination of arguments to the DateTime constructor is out of the legal range."; // Metadata: 0x003C0F0A
	public const string Arg_DirectoryNotFoundException = "Attempted to access a path that is not on the disk."; // Metadata: 0x003C0F5D
	public const string Arg_DecBitCtor = "Decimal byte array constructor requires an array of length four containing valid decimal bytes."; // Metadata: 0x003C0F94
	public const string Arg_DivideByZero = "Attempted to divide by zero."; // Metadata: 0x003C0FF7
	public const string Arg_DlgtNullInst = "Delegate to an instance method cannot have null \'this\'."; // Metadata: 0x003C1017
	public const string Arg_DlgtTypeMis = "Delegates must be of the same type."; // Metadata: 0x003C1052
	public const string Arg_DuplicateWaitObjectException = "Duplicate objects in argument."; // Metadata: 0x003C1079
	public const string Arg_EnumAndObjectMustBeSameType = "Object must be the same type as the enum. The type passed in was \'{0}\'; the enum type was \'{1}\'."; // Metadata: 0x003C109B
	public const string Arg_EntryPointNotFoundException = "Entry point was not found."; // Metadata: 0x003C10FF
	public const string Arg_EntryPointNotFoundExceptionParameterized = "Unable to find an entry point named \'{0}\' in DLL \'{1}\'."; // Metadata: 0x003C111D
	public const string Arg_EnumIllegalVal = "Illegal enum value: {0}."; // Metadata: 0x003C1158
	public const string Arg_ExecutionEngineException = "Internal error in the runtime."; // Metadata: 0x003C1174
	public const string Arg_ExternalException = "External component has thrown an exception."; // Metadata: 0x003C1196
	public const string Arg_FieldAccessException = "Attempted to access a field that is not accessible by the caller."; // Metadata: 0x003C11C5
	public const string Arg_FormatException = "One of the identified items was in an invalid format."; // Metadata: 0x003C120A
	public const string Arg_GuidArrayCtor = "Byte array for GUID must be exactly {0} bytes long."; // Metadata: 0x003C1243
	public const string Arg_HexStyleNotSupported = "The number style AllowHexSpecifier is not supported on floating point data types."; // Metadata: 0x003C127A
	public const string Arg_HTCapacityOverflow = "Hashtable\'s capacity overflowed and went negative. Check load factor, capacity and the current size of the table."; // Metadata: 0x003C12CF
	public const string Arg_IndexOutOfRangeException = "Index was outside the bounds of the array."; // Metadata: 0x003C1344
	public const string Arg_InsufficientExecutionStackException = "Insufficient stack to continue executing the program safely. This can happen from having too many functions on the call stack or function on the stack using too much stack space."; // Metadata: 0x003C1372
	public const string Arg_InvalidBase = "Invalid Base."; // Metadata: 0x003C1428
	public const string Arg_InvalidCastException = "Specified cast is not valid."; // Metadata: 0x003C1439
	public const string Arg_InvalidHexStyle = "With the AllowHexSpecifier bit set in the enum bit field, the only other valid bits that can be combined into the enum value must be a subset of those in HexNumber."; // Metadata: 0x003C1459
	public const string Arg_InvalidOperationException = "Operation is not valid due to the current state of the object."; // Metadata: 0x003C1501
	public const string Arg_OleAutDateInvalid = " Not a legal OleAut date."; // Metadata: 0x003C1543
	public const string Arg_OleAutDateScale = "OleAut date did not convert to a DateTime correctly."; // Metadata: 0x003C1560
	public const string Arg_InvalidRuntimeTypeHandle = "Invalid RuntimeTypeHandle."; // Metadata: 0x003C1598
	public const string Arg_IOException = "I/O error occurred."; // Metadata: 0x003C15B6
	public const string Arg_KeyNotFound = "The given key was not present in the dictionary."; // Metadata: 0x003C15CD
	public const string Arg_LongerThanSrcString = "Source string was not long enough. Check sourceIndex and count."; // Metadata: 0x003C1601
	public const string Arg_LowerBoundsMustMatch = "The arrays\' lower bounds must be identical."; // Metadata: 0x003C1644
	public const string Arg_MissingFieldException = "Attempted to access a non-existing field."; // Metadata: 0x003C1673
	public const string Arg_MethodAccessException = "Attempt to access the method failed."; // Metadata: 0x003C16A0
	public const string Arg_MissingMemberException = "Attempted to access a missing member."; // Metadata: 0x003C16C8
	public const string Arg_MissingMethodException = "Attempted to access a missing method."; // Metadata: 0x003C16F1
	public const string Arg_MulticastNotSupportedException = "Attempted to add multiple callbacks to a delegate that does not support multicast."; // Metadata: 0x003C171A
	public const string Arg_MustBeBoolean = "Object must be of type Boolean."; // Metadata: 0x003C1770
	public const string Arg_MustBeByte = "Object must be of type Byte."; // Metadata: 0x003C1793
	public const string Arg_MustBeChar = "Object must be of type Char."; // Metadata: 0x003C17B3
	public const string Arg_MustBeDateTime = "Object must be of type DateTime."; // Metadata: 0x003C17D3
	public const string Arg_MustBeDateTimeOffset = "Object must be of type DateTimeOffset."; // Metadata: 0x003C17F7
	public const string Arg_MustBeDecimal = "Object must be of type Decimal."; // Metadata: 0x003C1821
	public const string Arg_MustBeDouble = "Object must be of type Double."; // Metadata: 0x003C1844
	public const string Arg_MustBeEnum = "Type provided must be an Enum."; // Metadata: 0x003C1866
	public const string Arg_MustBeGuid = "Object must be of type GUID."; // Metadata: 0x003C1888
	public const string Arg_MustBeInt16 = "Object must be of type Int16."; // Metadata: 0x003C18A8
	public const string Arg_MustBeInt32 = "Object must be of type Int32."; // Metadata: 0x003C18C9
	public const string Arg_MustBeInt64 = "Object must be of type Int64."; // Metadata: 0x003C18EA
	public const string Arg_MustBePrimArray = "Object must be an array of primitives."; // Metadata: 0x003C190B
	public const string Arg_MustBeSByte = "Object must be of type SByte."; // Metadata: 0x003C1935
	public const string Arg_MustBeSingle = "Object must be of type Single."; // Metadata: 0x003C1956
	public const string Arg_MustBeStatic = "Method must be a static method."; // Metadata: 0x003C1978
	public const string Arg_MustBeString = "Object must be of type String."; // Metadata: 0x003C199B
	public const string Arg_MustBeStringPtrNotAtom = "The pointer passed in as a String must not be in the bottom 64K of the process\'s address space."; // Metadata: 0x003C19BD
	public const string Arg_MustBeTimeSpan = "Object must be of type TimeSpan."; // Metadata: 0x003C1A20
	public const string Arg_MustBeUInt16 = "Object must be of type UInt16."; // Metadata: 0x003C1A44
	public const string Arg_MustBeUInt32 = "Object must be of type UInt32."; // Metadata: 0x003C1A66
	public const string Arg_MustBeUInt64 = "Object must be of type UInt64."; // Metadata: 0x003C1A88
	public const string Arg_MustBeVersion = "Object must be of type Version."; // Metadata: 0x003C1AAA
	public const string Arg_NeedAtLeast1Rank = "Must provide at least one rank."; // Metadata: 0x003C1ACD
	public const string Arg_Need2DArray = "Array was not a two-dimensional array."; // Metadata: 0x003C1AF0
	public const string Arg_Need3DArray = "Array was not a three-dimensional array."; // Metadata: 0x003C1B1A
	public const string Arg_NegativeArgCount = "Argument count must not be negative."; // Metadata: 0x003C1B46
	public const string Arg_NotFiniteNumberException = "Arg_NotFiniteNumberException = Number encountered was not a finite quantity."; // Metadata: 0x003C1B6E
	public const string Arg_NonZeroLowerBound = "The lower bound of target array must be zero."; // Metadata: 0x003C1BBE
	public const string Arg_NotGenericParameter = "Method may only be called on a Type for which Type.IsGenericParameter is true."; // Metadata: 0x003C1BEF
	public const string Arg_NotImplementedException = "The method or operation is not implemented."; // Metadata: 0x003C1C41
	public const string Arg_NotSupportedException = "Specified method is not supported."; // Metadata: 0x003C1C70
	public const string Arg_NotSupportedNonZeroLowerBound = "Arrays with non-zero lower bounds are not supported."; // Metadata: 0x003C1C96
	public const string Arg_NullReferenceException = "Object reference not set to an instance of an object."; // Metadata: 0x003C1CCE
	public const string Arg_ObjObjEx = "Object of type \'{0}\' cannot be converted to type \'{1}\'."; // Metadata: 0x003C1D07
	public const string Arg_OverflowException = "Arithmetic operation resulted in an overflow."; // Metadata: 0x003C1D42
	public const string Arg_OutOfMemoryException = "Insufficient memory to continue the execution of the program."; // Metadata: 0x003C1D73
	public const string Arg_PlatformNotSupported = "Operation is not supported on this platform."; // Metadata: 0x003C1DB4
	public const string Arg_ParamName_Name = "Parameter name: {0}"; // Metadata: 0x003C1DE4
	public const string Arg_PathIllegal = "The path is not of a legal form."; // Metadata: 0x003C1DFB
	public const string Arg_PathIllegalUNC = "The UNC path should be of the form \\\\\\\\server\\\\share."; // Metadata: 0x003C1E1F
	public const string Arg_RankException = "Attempted to operate on an array with the incorrect number of dimensions."; // Metadata: 0x003C1E58
	public const string Arg_RankIndices = "Indices length does not match the array rank."; // Metadata: 0x003C1EA5
	public const string Arg_RankMultiDimNotSupported = "Only single dimensional arrays are supported for the requested action."; // Metadata: 0x003C1ED6
	public const string Arg_RanksAndBounds = "Number of lengths and lowerBounds must match."; // Metadata: 0x003C1F20
	public const string Arg_RegGetOverflowBug = "RegistryKey.GetValue does not allow a String that has a length greater than Int32.MaxValue."; // Metadata: 0x003C1F51
	public const string Arg_RegKeyNotFound = "The specified registry key does not exist."; // Metadata: 0x003C1FB0
	public const string Arg_SecurityException = "Security error."; // Metadata: 0x003C1FDE
	public const string Arg_StackOverflowException = "Operation caused a stack overflow."; // Metadata: 0x003C1FF1
	public const string Arg_SynchronizationLockException = "Object synchronization method was called from an unsynchronized block of code."; // Metadata: 0x003C2017
	public const string Arg_SystemException = "System error."; // Metadata: 0x003C2069
	public const string Arg_TargetInvocationException = "Exception has been thrown by the target of an invocation."; // Metadata: 0x003C207A
	public const string Arg_TargetParameterCountException = "Number of parameters specified does not match the expected number."; // Metadata: 0x003C20B7
	public const string Arg_DefaultValueMissingException = "Missing parameter does not have a default value."; // Metadata: 0x003C20FD
	public const string Arg_ThreadStartException = "Thread failed to start."; // Metadata: 0x003C2131
	public const string Arg_ThreadStateException = "Thread was in an invalid state for the operation being executed."; // Metadata: 0x003C214C
	public const string Arg_TimeoutException = "The operation has timed out."; // Metadata: 0x003C2190
	public const string Arg_TypeAccessException = "Attempt to access the type failed."; // Metadata: 0x003C21B0
	public const string Arg_TypeLoadException = "Failure has occurred while loading a type."; // Metadata: 0x003C21D6
	public const string Arg_UnauthorizedAccessException = "Attempted to perform an unauthorized operation."; // Metadata: 0x003C2204
	public const string Arg_VersionString = "Version string portion was too short or too long."; // Metadata: 0x003C2237
	public const string Arg_WrongType = "The value \'{0}\' is not of type \'{1}\' and cannot be used in this generic collection."; // Metadata: 0x003C226C
	public const string Argument_AbsolutePathRequired = "Absolute path information is required."; // Metadata: 0x003C22C3
	public const string Argument_AddingDuplicate = "An item with the same key has already been added. Key: {0}"; // Metadata: 0x003C22ED
	public const string Argument_AddingDuplicate__ = "Item has already been added. Key in dictionary: \'{0}\'  Key being added: \'{1}\'"; // Metadata: 0x003C232B
	public const string Argument_AdjustmentRulesNoNulls = "The AdjustmentRule array cannot contain null elements."; // Metadata: 0x003C237C
	public const string Argument_AdjustmentRulesOutOfOrder = "The elements of the AdjustmentRule array must be in chronological order and must not overlap."; // Metadata: 0x003C23B6
	public const string Argument_BadFormatSpecifier = "Format specifier was invalid."; // Metadata: 0x003C2417
	public const string Argument_CodepageNotSupported = "{0} is not a supported code page."; // Metadata: 0x003C2438
	public const string Argument_CompareOptionOrdinal = "CompareOption.Ordinal cannot be used with other options."; // Metadata: 0x003C245D
	public const string Argument_ConflictingDateTimeRoundtripStyles = "The DateTimeStyles value RoundtripKind cannot be used with the values AssumeLocal, AssumeUniversal or AdjustToUniversal."; // Metadata: 0x003C2499
	public const string Argument_ConflictingDateTimeStyles = "The DateTimeStyles values AssumeLocal and AssumeUniversal cannot be used together."; // Metadata: 0x003C2515
	public const string Argument_ConversionOverflow = "Conversion buffer overflow."; // Metadata: 0x003C256B
	public const string Argument_ConvertMismatch = "The conversion could not be completed because the supplied DateTime did not have the Kind property set correctly.  For example, when the Kind property is DateTimeKind.Local, the source time zone must be TimeZoneInfo.Local."; // Metadata: 0x003C258A
	public const string Argument_CultureInvalidIdentifier = "{0} is an invalid culture identifier."; // Metadata: 0x003C266C
	public const string Argument_CultureIetfNotSupported = "Culture IETF Name {0} is not a recognized IETF name."; // Metadata: 0x003C2695
	public const string Argument_CultureIsNeutral = "Culture ID {0} (0x{0:X4}) is a neutral culture; a region cannot be created from it."; // Metadata: 0x003C26CD
	public const string Argument_CultureNotSupported = "Culture is not supported."; // Metadata: 0x003C2724
	public const string Argument_CustomCultureCannotBePassedByNumber = "Customized cultures cannot be passed by LCID, only by name."; // Metadata: 0x003C2741
	public const string Argument_DateTimeBadBinaryData = "The binary data must result in a DateTime with ticks between DateTime.MinValue.Ticks and DateTime.MaxValue.Ticks."; // Metadata: 0x003C2780
	public const string Argument_DateTimeHasTicks = "The supplied DateTime must have the Year, Month, and Day properties set to 1.  The time cannot be specified more precisely than whole milliseconds."; // Metadata: 0x003C27F5
	public const string Argument_DateTimeHasTimeOfDay = "The supplied DateTime includes a TimeOfDay setting.   This is not supported."; // Metadata: 0x003C288C
	public const string Argument_DateTimeIsInvalid = "The supplied DateTime represents an invalid time.  For example, when the clock is adjusted forward, any time in the period that is skipped is invalid."; // Metadata: 0x003C28DC
	public const string Argument_DateTimeIsNotAmbiguous = "The supplied DateTime is not in an ambiguous time range."; // Metadata: 0x003C2976
	public const string Argument_DateTimeKindMustBeUnspecified = "The supplied DateTime must have the Kind property set to DateTimeKind.Unspecified."; // Metadata: 0x003C29B2
	public const string Argument_DateTimeOffsetInvalidDateTimeStyles = "The DateTimeStyles value \'NoCurrentDateDefault\' is not allowed when parsing DateTimeOffset."; // Metadata: 0x003C2A08
	public const string Argument_DateTimeOffsetIsNotAmbiguous = "The supplied DateTimeOffset is not in an ambiguous time range."; // Metadata: 0x003C2A67
	public const string Argument_EmptyDecString = "Decimal separator cannot be the empty string."; // Metadata: 0x003C2AA9
	public const string Argument_EmptyName = "Empty name is not legal."; // Metadata: 0x003C2ADA
	public const string Argument_EmptyWaithandleArray = "Waithandle array may not be empty."; // Metadata: 0x003C2AF6
	public const string Argument_EncoderFallbackNotEmpty = "Must complete Convert() operation or call Encoder.Reset() before calling GetBytes() or GetByteCount(). Encoder \'{0}\' fallback \'{1}\'."; // Metadata: 0x003C2B1C
	public const string Argument_EncodingConversionOverflowBytes = "The output byte buffer is too small to contain the encoded data, encoding \'{0}\' fallback \'{1}\'."; // Metadata: 0x003C2BA4
	public const string Argument_EncodingConversionOverflowChars = "The output char buffer is too small to contain the decoded characters, encoding \'{0}\' fallback \'{1}\'."; // Metadata: 0x003C2C07
	public const string Argument_EncodingNotSupported = "\'{0}\' is not a supported encoding name. For information on defining a custom encoding, see the documentation for the Encoding.RegisterProvider method."; // Metadata: 0x003C2C70
	public const string Argument_EnumTypeDoesNotMatch = "The argument type, \'{0}\', is not the same as the enum type \'{1}\'."; // Metadata: 0x003C2D0A
	public const string Argument_FallbackBufferNotEmpty = "Cannot change fallback when buffer is not empty. Previous Convert() call left data in the fallback buffer."; // Metadata: 0x003C2D4F
	public const string Argument_IdnBadLabelSize = "IDN labels must be between 1 and 63 characters long."; // Metadata: 0x003C2DBD
	public const string Argument_IdnBadPunycode = "Invalid IDN encoded string."; // Metadata: 0x003C2DF5
	public const string Argument_IdnIllegalName = "Decoded string is not a valid IDN name."; // Metadata: 0x003C2E14
	public const string Argument_ImplementIComparable = "At least one object must implement IComparable."; // Metadata: 0x003C2E3F
	public const string Argument_InvalidArgumentForComparison = "Type of argument is not compatible with the generic comparer."; // Metadata: 0x003C2E72
	public const string Argument_InvalidArrayLength = "Length of the array must be {0}."; // Metadata: 0x003C2EB3
	public const string Argument_InvalidArrayType = "Target array type is not compatible with the type of items in the collection."; // Metadata: 0x003C2ED7
	public const string Argument_InvalidCalendar = "Not a valid calendar for the given culture."; // Metadata: 0x003C2F28
	public const string Argument_InvalidCharSequence = "Invalid Unicode code point found at index {0}."; // Metadata: 0x003C2F57
	public const string Argument_InvalidCharSequenceNoIndex = "String contains invalid Unicode code points."; // Metadata: 0x003C2F89
	public const string Argument_InvalidCodePageBytesIndex = "Unable to translate bytes {0} at index {1} from specified code page to Unicode."; // Metadata: 0x003C2FB9
	public const string Argument_InvalidCodePageConversionIndex = "Unable to translate Unicode character \\\\u{0:X4} at index {1} to specified code page."; // Metadata: 0x003C300C
	public const string Argument_InvalidCultureName = "Culture name \'{0}\' is not supported."; // Metadata: 0x003C3064
	public const string Argument_InvalidDateTimeKind = "Invalid DateTimeKind value."; // Metadata: 0x003C308C
	public const string Argument_InvalidDateTimeStyles = "An undefined DateTimeStyles value is being used."; // Metadata: 0x003C30AB
	public const string Argument_InvalidDigitSubstitution = "The DigitSubstitution property must be of a valid member of the DigitShapes enumeration. Valid entries include Context, NativeNational or None."; // Metadata: 0x003C30DF
	public const string Argument_InvalidEnumValue = "The value \'{0}\' is not valid for this usage of the type {1}."; // Metadata: 0x003C3172
	public const string Argument_InvalidFlag = "Value of flags is invalid."; // Metadata: 0x003C31B2
	public const string Argument_InvalidGroupSize = "Every element in the value array should be between one and nine, except for the last element, which can be zero."; // Metadata: 0x003C31D0
	public const string Argument_InvalidHighSurrogate = "Found a high surrogate char without a following low surrogate at index: {0}. The input may not be in this encoding, or may not contain valid Unicode (UTF-16) characters."; // Metadata: 0x003C3244
	public const string Argument_InvalidId = "The specified ID parameter \'{0}\' is not supported."; // Metadata: 0x003C32F1
	public const string Argument_InvalidLowSurrogate = "Found a low surrogate char without a preceding high surrogate at index: {0}. The input may not be in this encoding, or may not contain valid Unicode (UTF-16) characters."; // Metadata: 0x003C3327
	public const string Argument_InvalidNativeDigitCount = "The NativeDigits array must contain exactly ten members."; // Metadata: 0x003C33D4
	public const string Argument_InvalidNativeDigitValue = "Each member of the NativeDigits array must be a single text element (one or more UTF16 code points) with a Unicode Nd (Number, Decimal Digit) property indicating it is a digit."; // Metadata: 0x003C3410
	public const string Argument_InvalidNeutralRegionName = "The region name {0} should not correspond to neutral culture; a specific culture name is required."; // Metadata: 0x003C34C4
	public const string Argument_InvalidNormalizationForm = "Invalid normalization form."; // Metadata: 0x003C352A
	public const string Argument_InvalidNumberStyles = "An undefined NumberStyles value is being used."; // Metadata: 0x003C3549
	public const string Argument_InvalidOffLen = "Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection."; // Metadata: 0x003C357B
	public const string Argument_InvalidPathChars = "Illegal characters in path."; // Metadata: 0x003C3611
	public const string Argument_InvalidREG_TZI_FORMAT = "The REG_TZI_FORMAT structure is corrupt."; // Metadata: 0x003C3630
	public const string Argument_InvalidResourceCultureName = "The given culture name \'{0}\' cannot be used to locate a resource file. Resource filenames must consist of only letters, numbers, hyphens or underscores."; // Metadata: 0x003C365C
	public const string Argument_InvalidSerializedString = "The specified serialized string \'{0}\' is not supported."; // Metadata: 0x003C36F8
	public const string Argument_InvalidTimeSpanStyles = "An undefined TimeSpanStyles value is being used."; // Metadata: 0x003C3733
	public const string Argument_MustBeFalse = "Argument must be initialized to false"; // Metadata: 0x003C3767
	public const string Argument_NoEra = "No Era was supplied."; // Metadata: 0x003C3790
	public const string Argument_NoRegionInvariantCulture = "There is no region associated with the Invariant Culture (Culture ID: 0x7F)."; // Metadata: 0x003C37A8
	public const string Argument_NotIsomorphic = "Object contains non-primitive or non-blittable data."; // Metadata: 0x003C37F8
	public const string Argument_OffsetLocalMismatch = "The UTC Offset of the local dateTime parameter does not match the offset argument."; // Metadata: 0x003C3830
	public const string Argument_OffsetPrecision = "Offset must be specified in whole minutes."; // Metadata: 0x003C3886
	public const string Argument_OffsetOutOfRange = "Offset must be within plus or minus 14 hours."; // Metadata: 0x003C38B4
	public const string Argument_OffsetUtcMismatch = "The UTC Offset for Utc DateTime instances must be 0."; // Metadata: 0x003C38E5
	public const string Argument_OneOfCulturesNotSupported = "Culture name {0} or {1} is not supported."; // Metadata: 0x003C391D
	public const string Argument_OnlyMscorlib = "Only mscorlib\'s assembly is valid."; // Metadata: 0x003C394A
	public const string Argument_OutOfOrderDateTimes = "The DateStart property must come before the DateEnd property."; // Metadata: 0x003C3970
	public const string ArgumentOutOfRange_HugeArrayNotSupported = "Arrays larger than 2GB are not supported."; // Metadata: 0x003C39B1
	public const string ArgumentOutOfRange_Index = "Index was out of range. Must be non-negative and less than the size of the collection."; // Metadata: 0x003C39DE
	public const string ArgumentOutOfRange_Length = "The specified length exceeds maximum capacity of SecureString."; // Metadata: 0x003C3A38
	public const string ArgumentOutOfRange_LengthTooLarge = "The specified length exceeds the maximum value of {0}."; // Metadata: 0x003C3A7A
	public const string ArgumentOutOfRange_NeedNonNegNum = "Non-negative number required."; // Metadata: 0x003C3AB4
	public const string ArgumentOutOfRange_NeedNonNegNumRequired = "Non-negative number required."; // Metadata: 0x003C3AD5
	public const string Argument_PathFormatNotSupported = "The given path\'s format is not supported."; // Metadata: 0x003C3AF6
	public const string Argument_RecursiveFallback = "Recursive fallback not allowed for character \\\\u{0:X4}."; // Metadata: 0x003C3B23
	public const string Argument_RecursiveFallbackBytes = "Recursive fallback not allowed for bytes {0}."; // Metadata: 0x003C3B5E
	public const string Argument_ResultCalendarRange = "The result is out of the supported range for this calendar. The result should be between {0} (Gregorian date) and {1} (Gregorian date), inclusive."; // Metadata: 0x003C3B8F
	public const string Argument_SemaphoreInitialMaximum = "The initial count for the semaphore must be greater than or equal to zero and less than the maximum count."; // Metadata: 0x003C3C25
	public const string Argument_TimeSpanHasSeconds = "The TimeSpan parameter cannot be specified more precisely than whole minutes."; // Metadata: 0x003C3C93
	public const string Argument_TimeZoneNotFound = "The time zone ID \'{0}\' was not found on the local computer."; // Metadata: 0x003C3CE4
	public const string Argument_TimeZoneInfoBadTZif = "The tzfile does not begin with the magic characters \'TZif\'.  Please verify that the file is not corrupt."; // Metadata: 0x003C3D23
	public const string Argument_TimeZoneInfoInvalidTZif = "The TZif data structure is corrupt."; // Metadata: 0x003C3D8F
	public const string Argument_ToExclusiveLessThanFromExclusive = "fromInclusive must be less than or equal to toExclusive."; // Metadata: 0x003C3DB6
	public const string Argument_TransitionTimesAreIdentical = "The DaylightTransitionStart property must not equal the DaylightTransitionEnd property."; // Metadata: 0x003C3DF2
	public const string Argument_UTCOutOfRange = "The UTC time represented when the offset is applied must be between year 0 and 10,000."; // Metadata: 0x003C3E4D
	public const string Argument_WaitHandleNameTooLong = "The name can be no more than {0} characters in length."; // Metadata: 0x003C3EA7
	public const string ArgumentException_OtherNotArrayOfCorrectLength = "Object is not a array with the same number of elements as the array to compare it to."; // Metadata: 0x003C3EE1
	public const string ArgumentException_TupleIncorrectType = "Argument must be of type {0}."; // Metadata: 0x003C3F3A
	public const string ArgumentException_TupleLastArgumentNotATuple = "The last element of an eight element tuple must be a Tuple."; // Metadata: 0x003C3F5B
	public const string ArgumentException_ValueTupleIncorrectType = "Argument must be of type {0}."; // Metadata: 0x003C3F9A
	public const string ArgumentException_ValueTupleLastArgumentNotAValueTuple = "The last element of an eight element ValueTuple must be a ValueTuple."; // Metadata: 0x003C3FBB
	public const string ArgumentNull_Array = "Array cannot be null."; // Metadata: 0x003C4004
	public const string ArgumentNull_ArrayElement = "At least one element in the specified array was null."; // Metadata: 0x003C401D
	public const string ArgumentNull_ArrayValue = "Found a null value within an array."; // Metadata: 0x003C4056
	public const string ArgumentNull_Generic = "Value cannot be null."; // Metadata: 0x003C407D
	public const string ArgumentNull_Key = "Key cannot be null."; // Metadata: 0x003C4096
	public const string ArgumentNull_Obj = "Object cannot be null."; // Metadata: 0x003C40AD
	public const string ArgumentNull_String = "String reference not set to an instance of a String."; // Metadata: 0x003C40C7
	public const string ArgumentNull_Type = "Type cannot be null."; // Metadata: 0x003C40FF
	public const string ArgumentNull_Waithandles = "The waitHandles parameter cannot be null."; // Metadata: 0x003C4117
	public const string ArgumentNull_WithParamName = "Parameter \'{0}\' cannot be null."; // Metadata: 0x003C4144
	public const string ArgumentOutOfRange_AddValue = "Value to add was out of range."; // Metadata: 0x003C4167
	public const string ArgumentOutOfRange_ActualValue = "Actual value was {0}."; // Metadata: 0x003C4189
	public const string ArgumentOutOfRange_BadYearMonthDay = "Year, Month, and Day parameters describe an un-representable DateTime."; // Metadata: 0x003C41A2
	public const string ArgumentOutOfRange_BadHourMinuteSecond = "Hour, Minute, and Second parameters describe an un-representable DateTime."; // Metadata: 0x003C41EC
	public const string ArgumentOutOfRange_BiggerThanCollection = "Must be less than or equal to the size of the collection."; // Metadata: 0x003C423A
	public const string ArgumentOutOfRange_Bounds_Lower_Upper = "Argument must be between {0} and {1}."; // Metadata: 0x003C4277
	public const string ArgumentOutOfRange_CalendarRange = "Specified time is not supported in this calendar. It should be between {0} (Gregorian date) and {1} (Gregorian date), inclusive."; // Metadata: 0x003C42A0
	public const string ArgumentOutOfRange_Capacity = "Capacity exceeds maximum capacity."; // Metadata: 0x003C4324
	public const string ArgumentOutOfRange_Count = "Count must be positive and count must refer to a location within the string/array/collection."; // Metadata: 0x003C434A
	public const string ArgumentOutOfRange_DateArithmetic = "The added or subtracted value results in an un-representable DateTime."; // Metadata: 0x003C43AB
	public const string ArgumentOutOfRange_DateTimeBadMonths = "Months value must be between +/-120000."; // Metadata: 0x003C43F5
	public const string ArgumentOutOfRange_DateTimeBadTicks = "Ticks must be between DateTime.MinValue.Ticks and DateTime.MaxValue.Ticks."; // Metadata: 0x003C4420
	public const string ArgumentOutOfRange_DateTimeBadYears = "Years value must be between +/-10000."; // Metadata: 0x003C446E
	public const string ArgumentOutOfRange_Day = "Day must be between 1 and {0} for month {1}."; // Metadata: 0x003C4497
	public const string ArgumentOutOfRange_DayOfWeek = "The DayOfWeek enumeration must be in the range 0 through 6."; // Metadata: 0x003C44C7
	public const string ArgumentOutOfRange_DayParam = "The Day parameter must be in the range 1 through 31."; // Metadata: 0x003C4506
	public const string ArgumentOutOfRange_DecimalRound = "Decimal can only round to between 0 and 28 digits of precision."; // Metadata: 0x003C453E
	public const string ArgumentOutOfRange_DecimalScale = "Decimal\'s scale value must be between 0 and 28, inclusive."; // Metadata: 0x003C4581
	public const string ArgumentOutOfRange_EndIndexStartIndex = "endIndex cannot be greater than startIndex."; // Metadata: 0x003C45BF
	public const string ArgumentOutOfRange_Enum = "Enum value was out of legal range."; // Metadata: 0x003C45EE
	public const string ArgumentOutOfRange_Era = "Time value was out of era range."; // Metadata: 0x003C4614
	public const string ArgumentOutOfRange_FileTimeInvalid = "Not a valid Win32 FileTime."; // Metadata: 0x003C4638
	public const string ArgumentOutOfRange_GenericPositive = "Value must be positive."; // Metadata: 0x003C4657
	public const string ArgumentOutOfRange_GetByteCountOverflow = "Too many characters. The resulting number of bytes is larger than what can be returned as an int."; // Metadata: 0x003C4672
	public const string ArgumentOutOfRange_GetCharCountOverflow = "Too many bytes. The resulting number of chars is larger than what can be returned as an int."; // Metadata: 0x003C46D7
	public const string ArgumentOutOfRange_IndexCount = "Index and count must refer to a location within the string."; // Metadata: 0x003C4737
	public const string ArgumentOutOfRange_IndexCountBuffer = "Index and count must refer to a location within the buffer."; // Metadata: 0x003C4776
	public const string ArgumentOutOfRange_IndexLength = "Index and length must refer to a location within the string."; // Metadata: 0x003C47B5
	public const string ArgumentOutOfRange_IndexString = "Index was out of range. Must be non-negative and less than the length of the string."; // Metadata: 0x003C47F5
	public const string ArgumentOutOfRange_InvalidEraValue = "Era value was not valid."; // Metadata: 0x003C484D
	public const string ArgumentOutOfRange_InvalidHighSurrogate = "A valid high surrogate character is between 0xd800 and 0xdbff, inclusive."; // Metadata: 0x003C4869
	public const string ArgumentOutOfRange_InvalidLowSurrogate = "A valid low surrogate character is between 0xdc00 and 0xdfff, inclusive."; // Metadata: 0x003C48B6
	public const string ArgumentOutOfRange_InvalidUTF32 = "A valid UTF32 value is between 0x000000 and 0x10ffff, inclusive, and should not include surrogate codepoint values (0x00d800 ~ 0x00dfff)."; // Metadata: 0x003C4902
	public const string ArgumentOutOfRange_LengthGreaterThanCapacity = "The length cannot be greater than the capacity."; // Metadata: 0x003C498F
	public const string ArgumentOutOfRange_ListInsert = "Index must be within the bounds of the List."; // Metadata: 0x003C49C2
	public const string ArgumentOutOfRange_ListItem = "Index was out of range. Must be non-negative and less than the size of the list."; // Metadata: 0x003C49F2
	public const string ArgumentOutOfRange_ListRemoveAt = "Index was out of range. Must be non-negative and less than the size of the list."; // Metadata: 0x003C4A46
	public const string ArgumentOutOfRange_Month = "Month must be between one and twelve."; // Metadata: 0x003C4A9A
	public const string ArgumentOutOfRange_MonthParam = "The Month parameter must be in the range 1 through 12."; // Metadata: 0x003C4AC3
	public const string ArgumentOutOfRange_MustBeNonNegInt32 = "Value must be non-negative and less than or equal to Int32.MaxValue."; // Metadata: 0x003C4AFD
	public const string ArgumentOutOfRange_MustBeNonNegNum = "\'{0}\' must be non-negative."; // Metadata: 0x003C4B45
	public const string ArgumentOutOfRange_MustBePositive = "\'{0}\' must be greater than zero."; // Metadata: 0x003C4B64
	public const string ArgumentOutOfRange_NeedNonNegOrNegative1 = "Number must be either non-negative and less than or equal to Int32.MaxValue or -1."; // Metadata: 0x003C4B88
	public const string ArgumentOutOfRange_NeedPosNum = "Positive number required."; // Metadata: 0x003C4BDE
	public const string ArgumentOutOfRange_NegativeCapacity = "Capacity must be positive."; // Metadata: 0x003C4BFB
	public const string ArgumentOutOfRange_NegativeCount = "Count cannot be less than zero."; // Metadata: 0x003C4C19
	public const string ArgumentOutOfRange_NegativeLength = "Length cannot be less than zero."; // Metadata: 0x003C4C3C
	public const string ArgumentOutOfRange_OffsetLength = "Offset and length must refer to a position in the string."; // Metadata: 0x003C4C60
	public const string ArgumentOutOfRange_OffsetOut = "Either offset did not refer to a position in the string, or there is an insufficient length of destination character array."; // Metadata: 0x003C4C9D
	public const string ArgumentOutOfRange_PartialWCHAR = "Pointer startIndex and length do not refer to a valid string."; // Metadata: 0x003C4D1C
	public const string ArgumentOutOfRange_Range = "Valid values are between {0} and {1}, inclusive."; // Metadata: 0x003C4D5D
	public const string ArgumentOutOfRange_RoundingDigits = "Rounding digits must be between 0 and 15, inclusive."; // Metadata: 0x003C4D91
	public const string ArgumentOutOfRange_SmallCapacity = "capacity was less than the current size."; // Metadata: 0x003C4DC9
	public const string ArgumentOutOfRange_SmallMaxCapacity = "MaxCapacity must be one or greater."; // Metadata: 0x003C4DF5
	public const string ArgumentOutOfRange_StartIndex = "StartIndex cannot be less than zero."; // Metadata: 0x003C4E1C
	public const string ArgumentOutOfRange_StartIndexLargerThanLength = "startIndex cannot be larger than length of string."; // Metadata: 0x003C4E44
	public const string ArgumentOutOfRange_StartIndexLessThanLength = "startIndex must be less than length of string."; // Metadata: 0x003C4E7A
	public const string ArgumentOutOfRange_UtcOffset = "The TimeSpan parameter must be within plus or minus 14.0 hours."; // Metadata: 0x003C4EAC
	public const string ArgumentOutOfRange_UtcOffsetAndDaylightDelta = "The sum of the BaseUtcOffset and DaylightDelta properties must within plus or minus 14.0 hours."; // Metadata: 0x003C4EEF
	public const string ArgumentOutOfRange_Version = "Version\'s parameters must be greater than or equal to zero."; // Metadata: 0x003C4F52
	public const string ArgumentOutOfRange_Week = "The Week parameter must be in the range 1 through 5."; // Metadata: 0x003C4F91
	public const string ArgumentOutOfRange_Year = "Year must be between 1 and 9999."; // Metadata: 0x003C4FC9
	public const string Arithmetic_NaN = "Function does not accept floating point Not-a-Number values."; // Metadata: 0x003C4FED
	public const string ArrayTypeMismatch_CantAssignType = "Source array type cannot be assigned to destination array type."; // Metadata: 0x003C502D
	public const string BadImageFormatException_CouldNotLoadFileOrAssembly = "Could not load file or assembly \'{0}\'. An attempt was made to load a program with an incorrect format."; // Metadata: 0x003C5070
	public const string CollectionCorrupted = "A prior operation on this collection was interrupted by an exception. Collection\'s state is no longer trusted."; // Metadata: 0x003C50DA
	public const string Exception_EndOfInnerExceptionStack = "--- End of inner exception stack trace ---"; // Metadata: 0x003C514C
	public const string Exception_WasThrown = "Exception of type \'{0}\' was thrown."; // Metadata: 0x003C517A
	public const string Format_BadBase64Char = "The input is not a valid Base-64 string as it contains a non-base 64 character, more than two padding characters, or an illegal character among the padding characters."; // Metadata: 0x003C51A1
	public const string Format_BadBase64CharArrayLength = "Invalid length for a Base-64 char array or string."; // Metadata: 0x003C524C
	public const string Format_BadBoolean = "String was not recognized as a valid Boolean."; // Metadata: 0x003C5282
	public const string Format_BadFormatSpecifier = "Format specifier was invalid."; // Metadata: 0x003C52B3
	public const string Format_BadQuote = "Cannot find a matching quote character for the character \'{0}\'."; // Metadata: 0x003C52D4
	public const string Format_EmptyInputString = "Input string was either empty or contained only whitespace."; // Metadata: 0x003C5317
	public const string Format_GuidHexPrefix = "Expected hex 0x in \'{0}\'."; // Metadata: 0x003C5356
	public const string Format_GuidInvLen = "Guid should contain 32 digits with 4 dashes (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)."; // Metadata: 0x003C5373
	public const string Format_GuidInvalidChar = "Guid string should only contain hexadecimal characters."; // Metadata: 0x003C53CA
	public const string Format_GuidBrace = "Expected {0xdddddddd, etc}."; // Metadata: 0x003C5405
	public const string Format_GuidComma = "Could not find a comma, or the length between the previous token and the comma was zero (i.e., \'0x,\'etc.)."; // Metadata: 0x003C5424
	public const string Format_GuidBraceAfterLastNumber = "Could not find a brace, or the length between the previous token and the brace was zero (i.e., \'0x,\'etc.)."; // Metadata: 0x003C5492
	public const string Format_GuidDashes = "Dashes are in the wrong position for GUID parsing."; // Metadata: 0x003C5500
	public const string Format_GuidEndBrace = "Could not find the ending brace."; // Metadata: 0x003C5536
	public const string Format_ExtraJunkAtEnd = "Additional non-parsable characters are at the end of the string."; // Metadata: 0x003C555A
	public const string Format_GuidUnrecognized = "Unrecognized Guid format."; // Metadata: 0x003C559E
	public const string Format_IndexOutOfRange = "Index (zero based) must be greater than or equal to zero and less than the size of the argument list."; // Metadata: 0x003C55BB
	public const string Format_InvalidGuidFormatSpecification = "Format String can be only \'D\', \'d\', \'N\', \'n\', \'P\', \'p\', \'B\', \'b\', \'X\' or \'x\'."; // Metadata: 0x003C5624
	public const string Format_InvalidString = "Input string was not in a correct format."; // Metadata: 0x003C5675
	public const string Format_NeedSingleChar = "String must be exactly one character long."; // Metadata: 0x003C56A2
	public const string Format_NoParsibleDigits = "Could not find any recognizable digits."; // Metadata: 0x003C56D0
	public const string Format_BadTimeSpan = "String was not recognized as a valid TimeSpan."; // Metadata: 0x003C56FB
	public const string InsufficientMemory_MemFailPoint = "Insufficient available memory to meet the expected demands of an operation at this time.  Please try again later."; // Metadata: 0x003C572D
	public const string InsufficientMemory_MemFailPoint_TooBig = "Insufficient memory to meet the expected demands of an operation, and this system is likely to never satisfy this request.  If this is a 32 bit system, consider booting in 3 GB mode."; // Metadata: 0x003C57A2
	public const string InsufficientMemory_MemFailPoint_VAFrag = "Insufficient available memory to meet the expected demands of an operation at this time, possibly due to virtual address space fragmentation.  Please try again later."; // Metadata: 0x003C585C
	public const string InvalidCast_CannotCastNullToValueType = "Null object cannot be converted to a value type."; // Metadata: 0x003C5906
	public const string InvalidCast_DownCastArrayElement = "At least one element in the source array could not be cast down to the destination array type."; // Metadata: 0x003C593A
	public const string InvalidCast_FromTo = "Invalid cast from \'{0}\' to \'{1}\'."; // Metadata: 0x003C599C
	public const string InvalidCast_IConvertible = "Object must implement IConvertible."; // Metadata: 0x003C59C1
	public const string InvalidCast_StoreArrayElement = "Object cannot be stored in an array of this type."; // Metadata: 0x003C59E8
	public const string InvalidOperation_Calling = "WinRT Interop has already been initialized and cannot be initialized again."; // Metadata: 0x003C5A1D
	public const string InvalidOperation_DateTimeParsing = "Internal Error in DateTime and Calendar operations."; // Metadata: 0x003C5A6C
	public const string InvalidOperation_EnumEnded = "Enumeration already finished."; // Metadata: 0x003C5AA3
	public const string InvalidOperation_EnumFailedVersion = "Collection was modified; enumeration operation may not execute."; // Metadata: 0x003C5AC4
	public const string InvalidOperation_EnumNotStarted = "Enumeration has not started. Call MoveNext."; // Metadata: 0x003C5B07
	public const string InvalidOperation_EnumOpCantHappen = "Enumeration has either not started or has already finished."; // Metadata: 0x003C5B36
	public const string InvalidOperation_HandleIsNotInitialized = "Handle is not initialized."; // Metadata: 0x003C5B75
	public const string InvalidOperation_IComparerFailed = "Failed to compare two elements in the array."; // Metadata: 0x003C5B93
	public const string InvalidOperation_NoValue = "Nullable object must have a value."; // Metadata: 0x003C5BC3
	public const string InvalidOperation_NullArray = "The underlying array is null."; // Metadata: 0x003C5BE9
	public const string InvalidOperation_Overlapped_Pack = "Cannot pack a packed Overlapped again."; // Metadata: 0x003C5C0A
	public const string InvalidOperation_ReadOnly = "Instance is read-only."; // Metadata: 0x003C5C34
	public const string InvalidOperation_ThreadWrongThreadStart = "The thread was created with a ThreadStart delegate that does not accept a parameter."; // Metadata: 0x003C5C4E
	public const string InvalidOperation_UnknownEnumType = "Unknown enum type."; // Metadata: 0x003C5CA6
	public const string InvalidOperation_WriteOnce = "This property has already been set and cannot be modified."; // Metadata: 0x003C5CBC
	public const string InvalidOperation_ArrayCreateInstance_NotARuntimeType = "Array.CreateInstance() can only accept Type objects created by the runtime."; // Metadata: 0x003C5CFA
	public const string InvalidOperation_TooEarly = "Internal Error: This operation cannot be invoked in an eager class constructor."; // Metadata: 0x003C5D49
	public const string InvalidOperation_NullContext = "Cannot call Set on a null context"; // Metadata: 0x003C5D9C
	public const string InvalidOperation_CannotUseAFCOtherThread = "AsyncFlowControl object must be used on the thread where it was created."; // Metadata: 0x003C5DC1
	public const string InvalidOperation_CannotRestoreUnsupressedFlow = "Cannot restore context flow when it is not suppressed."; // Metadata: 0x003C5E0D
	public const string InvalidOperation_CannotSupressFlowMultipleTimes = "Context flow is already suppressed."; // Metadata: 0x003C5E47
	public const string InvalidOperation_CannotUseAFCMultiple = "AsyncFlowControl object can be used only once to call Undo()."; // Metadata: 0x003C5E6E
	public const string InvalidOperation_AsyncFlowCtrlCtxMismatch = "AsyncFlowControl objects can be used to restore flow only on a Context that had its flow suppressed."; // Metadata: 0x003C5EAF
	public const string InvalidProgram_Default = "Common Language Runtime detected an invalid program."; // Metadata: 0x003C5F17
	public const string InvalidProgram_Specific = "Common Language Runtime detected an invalid program. The body of method \'{0}\' is invalid."; // Metadata: 0x003C5F4F
	public const string InvalidProgram_Vararg = "Method \'{0}\' has a variable argument list. Variable argument lists are not supported in .NET Core."; // Metadata: 0x003C5FAC
	public const string InvalidProgram_CallVirtFinalize = "Object.Finalize() can not be called directly. It is only callable by the runtime."; // Metadata: 0x003C6012
	public const string InvalidTimeZone_InvalidRegistryData = "The time zone ID \'{0}\' was found on the local computer, but the registry information was corrupt."; // Metadata: 0x003C6067
	public const string IO_FileExists_Name = "The file \'{0}\' already exists."; // Metadata: 0x003C60CC
	public const string IO_FileName_Name = "File name: \'{0}\'"; // Metadata: 0x003C60EE
	public const string IO_FileNotFound = "Unable to find the specified file."; // Metadata: 0x003C6102
	public const string IO_FileNotFound_FileName = "Could not load file or assembly \'{0}\'. The system cannot find the file specified."; // Metadata: 0x003C6128
	public const string IO_FileLoad = "Could not load the specified file."; // Metadata: 0x003C617D
	public const string IO_FileLoad_FileName = "Could not load the file \'{0}\'."; // Metadata: 0x003C61A3
	public const string IO_PathNotFound_NoPathName = "Could not find a part of the path."; // Metadata: 0x003C61C5
	public const string IO_PathNotFound_Path = "Could not find a part of the path \'{0}\'."; // Metadata: 0x003C61EB
	public const string IO_PathTooLong = "The specified path, file name, or both are too long. The fully qualified file name must be less than 260 characters, and the directory name must be less than 248 characters."; // Metadata: 0x003C6217
	public const string IO_SharingViolation_File = "The process cannot access the file \'{0}\' because it is being used by another process."; // Metadata: 0x003C62C8
	public const string IO_SharingViolation_NoFileName = "The process cannot access the file because it is being used by another process."; // Metadata: 0x003C6321
	public const string IO_AlreadyExists_Name = "Cannot create \'{0}\' because a file or directory with the same name already exists."; // Metadata: 0x003C6374
	public const string UnauthorizedAccess_IODenied_NoPathName = "Access to the path is denied."; // Metadata: 0x003C63CA
	public const string UnauthorizedAccess_IODenied_Path = "Access to the path \'{0}\' is denied."; // Metadata: 0x003C63EB
	public const string Lazy_CreateValue_NoParameterlessCtorForT = "The lazily-initialized type does not have a public, parameterless constructor."; // Metadata: 0x003C6412
	public const string Lazy_ctor_ModeInvalid = "The mode argument specifies an invalid value."; // Metadata: 0x003C6464
	public const string Lazy_StaticInit_InvalidOperation = "ValueFactory returned null."; // Metadata: 0x003C6495
	public const string Lazy_ToString_ValueNotCreated = "Value is not created."; // Metadata: 0x003C64B4
	public const string Lazy_Value_RecursiveCallsToValue = "ValueFactory attempted to access the Value property of this instance."; // Metadata: 0x003C64CD
	public const string MissingConstructor_Name = "Constructor on type \'{0}\' not found."; // Metadata: 0x003C6516
	public const string MustUseCCRewrite = "An assembly (probably \'{1}\') must be rewritten using the code contracts binary rewriter (CCRewrite) because it is calling Contract.{0} and the CONTRACTS_FULL symbol is defined.  Remove any explicit definitions of the CONTRACTS_FULL symbol from your project and rebuild.  CCRewrite can be downloaded from http://go.microsoft.com/fwlink/?LinkID=169180. \\r\\nAfter the rewriter is installed, it can be enabled in Visual Studio from the project\'s Properties page on the Code Contracts pane.  Ensure that \'Perform Runtime Contract Checking\' is enabled, which will define CONTRACTS_FULL."; // Metadata: 0x003C653E
	public const string NotSupported_FixedSizeCollection = "Collection was of a fixed size."; // Metadata: 0x003C6786
	public const string NotSupported_MaxWaitHandles = "The number of WaitHandles must be less than or equal to 64."; // Metadata: 0x003C67A9
	public const string NotSupported_NoCodepageData = "No data is available for encoding {0}. For information on defining a custom encoding, see the documentation for the Encoding.RegisterProvider method."; // Metadata: 0x003C67E8
	public const string NotSupported_ReadOnlyCollection = "Collection is read-only."; // Metadata: 0x003C6881
	public const string NotSupported_StringComparison = "The string comparison type passed in is currently not supported."; // Metadata: 0x003C689D
	public const string NotSupported_VoidArray = "Arrays of System.Void are not supported."; // Metadata: 0x003C68E1
	public const string NotSupported_ByRefLike = "Cannot create boxed ByRef-like values."; // Metadata: 0x003C690D
	public const string NotSupported_Type = "Type is not supported."; // Metadata: 0x003C6937
	public const string NotSupported_WaitAllSTAThread = "WaitAll for multiple handles on a STA thread is not supported."; // Metadata: 0x003C6951
	public const string ObjectDisposed_Generic = "Cannot access a disposed object."; // Metadata: 0x003C6993
	public const string ObjectDisposed_ObjectName_Name = "Object name: \'{0}\'."; // Metadata: 0x003C69B7
	public const string Overflow_Byte = "Value was either too large or too small for an unsigned byte."; // Metadata: 0x003C69CE
	public const string Overflow_Char = "Value was either too large or too small for a character."; // Metadata: 0x003C6A0F
	public const string Overflow_Decimal = "Value was either too large or too small for a Decimal."; // Metadata: 0x003C6A4B
	public const string Overflow_Double = "Value was either too large or too small for a Double."; // Metadata: 0x003C6A85
	public const string Overflow_TimeSpanElementTooLarge = "The TimeSpan could not be parsed because at least one of the numeric components is out of range or contains too many digits."; // Metadata: 0x003C6ABE
	public const string Overflow_Duration = "The duration cannot be returned for TimeSpan.MinValue because the absolute value of TimeSpan.MinValue exceeds the value of TimeSpan.MaxValue."; // Metadata: 0x003C6B3E
	public const string Overflow_Int16 = "Value was either too large or too small for an Int16."; // Metadata: 0x003C6BCF
	public const string Overflow_Int32 = "Value was either too large or too small for an Int32."; // Metadata: 0x003C6C08
	public const string Overflow_Int64 = "Value was either too large or too small for an Int64."; // Metadata: 0x003C6C41
	public const string Overflow_NegateTwosCompNum = "Negating the minimum value of a twos complement number is invalid."; // Metadata: 0x003C6C7A
	public const string Overflow_NegativeUnsigned = "The string was being parsed as an unsigned number and could not have a negative sign."; // Metadata: 0x003C6CC0
	public const string Overflow_SByte = "Value was either too large or too small for a signed byte."; // Metadata: 0x003C6D19
	public const string Overflow_Single = "Value was either too large or too small for a Single."; // Metadata: 0x003C6D57
	public const string Overflow_TimeSpanTooLong = "TimeSpan overflowed because the duration is too long."; // Metadata: 0x003C6D90
	public const string Overflow_UInt16 = "Value was either too large or too small for a UInt16."; // Metadata: 0x003C6DC9
	public const string Overflow_UInt32 = "Value was either too large or too small for a UInt32."; // Metadata: 0x003C6E02
	public const string Overflow_UInt64 = "Value was either too large or too small for a UInt64."; // Metadata: 0x003C6E3B
	public const string Rank_MultiDimNotSupported = "Only single dimension arrays are supported here."; // Metadata: 0x003C6E74
	public const string RuntimeWrappedException = "An object that does not derive from System.Exception has been wrapped in a RuntimeWrappedException."; // Metadata: 0x003C6EA8
	public const string SpinWait_SpinUntil_ArgumentNull = "The condition argument is null."; // Metadata: 0x003C6F0F
	public const string Serialization_CorruptField = "The value of the field \'{0}\' is invalid.  The serialized data is corrupt."; // Metadata: 0x003C6F32
	public const string Serialization_InvalidData = "An error occurred while deserializing the object.  The serialized data is corrupt."; // Metadata: 0x003C6F7F
	public const string Serialization_InvalidEscapeSequence = "The serialized data contained an invalid escape sequence \'\\\\{0}\'."; // Metadata: 0x003C6FD5
	public const string Serialization_InvalidType = "Only system-provided types can be passed to the GetUninitializedObject method. \'{0}\' is not a valid instance of a type."; // Metadata: 0x003C701A
	public const string SpinWait_SpinUntil_TimeoutWrong = "The timeout must represent a value between -1 and Int32.MaxValue, inclusive."; // Metadata: 0x003C7095
	public const string Threading_AbandonedMutexException = "The wait completed due to an abandoned mutex."; // Metadata: 0x003C70E5
	public const string Threading_SemaphoreFullException = "Adding the specified count to the semaphore would cause it to exceed its maximum count."; // Metadata: 0x003C7116
	public const string Threading_ThreadInterrupted = "Thread was interrupted from a waiting state."; // Metadata: 0x003C7171
	public const string Threading_WaitHandleCannotBeOpenedException = "No handle of the given name exists."; // Metadata: 0x003C71A1
	public const string Threading_WaitHandleCannotBeOpenedException_InvalidHandle = "A WaitHandle with system-wide name \'{0}\' cannot be created. A WaitHandle of a different type might have the same name."; // Metadata: 0x003C71C8
	public const string TimeZoneNotFound_MissingRegistryData = "The time zone ID \'{0}\' was not found on the local computer."; // Metadata: 0x003C7242
	public const string TypeInitialization_Default = "Type constructor threw an exception."; // Metadata: 0x003C7281
	public const string TypeInitialization_Type = "The type initializer for \'{0}\' threw an exception."; // Metadata: 0x003C72A9
	public const string TypeInitialization_Type_NoTypeAvailable = "A type initializer threw an exception. To determine which type, inspect the InnerException\'s StackTrace property."; // Metadata: 0x003C72DF
	public const string Verification_Exception = "Operation could destabilize the runtime."; // Metadata: 0x003C7354
	public const string Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType = "Enum underlying type and the object must be same type or object. Type passed in was \'{0}\'; the enum underlying type was \'{1}\'."; // Metadata: 0x003C7380
	public const string Format_InvalidEnumFormatSpecification = "Format String can be only \'G\', \'g\', \'X\', \'x\', \'F\', \'f\', \'D\' or \'d\'."; // Metadata: 0x003C7402
	public const string Arg_MustBeEnumBaseTypeOrEnum = "The value passed in must be an enum base or an underlying type for an enum, such as an Int32."; // Metadata: 0x003C7449
	public const string Arg_EnumUnderlyingTypeAndObjectMustBeSameType = "Enum underlying type and the object must be same type or object must be a String. Type passed in was \'{0}\'; the enum underlying type was \'{1}\'."; // Metadata: 0x003C74AA
	public const string Arg_MustBeType = "Type must be a type provided by the runtime."; // Metadata: 0x003C753D
	public const string Arg_MustContainEnumInfo = "Must specify valid information for parsing in the string."; // Metadata: 0x003C756D
	public const string Arg_EnumValueNotFound = "Requested value \'{0}\' was not found."; // Metadata: 0x003C75AA
	public const string Argument_StringZeroLength = "String cannot be of zero length."; // Metadata: 0x003C75D2
	public const string Argument_StringFirstCharIsZero = "The first char in the string is the null character."; // Metadata: 0x003C75F6
	public const string Argument_LongEnvVarValue = "Environment variable name or value is too long."; // Metadata: 0x003C762D
	public const string Argument_IllegalEnvVarName = "Environment variable name cannot contain equal character."; // Metadata: 0x003C7660
	public const string AssumptionFailed = "Assumption failed."; // Metadata: 0x003C769D
	public const string AssumptionFailed_Cnd = "Assumption failed: {0}"; // Metadata: 0x003C76B3
	public const string AssertionFailed = "Assertion failed."; // Metadata: 0x003C76CD
	public const string AssertionFailed_Cnd = "Assertion failed: {0}"; // Metadata: 0x003C76E2
	public const string PreconditionFailed = "Precondition failed."; // Metadata: 0x003C76FB
	public const string PreconditionFailed_Cnd = "Precondition failed: {0}"; // Metadata: 0x003C7713
	public const string PostconditionFailed = "Postcondition failed."; // Metadata: 0x003C772F
	public const string PostconditionFailed_Cnd = "Postcondition failed: {0}"; // Metadata: 0x003C7748
	public const string PostconditionOnExceptionFailed = "Postcondition failed after throwing an exception."; // Metadata: 0x003C7765
	public const string PostconditionOnExceptionFailed_Cnd = "Postcondition failed after throwing an exception: {0}"; // Metadata: 0x003C779A
	public const string InvariantFailed = "Invariant failed."; // Metadata: 0x003C77D3
	public const string InvariantFailed_Cnd = "Invariant failed: {0}"; // Metadata: 0x003C77E8
	public const string MissingEncodingNameResource = "Could not find a resource entry for the encoding codepage \'{0} - {1}\'"; // Metadata: 0x003C7801
	public const string Globalization_cp_1200 = "Unicode"; // Metadata: 0x003C784A
	public const string Globalization_cp_1201 = "Unicode (Big-Endian)"; // Metadata: 0x003C7855
	public const string Globalization_cp_12000 = "Unicode (UTF-32)"; // Metadata: 0x003C786D
	public const string Globalization_cp_12001 = "Unicode (UTF-32 Big-Endian)"; // Metadata: 0x003C7881
	public const string Globalization_cp_20127 = "US-ASCII"; // Metadata: 0x003C78A0
	public const string Globalization_cp_28591 = "Western European (ISO)"; // Metadata: 0x003C78AC
	public const string Globalization_cp_65000 = "Unicode (UTF-7)"; // Metadata: 0x003C78C6
	public const string Globalization_cp_65001 = "Unicode (UTF-8)"; // Metadata: 0x003C78D9
	public const string DebugAssertBanner = "---- DEBUG ASSERTION FAILED ----"; // Metadata: 0x003C78EC
	public const string DebugAssertLongMessage = "---- Assert Long Message ----"; // Metadata: 0x003C7910
	public const string DebugAssertShortMessage = "---- Assert Short Message ----"; // Metadata: 0x003C7931
	public const string InvalidCast_Empty = "Object cannot be cast to Empty."; // Metadata: 0x003C7953
	public const string Arg_UnknownTypeCode = "Unknown TypeCode value."; // Metadata: 0x003C7976
	public const string Format_BadDatePattern = "Could not determine the order of year, month, and date from \'{0}\'."; // Metadata: 0x003C7991
	public const string Format_BadDateTime = "String was not recognized as a valid DateTime."; // Metadata: 0x003C79D7
	public const string Format_BadDateTimeCalendar = "The DateTime represented by the string is not supported in calendar {0}."; // Metadata: 0x003C7A09
	public const string Format_BadDayOfWeek = "String was not recognized as a valid DateTime because the day of week was incorrect."; // Metadata: 0x003C7A55
	public const string Format_DateOutOfRange = "The DateTime represented by the string is out of range."; // Metadata: 0x003C7AAD
	public const string Format_MissingIncompleteDate = "There must be at least a partial date with a year present in the input."; // Metadata: 0x003C7AE8
	public const string Format_OffsetOutOfRange = "The time zone offset must be within plus or minus 14 hours."; // Metadata: 0x003C7B33
	public const string Format_RepeatDateTimePattern = "DateTime pattern \'{0}\' appears more than once with different values."; // Metadata: 0x003C7B72
	public const string Format_UnknowDateTimeWord = "The string was not recognized as a valid DateTime. There is an unknown word starting at index {0}."; // Metadata: 0x003C7BBA
	public const string Format_UTCOutOfRange = "The UTC representation of the date falls outside the year range 1-9999."; // Metadata: 0x003C7C20
	public const string RFLCT_Ambiguous = "Ambiguous match found."; // Metadata: 0x003C7C6B
	public const string AggregateException_ctor_DefaultMessage = "One or more errors occurred."; // Metadata: 0x003C7C85
	public const string AggregateException_ctor_InnerExceptionNull = "An element of innerExceptions was null."; // Metadata: 0x003C7CA5
	public const string AggregateException_DeserializationFailure = "The serialization stream contains no inner exceptions."; // Metadata: 0x003C7CD0
	public const string AggregateException_InnerException = "(Inner Exception #{0}) "; // Metadata: 0x003C7D0A
	public const string ArgumentOutOfRange_TimeoutTooLarge = "Time-out interval must be less than 2^32-2."; // Metadata: 0x003C7D25
	public const string ArgumentOutOfRange_PeriodTooLarge = "Period must be less than 2^32-2."; // Metadata: 0x003C7D54
	public const string TaskScheduler_FromCurrentSynchronizationContext_NoCurrent = "The current SynchronizationContext may not be used as a TaskScheduler."; // Metadata: 0x003C7D78
	public const string TaskScheduler_ExecuteTask_WrongTaskScheduler = "ExecuteTask may not be called for a task which was previously queued to a different TaskScheduler."; // Metadata: 0x003C7DC2
	public const string TaskScheduler_InconsistentStateAfterTryExecuteTaskInline = "The TryExecuteTaskInline call to the underlying scheduler succeeded, but the task body was not invoked."; // Metadata: 0x003C7E28
	public const string TaskSchedulerException_ctor_DefaultMessage = "An exception was thrown by a TaskScheduler."; // Metadata: 0x003C7E93
	public const string Task_MultiTaskContinuation_FireOptions = "It is invalid to exclude specific continuation kinds for continuations off of multiple tasks."; // Metadata: 0x003C7EC2
	public const string Task_ContinueWith_ESandLR = "The specified TaskContinuationOptions combined LongRunning and ExecuteSynchronously.  Synchronous continuations should not be long running."; // Metadata: 0x003C7F23
	public const string Task_MultiTaskContinuation_EmptyTaskList = "The tasks argument contains no tasks."; // Metadata: 0x003C7FB2
	public const string Task_MultiTaskContinuation_NullTask = "The tasks argument included a null value."; // Metadata: 0x003C7FDB
	public const string Task_FromAsync_PreferFairness = "It is invalid to specify TaskCreationOptions.PreferFairness in calls to FromAsync."; // Metadata: 0x003C8008
	public const string Task_FromAsync_LongRunning = "It is invalid to specify TaskCreationOptions.LongRunning in calls to FromAsync."; // Metadata: 0x003C805E
	public const string AsyncMethodBuilder_InstanceNotInitialized = "The builder was not properly initialized."; // Metadata: 0x003C80B1
	public const string TaskT_TransitionToFinal_AlreadyCompleted = "An attempt was made to transition a task to a final state when it had already completed."; // Metadata: 0x003C80DE
	public const string TaskT_DebuggerNoResult = "{Not yet computed}"; // Metadata: 0x003C813A
	public const string OperationCanceled = "The operation was canceled."; // Metadata: 0x003C8150
	public const string CancellationToken_CreateLinkedToken_TokensIsEmpty = "No tokens were supplied."; // Metadata: 0x003C816F
	public const string CancellationTokenSource_Disposed = "The CancellationTokenSource has been disposed."; // Metadata: 0x003C818B
	public const string CancellationToken_SourceDisposed = "The CancellationTokenSource associated with this CancellationToken has been disposed."; // Metadata: 0x003C81BD
	public const string TaskExceptionHolder_UnknownExceptionType = "(Internal)Expected an Exception or an IEnumerable<Exception>"; // Metadata: 0x003C8216
	public const string TaskExceptionHolder_UnhandledException = "A Task\'s exception(s) were not observed either by Waiting on the Task or accessing its Exception property. As a result, the unobserved exception was rethrown by the finalizer thread."; // Metadata: 0x003C8256
	public const string Task_Delay_InvalidMillisecondsDelay = "The value needs to be either -1 (signifying an infinite timeout), 0 or a positive integer."; // Metadata: 0x003C8310
	public const string Task_Delay_InvalidDelay = "The value needs to translate in milliseconds to -1 (signifying an infinite timeout), 0 or a positive integer less than or equal to Int32.MaxValue."; // Metadata: 0x003C836E
	public const string Task_Dispose_NotCompleted = "A task may only be disposed if it is in a completion state (RanToCompletion, Faulted or Canceled)."; // Metadata: 0x003C8404
	public const string Task_WaitMulti_NullTask = "The tasks array included at least one null element."; // Metadata: 0x003C846A
	public const string Task_ContinueWith_NotOnAnything = "The specified TaskContinuationOptions excluded all continuation kinds."; // Metadata: 0x003C84A1
	public const string Task_RunSynchronously_AlreadyStarted = "RunSynchronously may not be called on a task that was already started."; // Metadata: 0x003C84EB
	public const string Task_ThrowIfDisposed = "The task has been disposed."; // Metadata: 0x003C8535
	public const string Task_RunSynchronously_TaskCompleted = "RunSynchronously may not be called on a task that has already completed."; // Metadata: 0x003C8554
	public const string Task_RunSynchronously_Promise = "RunSynchronously may not be called on a task not bound to a delegate, such as the task returned from an asynchronous method."; // Metadata: 0x003C85A0
	public const string Task_RunSynchronously_Continuation = "RunSynchronously may not be called on a continuation task."; // Metadata: 0x003C8620
	public const string Task_Start_AlreadyStarted = "Start may not be called on a task that was already started."; // Metadata: 0x003C865E
	public const string Task_Start_ContinuationTask = "Start may not be called on a continuation task."; // Metadata: 0x003C869D
	public const string Task_Start_Promise = "Start may not be called on a promise-style task."; // Metadata: 0x003C86D0
	public const string Task_Start_TaskCompleted = "Start may not be called on a task that has completed."; // Metadata: 0x003C8704
	public const string TaskCanceledException_ctor_DefaultMessage = "A task was canceled."; // Metadata: 0x003C873D
	public const string TaskCompletionSourceT_TrySetException_NoExceptions = "The exceptions collection was empty."; // Metadata: 0x003C8755
	public const string TaskCompletionSourceT_TrySetException_NullException = "The exceptions collection included at least one null element."; // Metadata: 0x003C877D
	public const string Argument_MinMaxValue = "\'{0}\' cannot be greater than {1}."; // Metadata: 0x003C87BE
	public const string ExecutionContext_ExceptionInAsyncLocalNotification = "An exception was not handled in an AsyncLocal<T> notification callback."; // Metadata: 0x003C87E3
	public const string InvalidOperation_WrongAsyncResultOrEndCalledMultiple = "Either the IAsyncResult object did not come from the corresponding async method on this type, or the End method was called multiple times with the same IAsyncResult."; // Metadata: 0x003C882E
	public const string SpinLock_IsHeldByCurrentThread = "Thread tracking is disabled."; // Metadata: 0x003C88D7
	public const string SpinLock_TryEnter_LockRecursionException = "The calling thread already holds the lock."; // Metadata: 0x003C88F7
	public const string SpinLock_Exit_SynchronizationLockException = "The calling thread does not hold the lock."; // Metadata: 0x003C8925
	public const string SpinLock_TryReliableEnter_ArgumentException = "The tookLock argument must be set to false before calling this method."; // Metadata: 0x003C8953
	public const string SpinLock_TryEnter_ArgumentOutOfRange = "The timeout must be a value between -1 and Int32.MaxValue, inclusive."; // Metadata: 0x003C899D
	public const string ManualResetEventSlim_Disposed = "The event has been disposed."; // Metadata: 0x003C89E6
	public const string ManualResetEventSlim_ctor_SpinCountOutOfRange = "The spinCount argument must be in the range 0 to {0}, inclusive."; // Metadata: 0x003C8A06
	public const string ManualResetEventSlim_ctor_TooManyWaiters = "There are too many threads currently waiting on the event. A maximum of {0} waiting threads are supported."; // Metadata: 0x003C8A4A
	public const string InvalidOperation_SendNotSupportedOnWindowsRTSynchronizationContext = "Send is not supported in the Windows Runtime SynchronizationContext"; // Metadata: 0x003C8AB8
	public const string InvalidOperation_SetData_OnlyOnce = "SetData can only be used to set the value of a given name once."; // Metadata: 0x003C8AFF
	public const string SemaphoreSlim_Disposed = "The semaphore has been disposed."; // Metadata: 0x003C8B42
	public const string SemaphoreSlim_Release_CountWrong = "The releaseCount argument must be greater than zero."; // Metadata: 0x003C8B66
	public const string SemaphoreSlim_Wait_TimeoutWrong = "The timeout must represent a value between -1 and Int32.MaxValue, inclusive."; // Metadata: 0x003C8B9E
	public const string SemaphoreSlim_ctor_MaxCountWrong = "The maximumCount argument must be a positive number. If a maximum is not required, use the constructor without a maxCount parameter."; // Metadata: 0x003C8BEE
	public const string SemaphoreSlim_ctor_InitialCountWrong = "The initialCount argument must be non-negative and less than or equal to the maximumCount."; // Metadata: 0x003C8C76
	public const string ThreadLocal_ValuesNotAvailable = "The ThreadLocal object is not tracking values. To use the Values property, use a ThreadLocal constructor that accepts the trackAllValues parameter and set the parameter to true."; // Metadata: 0x003C8CD4
	public const string ThreadLocal_Value_RecursiveCallsToValue = "ValueFactory attempted to access the Value property of this instance."; // Metadata: 0x003C8D89
	public const string ThreadLocal_Disposed = "The ThreadLocal object has been disposed."; // Metadata: 0x003C8DD2
	public const string LockRecursionException_WriteAfterReadNotAllowed = "Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock."; // Metadata: 0x003C8DFF
	public const string LockRecursionException_RecursiveWriteNotAllowed = "Recursive write lock acquisitions not allowed in this mode."; // Metadata: 0x003C8EEC
	public const string LockRecursionException_ReadAfterWriteNotAllowed = "A read lock may not be acquired with the write lock held in this mode."; // Metadata: 0x003C8F2B
	public const string LockRecursionException_RecursiveUpgradeNotAllowed = "Recursive upgradeable lock acquisitions not allowed in this mode."; // Metadata: 0x003C8F75
	public const string LockRecursionException_RecursiveReadNotAllowed = "Recursive read lock acquisitions not allowed in this mode."; // Metadata: 0x003C8FBA
	public const string SynchronizationLockException_IncorrectDispose = "The lock is being disposed while still being used. It either is being held by a thread and/or has active waiters waiting to acquire the lock."; // Metadata: 0x003C8FF8
	public const string SynchronizationLockException_MisMatchedWrite = "The write lock is being released without being held."; // Metadata: 0x003C9089
	public const string LockRecursionException_UpgradeAfterReadNotAllowed = "Upgradeable lock may not be acquired with read lock held."; // Metadata: 0x003C90C1
	public const string LockRecursionException_UpgradeAfterWriteNotAllowed = "Upgradeable lock may not be acquired with write lock held in this mode. Acquiring Upgradeable lock gives the ability to read along with an option to upgrade to a writer."; // Metadata: 0x003C90FE
	public const string SynchronizationLockException_MisMatchedUpgrade = "The upgradeable lock is being released without being held."; // Metadata: 0x003C91AB
	public const string SynchronizationLockException_MisMatchedRead = "The read lock is being released without being held."; // Metadata: 0x003C91E9
	public const string InvalidOperation_TimeoutsNotSupported = "Timeouts are not supported on this stream."; // Metadata: 0x003C9220
	public const string NotSupported_UnreadableStream = "Stream does not support reading."; // Metadata: 0x003C924E
	public const string NotSupported_UnwritableStream = "Stream does not support writing."; // Metadata: 0x003C9272
	public const string ObjectDisposed_StreamClosed = "Cannot access a closed Stream."; // Metadata: 0x003C9296
	public const string NotSupported_SubclassOverride = "Derived classes must provide an implementation."; // Metadata: 0x003C92B8
	public const string InvalidOperation_NoPublicRemoveMethod = "Cannot remove the event handler since no public remove method exists for the event."; // Metadata: 0x003C92EB
	public const string InvalidOperation_NoPublicAddMethod = "Cannot add the event handler since no public add method exists for the event."; // Metadata: 0x003C9342
	public const string SerializationException = "Serialization error."; // Metadata: 0x003C9393
	public const string Serialization_NotFound = "Member \'{0}\' was not found."; // Metadata: 0x003C93AB
	public const string Serialization_OptionalFieldVersionValue = "Version value must be positive."; // Metadata: 0x003C93CA
	public const string Serialization_SameNameTwice = "Cannot add the same member twice to a SerializationInfo object."; // Metadata: 0x003C93ED
	public const string NotSupported_AbstractNonCLS = "This non-CLS method is not implemented."; // Metadata: 0x003C9430
	public const string NotSupported_NoTypeInfo = "Cannot resolve {0} to a TypeInfo object."; // Metadata: 0x003C945B
	public const string Arg_CustomAttributeFormatException = "Binary format of the specified custom attribute was invalid."; // Metadata: 0x003C9487
	public const string Argument_InvalidMemberForNamedArgument = "The member must be either a field or a property."; // Metadata: 0x003C94C7
	public const string Arg_InvalidFilterCriteriaException = "Specified filter criteria was invalid."; // Metadata: 0x003C94FB
	public const string Arg_ParmArraySize = "Must specify one or more parameters."; // Metadata: 0x003C9525
	public const string Arg_MustBePointer = "Type must be a Pointer."; // Metadata: 0x003C954D
	public const string Arg_InvalidHandle = "Invalid handle."; // Metadata: 0x003C9568
	public const string Argument_InvalidEnum = "The Enum type should contain one and only one instance field."; // Metadata: 0x003C957B
	public const string Argument_MustHaveAttributeBaseClass = "Type passed in must be derived from System.Attribute or System.Attribute itself."; // Metadata: 0x003C95BC
	public const string InvalidFilterCriteriaException_CritString = "A String must be provided for the filter criteria."; // Metadata: 0x003C9610
	public const string InvalidFilterCriteriaException_CritInt = "An Int32 must be provided for the filter criteria."; // Metadata: 0x003C9646
	public const string InvalidOperation_NotSupportedOnWinRTEvent = "Adding or removing event handlers dynamically is not supported on WinRT events."; // Metadata: 0x003C967C
	public const string PlatformNotSupported_ReflectionOnly = "ReflectionOnly loading is not supported on this platform."; // Metadata: 0x003C96CF
	public const string PlatformNotSupported_OSXFileLocking = "Locking/unlocking file regions is not supported on this platform. Use FileShare on the entire file instead."; // Metadata: 0x003C970C
	public const string MissingMember_Name = "Member \'{0}\' not found."; // Metadata: 0x003C977B
	public const string MissingMethod_Name = "Method \'{0}\' not found."; // Metadata: 0x003C9796
	public const string MissingField_Name = "Field \'{0}\' not found."; // Metadata: 0x003C97B1
	public const string Format_StringZeroLength = "String cannot have zero length."; // Metadata: 0x003C97CB
	public const string Security_CannotReadRegistryData = "The time zone ID \'{0}\' was found on the local computer, but the application does not have permission to read the registry information."; // Metadata: 0x003C97EE
	public const string Security_InvalidAssemblyPublicKey = "Invalid assembly public key."; // Metadata: 0x003C9878
	public const string Security_RegistryPermission = "Requested registry access is not allowed."; // Metadata: 0x003C9898
	public const string ClassLoad_General = "Could not load type \'{0}\' from assembly \'{1}\'."; // Metadata: 0x003C98C5
	public const string ClassLoad_RankTooLarge = "\'{0}\' from assembly \'{1}\' has too many dimensions."; // Metadata: 0x003C98F7
	public const string ClassLoad_ExplicitGeneric = "Could not load type \'{0}\' from assembly \'{1}\' because generic types cannot have explicit layout."; // Metadata: 0x003C992D
	public const string ClassLoad_BadFormat = "Could not load type \'{0}\' from assembly \'{1}\' because the format is invalid."; // Metadata: 0x003C9991
	public const string ClassLoad_ValueClassTooLarge = "Array of type \'{0}\' from assembly \'{1}\' cannot be created because base value type is too large."; // Metadata: 0x003C99E1
	public const string ClassLoad_ExplicitLayout = "Could not load type \'{0}\' from assembly \'{1}\' because it contains an object field at offset \'{2}\' that is incorrectly aligned or overlapped by a non-object field."; // Metadata: 0x003C9A44
	public const string EE_MissingMethod = "Method not found: \'{0}\'."; // Metadata: 0x003C9AEA
	public const string EE_MissingField = "Field not found: \'{0}\'."; // Metadata: 0x003C9B06
	public const string UnauthorizedAccess_RegistryKeyGeneric_Key = "Access to the registry key \'{0}\' is denied."; // Metadata: 0x003C9B21
	public const string UnknownError_Num = "Unknown error \'{0}\'."; // Metadata: 0x003C9B50
	public const string Argument_NeedStructWithNoRefs = "The specified Type must be a struct containing no references."; // Metadata: 0x003C9B68
	public const string ArgumentNull_Buffer = "Buffer cannot be null."; // Metadata: 0x003C9BA9
	public const string ArgumentOutOfRange_AddressSpace = "The number of bytes cannot exceed the virtual address space on a 32 bit machine."; // Metadata: 0x003C9BC3
	public const string ArgumentOutOfRange_UIntPtrMaxMinusOne = "The length of the buffer must be less than the maximum UIntPtr value for your platform."; // Metadata: 0x003C9C17
	public const string Arg_BufferTooSmall = "Not enough space available in the buffer."; // Metadata: 0x003C9C72
	public const string InvalidOperation_MustCallInitialize = "You must call Initialize on this object instance before using it."; // Metadata: 0x003C9C9F
	public const string ArgumentException_BufferNotFromPool = "The buffer is not associated with this pool and may not be returned to it."; // Metadata: 0x003C9CE4
	public const string Argument_InvalidSafeBufferOffLen = "Offset and length were greater than the size of the SafeBuffer."; // Metadata: 0x003C9D32
	public const string Argument_InvalidSeekOrigin = "Invalid seek origin."; // Metadata: 0x003C9D75
	public const string Argument_NotEnoughBytesToRead = "There are not enough bytes remaining in the accessor to read at this position."; // Metadata: 0x003C9D8D
	public const string Argument_NotEnoughBytesToWrite = "There are not enough bytes remaining in the accessor to write at this position."; // Metadata: 0x003C9DDF
	public const string Argument_OffsetAndCapacityOutOfBounds = "Offset and capacity were greater than the size of the view."; // Metadata: 0x003C9E32
	public const string ArgumentOutOfRange_UnmanagedMemStreamLength = "UnmanagedMemoryStream length must be non-negative and less than 2^63 - 1 - baseAddress."; // Metadata: 0x003C9E71
	public const string Argument_UnmanagedMemAccessorWrapAround = "The UnmanagedMemoryAccessor capacity and offset would wrap around the high end of the address space."; // Metadata: 0x003C9ECC
	public const string ArgumentOutOfRange_StreamLength = "Stream length must be non-negative and less than 2^31 - 1 - origin."; // Metadata: 0x003C9F34
	public const string ArgumentOutOfRange_UnmanagedMemStreamWrapAround = "The UnmanagedMemoryStream capacity would wrap around the high end of the address space."; // Metadata: 0x003C9F7B
	public const string InvalidOperation_CalledTwice = "The method cannot be called twice on the same instance."; // Metadata: 0x003C9FD6
	public const string IO_FixedCapacity = "Unable to expand length of this stream beyond its capacity."; // Metadata: 0x003CA011
	public const string IO_SeekBeforeBegin = "An attempt was made to move the position before the beginning of the stream."; // Metadata: 0x003CA050
	public const string IO_StreamTooLong = "Stream was too long."; // Metadata: 0x003CA0A0
	public const string Arg_BadDecimal = "Read an invalid decimal value from the buffer."; // Metadata: 0x003CA0B8
	public const string NotSupported_Reading = "Accessor does not support reading."; // Metadata: 0x003CA0EA
	public const string NotSupported_UmsSafeBuffer = "This operation is not supported for an UnmanagedMemoryStream created from a SafeBuffer."; // Metadata: 0x003CA110
	public const string NotSupported_Writing = "Accessor does not support writing."; // Metadata: 0x003CA16B
	public const string NotSupported_UnseekableStream = "Stream does not support seeking."; // Metadata: 0x003CA191
	public const string IndexOutOfRange_UMSPosition = "Unmanaged memory stream position was beyond the capacity of the stream."; // Metadata: 0x003CA1B5
	public const string ObjectDisposed_StreamIsClosed = "Cannot access a closed Stream."; // Metadata: 0x003CA200
	public const string ObjectDisposed_ViewAccessorClosed = "Cannot access a closed accessor."; // Metadata: 0x003CA222
	public const string ArgumentOutOfRange_PositionLessThanCapacityRequired = "The position may not be greater or equal to the capacity of the accessor."; // Metadata: 0x003CA246
	public const string IO_EOF_ReadBeyondEOF = "Unable to read beyond the end of the stream."; // Metadata: 0x003CA293
	public const string Arg_EndOfStreamException = "Attempted to read past the end of the stream."; // Metadata: 0x003CA2C3
	public const string ObjectDisposed_FileClosed = "Cannot access a closed file."; // Metadata: 0x003CA2F4
	public const string Arg_InvalidSearchPattern = "Search pattern cannot contain \\\"..\\\" to move up directories and can be contained only internally in file/directory names, as in \\\"a..b\\\"."; // Metadata: 0x003CA314
	public const string ArgumentOutOfRange_FileLengthTooBig = "Specified file length was too large for the file system."; // Metadata: 0x003CA3A1
	public const string Argument_InvalidHandle = "\'handle\' has been disposed or is an invalid handle."; // Metadata: 0x003CA3DD
	public const string Argument_AlreadyBoundOrSyncHandle = "\'handle\' has already been bound to the thread pool, or was not opened for asynchronous I/O."; // Metadata: 0x003CA414
	public const string Argument_PreAllocatedAlreadyAllocated = "\'preAllocated\' is already in use."; // Metadata: 0x003CA473
	public const string Argument_NativeOverlappedAlreadyFree = "\'overlapped\' has already been freed."; // Metadata: 0x003CA498
	public const string Argument_NativeOverlappedWrongBoundHandle = "\'overlapped\' was not allocated by this ThreadPoolBoundHandle instance."; // Metadata: 0x003CA4C0
	public const string Arg_HandleNotAsync = "Handle does not support asynchronous operations. The parameters to the FileStream constructor may need to be changed to indicate that the handle was opened synchronously (that is, it was not opened for overlapped I/O)."; // Metadata: 0x003CA50A
	public const string ArgumentNull_Path = "Path cannot be null."; // Metadata: 0x003CA5E8
	public const string Argument_EmptyPath = "Empty path name is not legal."; // Metadata: 0x003CA600
	public const string Argument_InvalidFileModeAndAccessCombo = "Combining FileMode: {0} with FileAccess: {1} is invalid."; // Metadata: 0x003CA621
	public const string Argument_InvalidAppendMode = "Append access can be requested only in write-only mode."; // Metadata: 0x003CA65D
	public const string IO_UnknownFileName = "[Unknown]"; // Metadata: 0x003CA698
	public const string IO_FileStreamHandlePosition = "The OS handle\'s position is not what FileStream expected. Do not use a handle simultaneously in one FileStream and in Win32 code or another FileStream. This may cause data loss."; // Metadata: 0x003CA6A5
	public const string NotSupported_FileStreamOnNonFiles = "FileStream was asked to open a device that was not a file. For support for devices like \'com1:\' or \'lpt1:\', call CreateFile, then use the FileStream constructors that take an OS handle as an IntPtr."; // Metadata: 0x003CA75A
	public const string IO_BindHandleFailed = "BindHandle for ThreadPool failed on this handle."; // Metadata: 0x003CA824
	public const string Arg_HandleNotSync = "Handle does not support synchronous operations. The parameters to the FileStream constructor may need to be changed to indicate that the handle was opened asynchronously (that is, it was opened explicitly for overlapped I/O)."; // Metadata: 0x003CA858
	public const string IO_SetLengthAppendTruncate = "Unable to truncate data that previously existed in a file opened in Append mode."; // Metadata: 0x003CA93D
	public const string IO_SeekAppendOverwrite = "Unable seek backward to overwrite data that previously existed in a file opened in Append mode."; // Metadata: 0x003CA991
	public const string IO_FileTooLongOrHandleNotSync = "IO operation will not work. Most likely the file will become too long or the handle was not opened to support synchronous IO operations."; // Metadata: 0x003CA9F4
	public const string IndexOutOfRange_IORaceCondition = "Probable I/O race condition detected while copying memory. The I/O package is not thread safe by default. In multithreaded applications, a stream must be accessed in a thread-safe way, such as a thread-safe wrapper returned by TextReader\'s or TextWriter\'s Synchronized methods. This also applies to classes like StreamWriter and StreamReader."; // Metadata: 0x003CAA80
	public const string Arg_ResourceFileUnsupportedVersion = "The ResourceReader class does not know how to read this version of .resources files."; // Metadata: 0x003CABDA
	public const string Resources_StreamNotValid = "Stream is not a valid resource file."; // Metadata: 0x003CAC32
	public const string BadImageFormat_ResourcesHeaderCorrupted = "Corrupt .resources file. Unable to read resources from this file because of invalid header information. Try regenerating the .resources file."; // Metadata: 0x003CAC5A
	public const string Argument_StreamNotReadable = "Stream was not readable."; // Metadata: 0x003CACEB
	public const string BadImageFormat_NegativeStringLength = "Corrupt .resources file. String length must be non-negative."; // Metadata: 0x003CAD07
	public const string BadImageFormat_ResourcesNameInvalidOffset = "Corrupt .resources file. The Invalid offset into name section is ."; // Metadata: 0x003CAD47
	public const string BadImageFormat_TypeMismatch = "Corrupt .resources file.  The specified type doesn\'t match the available data in the stream."; // Metadata: 0x003CAD8D
	public const string BadImageFormat_ResourceNameCorrupted_NameIndex = "Corrupt .resources file. The resource name for name index that extends past the end of the stream is "; // Metadata: 0x003CADED
	public const string BadImageFormat_ResourcesDataInvalidOffset = "Corrupt .resources file. Invalid offset  into data section is "; // Metadata: 0x003CAE56
	public const string Format_Bad7BitInt32 = "Too many bytes in what should have been a 7 bit encoded Int32."; // Metadata: 0x003CAE98
	public const string BadImageFormat_InvalidType = "Corrupt .resources file.  The specified type doesn\'t exist."; // Metadata: 0x003CAEDA
	public const string ResourceReaderIsClosed = "ResourceReader is closed."; // Metadata: 0x003CAF19
	public const string Arg_MissingManifestResourceException = "Unable to find manifest resource."; // Metadata: 0x003CAF36
	public const string Serialization_MissingKeys = "The keys for this dictionary are missing."; // Metadata: 0x003CAF5B
	public const string Serialization_NullKey = "One of the serialized keys is null."; // Metadata: 0x003CAF88
	public const string NotSupported_KeyCollectionSet = "Mutating a key collection derived from a dictionary is not allowed."; // Metadata: 0x003CAFAF
	public const string NotSupported_ValueCollectionSet = "Mutating a value collection derived from a dictionary is not allowed."; // Metadata: 0x003CAFF6
	public const string IO_IO_StreamTooLong = "Stream was too long."; // Metadata: 0x003CB03F
	public const string UnauthorizedAccess_MemStreamBuffer = "MemoryStream\'s internal buffer cannot be accessed."; // Metadata: 0x003CB057
	public const string NotSupported_MemStreamNotExpandable = "Memory stream is not expandable."; // Metadata: 0x003CB08D
	public const string IO_IO_SeekBeforeBegin = "An attempt was made to move the position before the beginning of the stream."; // Metadata: 0x003CB0B1
	public const string ArgumentNull_Stream = "Stream cannot be null."; // Metadata: 0x003CB101
	public const string IO_IO_InvalidStringLen_Len = "BinaryReader encountered an invalid string length of {0} characters."; // Metadata: 0x003CB11B
	public const string ArgumentOutOfRange_BinaryReaderFillBuffer = "The number of bytes requested does not fit into BinaryReader\'s internal buffer."; // Metadata: 0x003CB163
	public const string Serialization_InsufficientDeserializationState = "Insufficient state to deserialize the object. Missing field \'{0}\'."; // Metadata: 0x003CB1B6
	public const string NotSupported_UnitySerHolder = "The UnitySerializationHolder object is designed to transmit information about other types and is not serializable itself."; // Metadata: 0x003CB1FC
	public const string Serialization_UnableToFindModule = "The given module {0} cannot be found within the assembly {1}."; // Metadata: 0x003CB279
	public const string Argument_InvalidUnity = "Invalid Unity type."; // Metadata: 0x003CB2BA
	public const string InvalidOperation_InvalidHandle = "The handle is invalid."; // Metadata: 0x003CB2D1
	public const string PlatformNotSupported_NamedSynchronizationPrimitives = "The named version of this synchronization primitive is not supported on this platform."; // Metadata: 0x003CB2EB
	public const string InvalidOperation_EmptyQueue = "Queue empty."; // Metadata: 0x003CB345
	public const string Overflow_MutexReacquireCount = "The current thread attempted to reacquire a mutex that has reached its maximum acquire count."; // Metadata: 0x003CB355
	public const string Serialization_InsufficientState = "Insufficient state to return the real object."; // Metadata: 0x003CB3B6
	public const string Serialization_UnknownMember = "Cannot get the member \'{0}\'."; // Metadata: 0x003CB3E7
	public const string Serialization_NullSignature = "The method signature cannot be null."; // Metadata: 0x003CB407
	public const string Serialization_MemberTypeNotRecognized = "Unknown member type."; // Metadata: 0x003CB42F
	public const string Serialization_BadParameterInfo = "Non existent ParameterInfo. Position bigger than member\'s parameters length."; // Metadata: 0x003CB447
	public const string Serialization_NoParameterInfo = "Serialized member does not have a ParameterInfo."; // Metadata: 0x003CB497
	public const string ArgumentNull_Assembly = "Assembly cannot be null."; // Metadata: 0x003CB4CB
	public const string Arg_InvalidNeutralResourcesLanguage_Asm_Culture = "The NeutralResourcesLanguageAttribute on the assembly \"{0}\" specifies an invalid culture name: \"{1}\"."; // Metadata: 0x003CB4E7
	public const string Arg_InvalidNeutralResourcesLanguage_FallbackLoc = "The NeutralResourcesLanguageAttribute specifies an invalid or unrecognized ultimate resource fallback location: \"{0}\"."; // Metadata: 0x003CB550
	public const string Arg_InvalidSatelliteContract_Asm_Ver = "Satellite contract version attribute on the assembly \'{0}\' specifies an invalid version: {1}."; // Metadata: 0x003CB5CA
	public const string Arg_ResMgrNotResSet = "Type parameter must refer to a subclass of ResourceSet."; // Metadata: 0x003CB62B
	public const string BadImageFormat_ResourceNameCorrupted = "Corrupt .resources file. A resource name extends past the end of the stream."; // Metadata: 0x003CB666
	public const string BadImageFormat_ResourcesNameTooLong = "Corrupt .resources file. Resource name extends past the end of the file."; // Metadata: 0x003CB6B6
	public const string InvalidOperation_ResMgrBadResSet_Type = "\'{0}\': ResourceSet derived classes must provide a constructor that takes a String file name and a constructor that takes a Stream."; // Metadata: 0x003CB702
	public const string InvalidOperation_ResourceNotStream_Name = "Resource \'{0}\' was not a Stream - call GetObject instead."; // Metadata: 0x003CB788
	public const string MissingManifestResource_MultipleBlobs = "A case-insensitive lookup for resource file \"{0}\" in assembly \"{1}\" found multiple entries. Remove the duplicates or specify the exact case."; // Metadata: 0x003CB7C5
	public const string MissingManifestResource_NoNeutralAsm = "Could not find any resources appropriate for the specified culture or the neutral culture.  Make sure \"{0}\" was correctly embedded or linked into assembly \"{1}\" at compile time, or that all the satellite assemblies required are loadable and fully signed."; // Metadata: 0x003CB855
	public const string MissingManifestResource_NoNeutralDisk = "Could not find any resources appropriate for the specified culture (or the neutral culture) on disk."; // Metadata: 0x003CB957
	public const string MissingManifestResource_NoPRIresources = "Unable to open Package Resource Index."; // Metadata: 0x003CB9BF
	public const string MissingManifestResource_ResWFileNotLoaded = "Unable to load resources for resource file \"{0}\" in package \"{1}\"."; // Metadata: 0x003CB9E9
	public const string MissingSatelliteAssembly_Culture_Name = "The satellite assembly named \"{1}\" for fallback culture \"{0}\" either could not be found or could not be loaded. This is generally a setup problem. Please consider reinstalling or repairing the application."; // Metadata: 0x003CBA2F
	public const string MissingSatelliteAssembly_Default = "Resource lookup fell back to the ultimate fallback resources in a satellite assembly, but that satellite either was not found or could not be loaded. Please consider reinstalling or repairing the application."; // Metadata: 0x003CBB00
	public const string NotSupported_ObsoleteResourcesFile = "Found an obsolete .resources file in assembly \'{0}\'. Rebuild that .resources file then rebuild that assembly."; // Metadata: 0x003CBBD4
	public const string NotSupported_ResourceObjectSerialization = "Cannot read resources that depend on serialization."; // Metadata: 0x003CBC45
	public const string ObjectDisposed_ResourceSet = "Cannot access a closed resource set."; // Metadata: 0x003CBC7C
	public const string Arg_ResourceNameNotExist = "The specified resource name \"{0}\" does not exist in the resource file."; // Metadata: 0x003CBCA4
	public const string BadImageFormat_ResourceDataLengthInvalid = "Corrupt .resources file.  The specified data length \'{0}\' is not a valid position in the stream."; // Metadata: 0x003CBCEE
	public const string BadImageFormat_ResourcesIndexTooLong = "Corrupt .resources file. String for name index \'{0}\' extends past the end of the file."; // Metadata: 0x003CBD52
	public const string InvalidOperation_ResourceNotString_Name = "Resource \'{0}\' was not a String - call GetObject instead."; // Metadata: 0x003CBDAC
	public const string InvalidOperation_ResourceNotString_Type = "Resource was of type \'{0}\' instead of String - call GetObject instead."; // Metadata: 0x003CBDE9
	public const string NotSupported_WrongResourceReader_Type = "This .resources file should not be read with this reader. The resource reader type is \"{0}\"."; // Metadata: 0x003CBE33
	public const string Arg_MustBeDelegate = "Type must derive from Delegate."; // Metadata: 0x003CBE93
	public const string NotSupported_GlobalMethodSerialization = "Serialization of global methods (including implicit serialization via the use of asynchronous delegates) is not supported."; // Metadata: 0x003CBEB6
	public const string NotSupported_DelegateSerHolderSerial = "DelegateSerializationHolder objects are designed to represent a delegate during serialization and are not serializable themselves."; // Metadata: 0x003CBF34
	public const string DelegateSer_InsufficientMetadata = "The delegate cannot be serialized properly due to missing metadata for the target method."; // Metadata: 0x003CBFBA
	public const string Argument_NoUninitializedStrings = "Uninitialized Strings cannot be created."; // Metadata: 0x003CC017
	public const string ArgumentOutOfRangeException_NoGCRegionSizeTooLarge = "totalSize is too large. For more information about setting the maximum size, see \\\"Latency Modes\\\" in http://go.microsoft.com/fwlink/?LinkId=522706."; // Metadata: 0x003CC043
	public const string InvalidOperationException_AlreadyInNoGCRegion = "The NoGCRegion mode was already in progress."; // Metadata: 0x003CC0DB
	public const string InvalidOperationException_NoGCRegionAllocationExceeded = "Allocated memory exceeds specified memory for NoGCRegion mode."; // Metadata: 0x003CC10B
	public const string InvalidOperationException_NoGCRegionInduced = "Garbage collection was induced in NoGCRegion mode."; // Metadata: 0x003CC14D
	public const string InvalidOperationException_NoGCRegionNotInProgress = "NoGCRegion mode must be set."; // Metadata: 0x003CC183
	public const string InvalidOperationException_SetLatencyModeNoGC = "The NoGCRegion mode is in progress. End it and then set a different mode."; // Metadata: 0x003CC1A3
	public const string InvalidOperation_NotWithConcurrentGC = "This API is not available when the concurrent GC is enabled."; // Metadata: 0x003CC1F0
	public const string ThreadState_AlreadyStarted = "Thread is running or terminated; it cannot restart."; // Metadata: 0x003CC230
	public const string ThreadState_Dead_Priority = "Thread is dead; priority cannot be accessed."; // Metadata: 0x003CC267
	public const string ThreadState_Dead_State = "Thread is dead; state cannot be accessed."; // Metadata: 0x003CC297
	public const string ThreadState_NotStarted = "Thread has not been started."; // Metadata: 0x003CC2C4
	public const string ThreadState_SetPriorityFailed = "Unable to set thread priority."; // Metadata: 0x003CC2E4
	public const string Serialization_InvalidFieldState = "Object fields may not be properly initialized."; // Metadata: 0x003CC306
	public const string Acc_CreateAbst = "Cannot create an abstract class."; // Metadata: 0x003CC338
	public const string Acc_CreateGeneric = "Cannot create a type for which Type.ContainsGenericParameters is true."; // Metadata: 0x003CC35C
	public const string Argument_InvalidValue = "Value was invalid."; // Metadata: 0x003CC3A6
	public const string NotSupported_ManagedActivation = "Cannot create uninitialized instances of types requiring managed activation."; // Metadata: 0x003CC3BC
	public const string PlatformNotSupported_ResourceManager_ResWFileUnsupportedMethod = "ResourceManager method \'{0}\' is not supported when reading from .resw resource files."; // Metadata: 0x003CC40C
	public const string PlatformNotSupported_ResourceManager_ResWFileUnsupportedProperty = "ResourceManager property \'{0}\' is not supported when reading from .resw resource files."; // Metadata: 0x003CC465
	public const string Serialization_NonSerType = "Type \'{0}\' in Assembly \'{1}\' is not marked as serializable."; // Metadata: 0x003CC4C0
	public const string InvalidCast_DBNull = "Object cannot be cast to DBNull."; // Metadata: 0x003CC4FF
	public const string NotSupported_NYI = "This feature is not currently implemented."; // Metadata: 0x003CC523
	public const string Delegate_GarbageCollected = "The corresponding delegate has been garbage collected. Please make sure the delegate is still referenced by managed code when you are using the marshalled native function pointer."; // Metadata: 0x003CC551
	public const string Arg_AmbiguousMatchException = "Ambiguous match found."; // Metadata: 0x003CC608
	public const string NotSupported_ChangeType = "ChangeType operation is not supported."; // Metadata: 0x003CC622
	public const string Arg_EmptyArray = "Array may not be empty."; // Metadata: 0x003CC64C
	public const string MissingMember = "Member not found."; // Metadata: 0x003CC667
	public const string MissingField = "Field not found."; // Metadata: 0x003CC67C
	public const string InvalidCast_FromDBNull = "Object cannot be cast from DBNull to other types."; // Metadata: 0x003CC690
	public const string NotSupported_DBNullSerial = "Only one DBNull instance may exist, and calls to DBNull deserialization methods are not allowed."; // Metadata: 0x003CC6C5
	public const string Serialization_StringBuilderCapacity = "The serialized Capacity property of StringBuilder must be positive, less than or equal to MaxCapacity and greater than or equal to the String length."; // Metadata: 0x003CC729
	public const string Serialization_StringBuilderMaxCapacity = "The serialized MaxCapacity property of StringBuilder must be positive and greater than or equal to the String length."; // Metadata: 0x003CC7C2
	public const string PlatformNotSupported_Remoting = "Remoting is not supported on this platform."; // Metadata: 0x003CC83B
	public const string PlatformNotSupported_StrongNameSigning = "Strong-name signing is not supported on this platform."; // Metadata: 0x003CC86A
	public const string Serialization_MissingDateTimeData = "Invalid serialized DateTime data. Unable to find \'ticks\' or \'dateData\'."; // Metadata: 0x003CC8A4
	public const string Serialization_DateTimeTicksOutOfRange = "Invalid serialized DateTime data. Ticks must be between DateTime.MinValue.Ticks and DateTime.MaxValue.Ticks."; // Metadata: 0x003CC8EF
	public const string Arg_InvalidANSIString = "The ANSI string passed in could not be converted from the default ANSI code page to Unicode."; // Metadata: 0x003CC95F
	public const string Arg_ExpectedNulTermination = "The value passed was not NUL terminated."; // Metadata: 0x003CC9BF
	public const string PlatformNotSupported_ArgIterator = "ArgIterator is not supported on this platform."; // Metadata: 0x003CC9EB
	public const string Arg_TypeUnloadedException = "Type had been unloaded."; // Metadata: 0x003CCA1D
	public const string Overflow_Currency = "Value was either too large or too small for a Currency."; // Metadata: 0x003CCA38
	public const string PlatformNotSupported_SecureBinarySerialization = "Secure binary serialization is not supported on this platform."; // Metadata: 0x003CCA73
	public const string Serialization_InvalidPtrValue = "An IntPtr or UIntPtr with an eight byte value cannot be deserialized on a machine with a four byte word size."; // Metadata: 0x003CCAB5
	public const string EventSource_ListenerNotFound = "Listener not found."; // Metadata: 0x003CCB26
	public const string EventSource_ToString = "EventSource({0}, {1})"; // Metadata: 0x003CCB3D
	public const string EventSource_ImplementGetMetadata = "Please implement the GetMetadata method in your derived class"; // Metadata: 0x003CCB56
	public const string EventSource_NeedGuid = "The Guid of an EventSource must be non zero."; // Metadata: 0x003CCB97
	public const string EventSource_NeedName = "The name of an EventSource must not be null."; // Metadata: 0x003CCBC7
	public const string EventSource_NeedDescriptors = "The descriptor of an EventSource must be non-null."; // Metadata: 0x003CCBF7
	public const string EventSource_NeedManifest = "The manifest of an EventSource must be non-null."; // Metadata: 0x003CCC2D
	public const string EventSource_EventSourceGuidInUse = "An instance of EventSource with Guid {0} already exists."; // Metadata: 0x003CCC61
	public const string EventSource_ListenerWriteFailure = "An error occurred when writing to a listener."; // Metadata: 0x003CCC9D
	public const string EventSource_NoManifest = "A manifest could not be generated for this EventSource because it contains one or more ill-formed event methods."; // Metadata: 0x003CCCCE
	public const string Argument_StreamNotWritable = "Stream was not writable."; // Metadata: 0x003CCD42
	public const string Arg_SurrogatesNotAllowedAsSingleChar = "Unicode surrogate characters must be written out as pairs together in the same call, not individually. Consider passing in a character array instead."; // Metadata: 0x003CCD5E
	public const string CustomAttributeFormat_InvalidFieldFail = "\'{0}\' field specified was not found."; // Metadata: 0x003CCDF7
	public const string CustomAttributeFormat_InvalidPropertyFail = "\'{0}\' property specified was not found."; // Metadata: 0x003CCE1F
	public const string NotSupported_CannotCallEqualsOnSpan = "Equals() on Span and ReadOnlySpan is not supported. Use operator== instead."; // Metadata: 0x003CCE4A
	public const string NotSupported_CannotCallGetHashCodeOnSpan = "GetHashCode() on Span and ReadOnlySpan is not supported."; // Metadata: 0x003CCE99
	public const string Argument_DestinationTooShort = "Destination is too short."; // Metadata: 0x003CCED5
	public const string Argument_InvalidTypeWithPointersNotSupported = "Cannot use type \'{0}\'. Only value types without pointers or references are supported."; // Metadata: 0x003CCEF2
	public const string ArrayTypeMismatch_ConstrainedCopy = "Array.ConstrainedCopy will only work on array types that are provably compatible, without any form of boxing, unboxing, widening, or casting of each array element.  Change the array types (i.e., copy a Derived[] to a Base[]), or use a mitigation strategy in the CER for Array.Copy\'s less powerful reliability contract, such as cloning the array or throwing away the potentially corrupt destination array."; // Metadata: 0x003CCF4B
	public const string Arg_DllNotFoundException = "Dll was not found."; // Metadata: 0x003CD0E3
	public const string Arg_DllNotFoundExceptionParameterized = "Unable to load DLL \'{0}\': The specified module could not be found."; // Metadata: 0x003CD0F9
	public const string WrongSizeArrayInNStruct = "Type could not be marshaled because the length of an embedded array instance does not match the declared length in the layout."; // Metadata: 0x003CD13F
	public const string Arg_InteropMarshalUnmappableChar = "Cannot marshal: Encountered unmappable character."; // Metadata: 0x003CD1C1
	public const string Arg_MarshalDirectiveException = "Marshaling directives are invalid."; // Metadata: 0x003CD1F6
	public const string BlockingCollection_Add_ConcurrentCompleteAdd = "CompleteAdding may not be used concurrently with additions to the collection."; // Metadata: 0x003CD21C
	public const string BlockingCollection_Add_Failed = "The underlying collection didn\'t accept the item."; // Metadata: 0x003CD26D
	public const string BlockingCollection_CantAddAnyWhenCompleted = "At least one of the specified collections is marked as complete with regards to additions."; // Metadata: 0x003CD2A2
	public const string BlockingCollection_CantTakeAnyWhenAllDone = "All collections are marked as complete with regards to additions."; // Metadata: 0x003CD300
	public const string BlockingCollection_CantTakeWhenDone = "The collection argument is empty and has been marked as complete with regards to additions."; // Metadata: 0x003CD345
	public const string BlockingCollection_Completed = "The collection has been marked as complete with regards to additions."; // Metadata: 0x003CD3A4
	public const string BlockingCollection_CopyTo_IncorrectType = "The array argument is of the incorrect type."; // Metadata: 0x003CD3ED
	public const string BlockingCollection_CopyTo_MultiDim = "The array argument is multidimensional."; // Metadata: 0x003CD41D
	public const string BlockingCollection_CopyTo_NonNegative = "The index argument must be greater than or equal zero."; // Metadata: 0x003CD448
	public const string Collection_CopyTo_TooManyElems = "The number of elements in the collection is greater than the available space from index to the end of the destination array."; // Metadata: 0x003CD482
	public const string BlockingCollection_ctor_BoundedCapacityRange = "The boundedCapacity argument must be positive."; // Metadata: 0x003CD502
	public const string BlockingCollection_ctor_CountMoreThanCapacity = "The collection argument contains more items than are allowed by the boundedCapacity."; // Metadata: 0x003CD534
	public const string BlockingCollection_Disposed = "The collection has been disposed."; // Metadata: 0x003CD58C
	public const string BlockingCollection_Take_CollectionModified = "The underlying collection was modified from outside of the BlockingCollection<T>."; // Metadata: 0x003CD5B1
	public const string BlockingCollection_TimeoutInvalid = "The specified timeout must represent a value between -1 and {0}, inclusive."; // Metadata: 0x003CD606
	public const string BlockingCollection_ValidateCollectionsArray_DispElems = "The collections argument contains at least one disposed element."; // Metadata: 0x003CD655
	public const string BlockingCollection_ValidateCollectionsArray_LargeSize = "The collections length is greater than the supported range for 32 bit machine."; // Metadata: 0x003CD699
	public const string BlockingCollection_ValidateCollectionsArray_NullElems = "The collections argument contains at least one null element."; // Metadata: 0x003CD6EB
	public const string BlockingCollection_ValidateCollectionsArray_ZeroSize = "The collections argument is a zero-length array."; // Metadata: 0x003CD72B
	public const string Common_OperationCanceled = "The operation was canceled."; // Metadata: 0x003CD75F
	public const string ConcurrentBag_Ctor_ArgumentNullException = "The collection argument is null."; // Metadata: 0x003CD77E
	public const string ConcurrentBag_CopyTo_ArgumentNullException = "The array argument is null."; // Metadata: 0x003CD7A2
	public const string Collection_CopyTo_ArgumentOutOfRangeException = "The index argument must be greater than or equal zero."; // Metadata: 0x003CD7C1
	public const string ConcurrentCollection_SyncRoot_NotSupported = "The SyncRoot property may not be used for the synchronization of concurrent collections."; // Metadata: 0x003CD7FB
	public const string ConcurrentDictionary_ArrayIncorrectType = "The array is multidimensional, or the type parameter for the set cannot be cast automatically to the type of the destination array."; // Metadata: 0x003CD857
	public const string ConcurrentDictionary_SourceContainsDuplicateKeys = "The source argument contains duplicate keys."; // Metadata: 0x003CD8DE
	public const string ConcurrentDictionary_ConcurrencyLevelMustBePositive = "The concurrencyLevel argument must be positive."; // Metadata: 0x003CD90E
	public const string ConcurrentDictionary_CapacityMustNotBeNegative = "The capacity argument must be greater than or equal to zero."; // Metadata: 0x003CD941
	public const string ConcurrentDictionary_IndexIsNegative = "The index argument is less than zero."; // Metadata: 0x003CD981
	public const string ConcurrentDictionary_ArrayNotLargeEnough = "The index is equal to or greater than the length of the array, or the number of elements in the dictionary is greater than the available space from index to the end of the destination array."; // Metadata: 0x003CD9AA
	public const string ConcurrentDictionary_KeyAlreadyExisted = "The key already existed in the dictionary."; // Metadata: 0x003CDA6C
	public const string ConcurrentDictionary_ItemKeyIsNull = "TKey is a reference type and item.Key is null."; // Metadata: 0x003CDA9A
	public const string ConcurrentDictionary_TypeOfKeyIncorrect = "The key was of an incorrect type for this dictionary."; // Metadata: 0x003CDACC
	public const string ConcurrentDictionary_TypeOfValueIncorrect = "The value was of an incorrect type for this dictionary."; // Metadata: 0x003CDB05
	public const string ConcurrentStack_PushPopRange_CountOutOfRange = "The count argument must be greater than or equal to zero."; // Metadata: 0x003CDB40
	public const string ConcurrentStack_PushPopRange_InvalidCount = "The sum of the startIndex and count arguments must be less than or equal to the collection\'s Count."; // Metadata: 0x003CDB7D
	public const string ConcurrentStack_PushPopRange_StartOutOfRange = "The startIndex argument must be greater than or equal to zero."; // Metadata: 0x003CDBE4
	public const string Partitioner_DynamicPartitionsNotSupported = "Dynamic partitions are not supported by this partitioner."; // Metadata: 0x003CDC26
	public const string PartitionerStatic_CanNotCallGetEnumeratorAfterSourceHasBeenDisposed = "Can not call GetEnumerator on partitions after the source enumerable is disposed"; // Metadata: 0x003CDC63
	public const string PartitionerStatic_CurrentCalledBeforeMoveNext = "MoveNext must be called at least once before calling Current."; // Metadata: 0x003CDCB7
	public const string ConcurrentBag_Enumerator_EnumerationNotStartedOrAlreadyFinished = "Enumeration has either not started or has already finished."; // Metadata: 0x003CDCF8
	public const string ArrayTypeMustBeExactMatch = "The array type must be exactly {0}."; // Metadata: 0x003CDD37
	public const string CannotCallEqualsOnSpan = "Equals() on Span and ReadOnlySpan is not supported. Use operator== instead."; // Metadata: 0x003CDD5E
	public const string CannotCallGetHashCodeOnSpan = "GetHashCode() on Span and ReadOnlySpan is not supported."; // Metadata: 0x003CDDAD
	public const string Argument_EmptyValue = "Value cannot be empty."; // Metadata: 0x003CDDE9
	public const string PlatformNotSupported_RuntimeInformation = "RuntimeInformation is not supported for Portable Class Libraries."; // Metadata: 0x003CDE03
	public const string MemoryDisposed = "Memory<T> has been disposed."; // Metadata: 0x003CDE48
	public const string OutstandingReferences = "Release all references before disposing this instance."; // Metadata: 0x003CDE68

	// Methods
	internal static string GetString(string name, params /* 0x00A20F88-0x00A20F98 */ object[] args) => default; // 0x01088C28-0x01088CA8
	internal static string GetString(CultureInfo culture, string name, params /* 0x00A20F98-0x00A20FA8 */ object[] args) => default; // 0x01088CA8-0x01088CB0
	internal static string GetString(string name) => default; // 0x01088CB0-0x01088CB4
	internal static string GetString(CultureInfo culture, string name) => default; // 0x01088CB4-0x01088CBC
	internal static string Format(string resourceFormat, params /* 0x00A20FA8-0x00A20FB8 */ object[] args) => default; // 0x01088CBC-0x01088D54
	internal static string Format(string resourceFormat, object p1) => default; // 0x01088D54-0x01088DD4
	internal static string Format(string resourceFormat, object p1, object p2) => default; // 0x01088DD4-0x01088E5C
	internal static string Format(string resourceFormat, object p1, object p2, object p3) => default; // 0x01088E5C-0x01088EF4
}

internal static class AssemblyRef // TypeDefIndex: 2873
{
	// Fields
	internal const string SystemConfiguration = "System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F15F3
	internal const string System = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003F164E
	public const string EcmaPublicKey = "b77a5c561934e089"; // Metadata: 0x003F169B
	public const string FrameworkPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9"; // Metadata: 0x003F16AF
	public const string FrameworkPublicKeyFull2 = "00240000048000009400000006020000002400005253413100040000010001008D56C76F9E8649383049F383C44BE0EC204181822A6C31CF5EB7EF486944D032188EA1D3920763712CCB12D75FB77E9811149E6148E5D32FBAAB37611C1878DDC19E20EF135D0CB2CFF2BFEC3D115810C3D9069638FE4BE215DBF795861920E5AB6F7DB2E2CEEF136AC23D5DD2BF031700AEC232F6C6B1C785B4305C123B37AB"; // Metadata: 0x003F17F3
	public const string MicrosoftPublicKey = "b03f5f7f11d50a3a"; // Metadata: 0x003F1937
	public const string MicrosoftJScript = "Microsoft.JScript, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F194B
	public const string MicrosoftVSDesigner = "Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F19A3
	public const string SystemData = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003F19FE
	public const string SystemDesign = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F1A50
	public const string SystemDrawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F1AA4
	public const string SystemWeb = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F1AF9
	public const string SystemWebExtensions = "System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003F1B4A
	public const string SystemWindowsForms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003F1BA6
}

internal static class Consts // TypeDefIndex: 2874
{
	// Fields
	public const string MonoVersion = "5.11.0.0"; // Metadata: 0x003F1C01
	public const string MonoCompany = "Mono development team"; // Metadata: 0x003F1C0D
	public const string MonoProduct = "Mono Common Language Infrastructure"; // Metadata: 0x003F1C26
	public const string MonoCopyright = "(c) Various Mono authors"; // Metadata: 0x003F1C4D
	public const int MonoCorlibVersion = 1051100001; // Metadata: 0x003F1C69
	public const string FxVersion = "4.0.0.0"; // Metadata: 0x003F1C6D
	public const string FxFileVersion = "4.0.30319.17020"; // Metadata: 0x003F1C78
	public const string EnvironmentVersion = "4.0.30319.17020"; // Metadata: 0x003F1C8B
	public const string VsVersion = "0.0.0.0"; // Metadata: 0x003F1C9E
	public const string VsFileVersion = "11.0.0.0"; // Metadata: 0x003F1CA9
	private const string PublicKeyToken = "b77a5c561934e089"; // Metadata: 0x003F1CB5
	public const string AssemblyI18N = "I18N, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x003F1CC9
	public const string AssemblyMicrosoft_JScript = "Microsoft.JScript, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F1D14
	public const string AssemblyMicrosoft_VisualStudio = "Microsoft.VisualStudio, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F1D6C
	public const string AssemblyMicrosoft_VisualStudio_Web = "Microsoft.VisualStudio.Web, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F1DC9
	public const string AssemblyMicrosoft_VSDesigner = "Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F1E2A
	public const string AssemblyMono_Http = "Mono.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x003F1E85
	public const string AssemblyMono_Posix = "Mono.Posix, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x003F1ED5
	public const string AssemblyMono_Security = "Mono.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x003F1F26
	public const string AssemblyMono_Messaging_RabbitMQ = "Mono.Messaging.RabbitMQ, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x003F1F7A
	public const string AssemblyCorlib = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003F1FD8
	public const string AssemblySystem = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003F2027
	public const string AssemblySystem_Data = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003F2074
	public const string AssemblySystem_Design = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F20C6
	public const string AssemblySystem_DirectoryServices = "System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F211A
	public const string AssemblySystem_Drawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F2179
	public const string AssemblySystem_Drawing_Design = "System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F21CE
	public const string AssemblySystem_Messaging = "System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F222A
	public const string AssemblySystem_Security = "System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F2281
	public const string AssemblySystem_ServiceProcess = "System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F22D7
	public const string AssemblySystem_Web = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x003F2333
	public const string AssemblySystem_Windows_Forms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003F2384
	public const string AssemblySystem_2_0 = "System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003F23DF
	public const string AssemblySystemCore_3_5 = "System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003F242C
	public const string AssemblySystem_Core = "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003F247E
	public const string WindowsBase_3_0 = "WindowsBase, Version=3.0.0.0, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003F24D0
	public const string AssemblyWindowsBase = "WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003F2511
	public const string AssemblyPresentationCore_3_5 = "PresentationCore, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003F2563
	public const string AssemblyPresentationCore_4_0 = "PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003F25BA
	public const string AssemblyPresentationFramework_3_5 = "PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x003F2611
	public const string AssemblySystemServiceModel_3_0 = "System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x003F266D
}

internal static class SR // TypeDefIndex: 2875
{
	// Methods
	internal static string GetString(string name, params /* 0x00A30A94-0x00A30AA4 */ object[] args) => default; // 0x00FC5804-0x00FC5884
	internal static string GetString(CultureInfo culture, string name, params /* 0x00A30AA4-0x00A30AB4 */ object[] args) => default; // 0x00FC5884-0x00FC588C
	internal static string GetString(string name) => default; // 0x00FC588C-0x00FC5890
	internal static string GetString(CultureInfo culture, string name) => default; // 0x00FC5890-0x00FC5898
	internal static string Format(string resourceFormat, params /* 0x00A30AB4-0x00A30AC4 */ object[] args) => default; // 0x00FC5898-0x00FC5930
	internal static string Format(string resourceFormat, object p1) => default; // 0x00FC5930-0x00FC59B0
	internal static string Format(string resourceFormat, object p1, object p2) => default; // 0x00FC59B0-0x00FC5A38
	internal static string Format(string resourceFormat, object p1, object p2, object p3) => default; // 0x00FC5A38-0x00FC5AD0
}

internal static class ThisAssembly // TypeDefIndex: 2876
{
	// Fields
	public const string Version = "4.0.0.0"; // Metadata: 0x003F26C7
}

namespace Microsoft.CSharp
{
	internal class CodeDomProvider // TypeDefIndex: 2877
	{
		// Constructors
		public CodeDomProvider() {} // 0x00FC54F0-0x00FC54F8
	
		// Methods
		public string CreateEscapedIdentifier(string name) => default; // 0x00FC54F8-0x00FC5568
		private static bool IsKeyword(string value) => default; // 0x00FC5568-0x00FC5570
		private static bool IsPrefixTwoUnderscore(string value) => default; // 0x00FC5570-0x00FC5600
	}

	internal class CSharpCodeProvider : Microsoft.CSharp.CodeDomProvider // TypeDefIndex: 2878
	{
		// Constructors
		public CSharpCodeProvider() {} // 0x00FC54E8-0x00FC54F0
	}

	internal class CodeGenerator // TypeDefIndex: 2879
	{
		// Constructors
		public CodeGenerator() {} // 0x00FC57FC-0x00FC5804
	
		// Methods
		public static bool IsValidLanguageIndependentIdentifier(string value) => default; // 0x00FC5600-0x00FC5608
		private static bool IsValidTypeNameOrIdentifier(string value, bool isTypeName) => default; // 0x00FC5608-0x00FC5794
		private static bool IsSpecialTypeChar(char ch, ref bool nextMustBeStartChar) => default; // 0x00FC5794-0x00FC57FC
	}
}

namespace MS.Internal.Xml.XPath
{
	internal sealed class AbsoluteQuery : ContextQuery // TypeDefIndex: 2880
	{
		// Constructors
		public AbsoluteQuery() {} // 0x01985874-0x0198589C
		private AbsoluteQuery(AbsoluteQuery other) {} // 0x019858C4-0x019858C8
	
		// Methods
		public override object Evaluate(XPathNodeIterator context) => default; // 0x01985900-0x0198596C
		public override XPathNavigator MatchNode(XPathNavigator context) => default; // 0x0198596C-0x019859AC
		public override XPathNodeIterator Clone() => default; // 0x019859AC-0x01985A0C
	}

	internal abstract class AstNode // TypeDefIndex: 2881
	{
		// Properties
		public abstract AstType Type { get; }
		public abstract XPathResultType ReturnType { get; }
	
		// Nested types
		public enum AstType // TypeDefIndex: 2882
		{
			Axis = 0,
			Operator = 1,
			Filter = 2,
			ConstantOperand = 3,
			Function = 4,
			Group = 5,
			Root = 6,
			Variable = 7,
			Error = 8
		}
	
		// Constructors
		protected AstNode() {} // 0x01985A0C-0x01985A14
	}

	internal sealed class AttributeQuery : BaseAxisQuery // TypeDefIndex: 2883
	{
		// Fields
		private bool onAttribute; // 0x54
	
		// Constructors
		public AttributeQuery() {} // Dummy constructor
		public AttributeQuery(Query qyParent, string Name, string Prefix, XPathNodeType Type) {} // 0x01985A14-0x01985A18
		private AttributeQuery(AttributeQuery other) {} // 0x01985AD4-0x01985B08
	
		// Methods
		public override void Reset() {} // 0x01985B7C-0x01985BAC
		public override XPathNavigator Advance() => default; // 0x01985BD8-0x01985C9C
		public override XPathNavigator MatchNode(XPathNavigator context) => default; // 0x01985C9C-0x01985D54
		public override XPathNodeIterator Clone() => default; // 0x01985D54-0x01985DB4
	}

	internal class Axis : AstNode // TypeDefIndex: 2884
	{
		// Fields
		private AxisType axisType; // 0x10
		private AstNode input; // 0x18
		private string prefix; // 0x20
		private string name; // 0x28
		private XPathNodeType nodeType; // 0x30
		protected bool abbrAxis; // 0x34
		private string urn; // 0x38
	
		// Properties
		public override AstType Type { get => default; } // 0x01985ED8-0x01985EE0 
		public override XPathResultType ReturnType { get => default; } // 0x01985EE0-0x01985EE8 
		public AstNode Input { get => default; set {} } // 0x01985EE8-0x01985EF0 0x01985EF0-0x01985EF8
		public string Prefix { get => default; } // 0x01985EF8-0x01985F00 
		public string Name { get => default; } // 0x01985F00-0x01985F08 
		public XPathNodeType NodeType { get => default; } // 0x01985F08-0x01985F10 
		public AxisType TypeOfAxis { get => default; } // 0x01985F10-0x01985F18 
		public bool AbbrAxis { get => default; } // 0x01985F18-0x01985F20 
		public string Urn { get => default; set {} } // 0x01985F20-0x01985F28 0x01985F28-0x01985F30
	
		// Nested types
		public enum AxisType // TypeDefIndex: 2885
		{
			Ancestor = 0,
			AncestorOrSelf = 1,
			Attribute = 2,
			Child = 3,
			Descendant = 4,
			DescendantOrSelf = 5,
			Following = 6,
			FollowingSibling = 7,
			Namespace = 8,
			Parent = 9,
			Preceding = 10,
			PrecedingSibling = 11,
			Self = 12,
			None = 13
		}
	
		// Constructors
		public Axis() {} // Dummy constructor
		public Axis(AxisType axisType, AstNode input, string prefix, string name, XPathNodeType nodetype) {} // 0x01985DB4-0x01985E54
		public Axis(AxisType axisType, AstNode input) {} // 0x01985E54-0x01985ED8
	}

	internal abstract class BaseAxisQuery : Query // TypeDefIndex: 2886
	{
		// Fields
		internal Query qyInput; // 0x18
		private bool nameTest; // 0x20
		private string name; // 0x28
		private string prefix; // 0x30
		private string nsUri; // 0x38
		private XPathNodeType typeTest; // 0x40
		protected XPathNavigator currentNode; // 0x48
		protected int position; // 0x50
	
		// Properties
		protected string Name { get; } // 0x019860C0-0x019860C8 
		protected string Prefix { get; } // 0x019860C8-0x019860D0 
		protected string Namespace { get; } // 0x019860D0-0x019860D8 
		protected bool NameTest { get; } // 0x019860D8-0x019860E0 
		protected XPathNodeType TypeTest { get; } // 0x019860E0-0x019860E8 
		public override int CurrentPosition { get; } // 0x019860E8-0x019860F0 
		public override XPathNavigator Current { get; } // 0x019860F0-0x019860F8 
		public override double XsltDefaultPriority { get; } // 0x01986274-0x0198635C 
		public override XPathResultType StaticType { get; } // 0x0198635C-0x01986364 
	
		// Constructors
		protected BaseAxisQuery() {} // Dummy constructor
		protected BaseAxisQuery(Query qyInput) {} // 0x01985F30-0x01985FBC
		protected BaseAxisQuery(Query qyInput, string name, string prefix, XPathNodeType typeTest) {} // 0x01985A18-0x01985AD4
		protected BaseAxisQuery(BaseAxisQuery other) {} // 0x01985B08-0x01985B7C
	
		// Methods
		public override void Reset() {} // 0x01985BAC-0x01985BD8
		public override void SetXsltContext(XsltContext context) {} // 0x01986060-0x019860C0
		public virtual bool matches(XPathNavigator e) => default; // 0x019860F8-0x01986218
		public override object Evaluate(XPathNodeIterator nodeIterator) => default; // 0x01986218-0x01986274
		public override void PrintQuery(XmlWriter w) {} // 0x01986364-0x019864D8
	}

	internal sealed class BooleanExpr : ValueQuery // TypeDefIndex: 2887
	{
		// Fields
		private Query opnd1; // 0x18
		private Query opnd2; // 0x20
		private bool isOr; // 0x28
	
		// Properties
		public override XPathResultType StaticType { get => default; } // 0x0198680C-0x01986814 
	
		// Constructors
		public BooleanExpr() {} // Dummy constructor
		public BooleanExpr(Operator.Op op, Query opnd1, Query opnd2) {} // 0x019864D8-0x019865EC
		private BooleanExpr(BooleanExpr other) {} // 0x01986628-0x01986678
	
		// Methods
		public override void SetXsltContext(XsltContext context) {} // 0x01986678-0x019866CC
		public override object Evaluate(XPathNodeIterator nodeIterator) => default; // 0x019866CC-0x019867AC
		public override XPathNodeIterator Clone() => default; // 0x019867AC-0x0198680C
		public override void PrintQuery(XmlWriter w) {} // 0x01986814-0x0198695C
	}

	internal sealed class BooleanFunctions : ValueQuery // TypeDefIndex: 2888
	{
		// Fields
		private Query arg; // 0x18
		private Function.FunctionType funcType; // 0x20
	
		// Properties
		public override XPathResultType StaticType { get => default; } // 0x01986E54-0x01986E5C 
	
		// Constructors
		public BooleanFunctions() {} // Dummy constructor
		public BooleanFunctions(Function.FunctionType funcType, Query arg) {} // 0x019865EC-0x01986628
		private BooleanFunctions(BooleanFunctions other) {} // 0x0198695C-0x019869A0
	
		// Methods
		public override void SetXsltContext(XsltContext context) {} // 0x019869A0-0x019869BC
		public override object Evaluate(XPathNodeIterator nodeIterator) => default; // 0x019869BC-0x01986AF8
		internal static bool toBoolean(double number) => default; // 0x01986DA8-0x01986E34
		internal static bool toBoolean(string str) => default; // 0x01986E34-0x01986E54
		internal bool toBoolean(XPathNodeIterator nodeIterator) => default; // 0x01986AF8-0x01986C38
		private bool Not(XPathNodeIterator nodeIterator) => default; // 0x01986C38-0x01986CDC
		private bool Lang(XPathNodeIterator nodeIterator) => default; // 0x01986CDC-0x01986DA8
		public override XPathNodeIterator Clone() => default; // 0x01986E5C-0x01986EBC
		public override void PrintQuery(XmlWriter w) {} // 0x01986EBC-0x01986FC0
	}

	internal abstract class CacheAxisQuery : BaseAxisQuery // TypeDefIndex: 2889
	{
		// Fields
		protected List<XPathNavigator> outputBuffer; // 0x58
	
		// Properties
		public override XPathNavigator Current { get; } // 0x01987210-0x01987290 
		public override int CurrentPosition { get; } // 0x01987290-0x01987298 
		public override int Count { get; } // 0x01987298-0x019872E8 
		public override QueryProps Properties { get; } // 0x019872E8-0x019872F0 
	
		// Constructors
		protected CacheAxisQuery() {} // Dummy constructor
		public CacheAxisQuery(Query qyInput, string name, string prefix, XPathNodeType typeTest) {} // 0x01986FC0-0x01987064
		protected CacheAxisQuery(CacheAxisQuery other) {} // 0x01987064-0x019870FC
	
		// Methods
		public override void Reset() {} // 0x019870FC-0x01987104
		public override object Evaluate(XPathNodeIterator context) => default; // 0x01987104-0x0198717C
		public override XPathNavigator Advance() => default; // 0x0198717C-0x01987210
	}

	internal sealed class CacheChildrenQuery : ChildrenQuery // TypeDefIndex: 2890
	{
		// Fields
		private XPathNavigator nextInput; // 0x60
		private ClonableStack<XPathNavigator> elementStk; // 0x68
		private ClonableStack<int> positionStk; // 0x70
		private bool needInput; // 0x78
	
		// Constructors
		public CacheChildrenQuery() {} // Dummy constructor
		public CacheChildrenQuery(Query qyInput, string name, string prefix, XPathNodeType type) {} // 0x019872F0-0x019873C0
		private CacheChildrenQuery(CacheChildrenQuery other) {} // 0x01987464-0x01987520
	
		// Methods
		public override void Reset() {} // 0x019875E0-0x01987664
		public override XPathNavigator Advance() => default; // 0x019876F0-0x01987824
		private bool DecideNextNode() => default; // 0x01987878-0x0198794C
		private XPathNavigator GetNextInput() => default; // 0x01987824-0x01987878
		public override XPathNodeIterator Clone() => default; // 0x01987A64-0x01987AC4
	}

	internal abstract class CacheOutputQuery : Query // TypeDefIndex: 2891
	{
		// Fields
		internal Query input; // 0x18
		protected List<XPathNavigator> outputBuffer; // 0x20
	
		// Properties
		public override XPathNavigator Current { get; } // 0x01987D38-0x01987DB8 
		public override XPathResultType StaticType { get; } // 0x01987DB8-0x01987DC0 
		public override int CurrentPosition { get; } // 0x01987DC0-0x01987DC8 
		public override int Count { get; } // 0x01987DC8-0x01987E18 
		public override QueryProps Properties { get; } // 0x01987E18-0x01987E20 
	
		// Constructors
		protected CacheOutputQuery() {} // Dummy constructor
		public CacheOutputQuery(Query input) {} // 0x01987AC4-0x01987B4C
		protected CacheOutputQuery(CacheOutputQuery other) {} // 0x01987B4C-0x01987BF4
	
		// Methods
		public override void Reset() {} // 0x01987BF4-0x01987BFC
		public override void SetXsltContext(XsltContext context) {} // 0x01987BFC-0x01987C20
		public override object Evaluate(XPathNodeIterator context) => default; // 0x01987C20-0x01987CA4
		public override XPathNavigator Advance() => default; // 0x01987CA4-0x01987D38
		public override void PrintQuery(XmlWriter w) {} // 0x01987E20-0x01987E9C
	}

	internal class ChildrenQuery : BaseAxisQuery // TypeDefIndex: 2892
	{
		// Fields
		private XPathNodeIterator iterator; // 0x58
	
		// Constructors
		public ChildrenQuery() {} // Dummy constructor
		public ChildrenQuery(Query qyInput, string name, string prefix, XPathNodeType type) {} // 0x019873C0-0x01987464
		protected ChildrenQuery(ChildrenQuery other) {} // 0x01987520-0x019875C8
	
		// Methods
		public override void Reset() {} // 0x01987664-0x019876F0
		public override XPathNavigator Advance() => default; // 0x01987EB0-0x01987FF8
		public sealed override XPathNavigator MatchNode(XPathNavigator context) => default; // 0x01988030-0x019880E0
		public override XPathNodeIterator Clone() => default; // 0x019880E0-0x01988140
	}

	internal sealed class ClonableStack<T> : List<T> // TypeDefIndex: 2893
	{
		// Constructors
		public ClonableStack() {}
		public ClonableStack(int capacity) {}
		private ClonableStack(IEnumerable<T> collection) {}
	
		// Methods
		public void Push(T value) {}
		public T Pop() => default;
		public T Peek() => default;
		public ClonableStack<T> Clone() => default;
	}

	internal class CompiledXpathExpr : XPathExpression // TypeDefIndex: 2894
	{
		// Fields
		private Query query; // 0x10
		private string expr; // 0x18
		private bool needContext; // 0x20
	
		// Properties
		internal Query QueryTree { get => default; } // 0x01988184-0x019881F4 
		public override string Expression { get => default; } // 0x019881F4-0x019881FC 
		public override XPathResultType ReturnType { get => default; } // 0x01988644-0x01988668 
	
		// Nested types
		private class UndefinedXsltContext : XsltContext // TypeDefIndex: 2895
		{
			// Fields
			private IXmlNamespaceResolver nsResolver; // 0x50
	
			// Properties
			public override string DefaultNamespace { get => default; } // 0x01988668-0x019886B8 
			public override bool Whitespace { get => default; } // 0x01988878-0x01988880 
	
			// Constructors
			public UndefinedXsltContext() {} // Dummy constructor
			public UndefinedXsltContext(IXmlNamespaceResolver nsResolver) {} // 0x01988614-0x01988644
	
			// Methods
			public override string LookupNamespace(string prefix) => default; // 0x019886B8-0x019887D0
			public override IXsltContextVariable ResolveVariable(string prefix, string name) => default; // 0x019887D0-0x01988824
			public override IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] ArgTypes) => default; // 0x01988824-0x01988878
			public override bool PreserveWhitespace(XPathNavigator node) => default; // 0x01988880-0x01988888
			public override int CompareDocument(string baseUri, string nextbaseUri) => default; // 0x01988888-0x01988898
		}
	
		// Constructors
		public CompiledXpathExpr() {} // Dummy constructor
		internal CompiledXpathExpr(Query query, string expression, bool needContext) {} // 0x01988140-0x01988184
	
		// Methods
		public virtual void CheckErrors() {} // 0x019881FC-0x01988200
		public override void AddSort(object expr, IComparer comparer) {} // 0x01988200-0x01988388
		public override void AddSort(object expr, XmlSortOrder order, XmlCaseOrder caseOrder, string lang, XmlDataType dataType) {} // 0x019883C4-0x01988470
		public override XPathExpression Clone() => default; // 0x01988470-0x019884F8
		public override void SetContext(XmlNamespaceManager nsManager) {} // 0x019884F8-0x01988504
		public override void SetContext(IXmlNamespaceResolver nsResolver) {} // 0x01988504-0x01988614
	}

	internal sealed class XPathComparerHelper : IComparer // TypeDefIndex: 2896
	{
		// Fields
		private XmlSortOrder order; // 0x10
		private XmlCaseOrder caseOrder; // 0x14
		private CultureInfo cinfo; // 0x18
		private XmlDataType dataType; // 0x20
	
		// Constructors
		public XPathComparerHelper() {} // Dummy constructor
		public XPathComparerHelper(XmlSortOrder order, XmlCaseOrder caseOrder, string lang, XmlDataType dataType) {} // 0x00FC0258-0x00FC03B8
	
		// Methods
		public int Compare(object x, object y) => default; // 0x00FC03B8-0x00FC0570
	}

	internal class ContextQuery : Query // TypeDefIndex: 2897
	{
		// Fields
		protected XPathNavigator contextNode; // 0x18
	
		// Properties
		public override XPathNavigator Current { get => default; } // 0x019888A0-0x019888A8 
		public override XPathResultType StaticType { get => default; } // 0x01988978-0x01988980 
		public override int CurrentPosition { get => default; } // 0x01988980-0x01988988 
		public override int Count { get => default; } // 0x01988988-0x01988990 
		public override QueryProps Properties { get => default; } // 0x01988990-0x01988998 
	
		// Constructors
		public ContextQuery() {} // 0x0198589C-0x019858C4
		protected ContextQuery(ContextQuery other) {} // 0x019858C8-0x01985900
	
		// Methods
		public override void Reset() {} // 0x01988898-0x019888A0
		public override object Evaluate(XPathNodeIterator context) => default; // 0x019888A8-0x019888EC
		public override XPathNavigator Advance() => default; // 0x019888EC-0x01988910
		public override XPathNavigator MatchNode(XPathNavigator current) => default; // 0x01988910-0x01988918
		public override XPathNodeIterator Clone() => default; // 0x01988918-0x01988978
	}

	internal abstract class DescendantBaseQuery : BaseAxisQuery // TypeDefIndex: 2898
	{
		// Fields
		protected bool matchSelf; // 0x54
		protected bool abbrAxis; // 0x55
	
		// Constructors
		protected DescendantBaseQuery() {} // Dummy constructor
		public DescendantBaseQuery(Query qyParent, string Name, string Prefix, XPathNodeType Type, bool matchSelf, bool abbrAxis) {} // 0x01988998-0x019889D8
		public DescendantBaseQuery(DescendantBaseQuery other) {} // 0x019889D8-0x01988A14
	
		// Methods
		public override XPathNavigator MatchNode(XPathNavigator context) => default; // 0x01988A14-0x01988B34
		public override void PrintQuery(XmlWriter w) {} // 0x01988B34-0x01988CD4
	}

	internal class DescendantQuery : DescendantBaseQuery // TypeDefIndex: 2899
	{
		// Fields
		private XPathNodeIterator nodeIterator; // 0x58
	
		// Constructors
		public DescendantQuery() {} // Dummy constructor
		internal DescendantQuery(Query qyParent, string Name, string Prefix, XPathNodeType Type, bool matchSelf, bool abbrAxis) {} // 0x01988F94-0x01988FD4
		public DescendantQuery(DescendantQuery other) {} // 0x01988FD4-0x01989018
	
		// Methods
		public override void Reset() {} // 0x01989018-0x01989048
		public override XPathNavigator Advance() => default; // 0x01989048-0x019891B4
		public override XPathNodeIterator Clone() => default; // 0x019891B4-0x01989214
	}

	internal sealed class DescendantOverDescendantQuery : DescendantBaseQuery // TypeDefIndex: 2900
	{
		// Fields
		private int level; // 0x58
	
		// Constructors
		public DescendantOverDescendantQuery() {} // Dummy constructor
		public DescendantOverDescendantQuery(Query qyParent, bool matchSelf, string name, string prefix, XPathNodeType typeTest, bool abbrAxis) {} // 0x01988CD4-0x01988D20
		private DescendantOverDescendantQuery(DescendantOverDescendantQuery other) {} // 0x01988D20-0x01988D54
	
		// Methods
		public override void Reset() {} // 0x01988D54-0x01988D84
		public override XPathNavigator Advance() => default; // 0x01988D84-0x01988E68
		private bool MoveToFirstChild() => default; // 0x01988E68-0x01988EBC
		private bool MoveUpUntillNext() => default; // 0x01988EBC-0x01988F34
		public override XPathNodeIterator Clone() => default; // 0x01988F34-0x01988F94
	}

	internal sealed class DocumentOrderQuery : CacheOutputQuery // TypeDefIndex: 2901
	{
		// Constructors
		public DocumentOrderQuery() {} // Dummy constructor
		public DocumentOrderQuery(Query qyParent) {} // 0x01989214-0x01989218
		private DocumentOrderQuery(DocumentOrderQuery other) {} // 0x01989218-0x0198921C
	
		// Methods
		public override object Evaluate(XPathNodeIterator context) => default; // 0x0198921C-0x01989270
		public override XPathNavigator MatchNode(XPathNavigator context) => default; // 0x019893D8-0x019893FC
		public override XPathNodeIterator Clone() => default; // 0x019893FC-0x0198945C
	}

	internal sealed class EmptyQuery : Query // TypeDefIndex: 2902
	{
		// Properties
		public override int CurrentPosition { get => default; } // 0x0198946C-0x01989474 
		public override int Count { get => default; } // 0x01989474-0x0198947C 
		public override QueryProps Properties { get => default; } // 0x0198947C-0x01989484 
		public override XPathResultType StaticType { get => default; } // 0x01989484-0x0198948C 
		public override XPathNavigator Current { get => default; } // 0x01989490-0x01989498 
	
		// Constructors
		public EmptyQuery() {} // 0x01989498-0x019894A0
	
		// Methods
		public override XPathNavigator Advance() => default; // 0x0198945C-0x01989464
		public override XPathNodeIterator Clone() => default; // 0x01989464-0x01989468
		public override object Evaluate(XPathNodeIterator context) => default; // 0x01989468-0x0198946C
		public override void Reset() {} // 0x0198948C-0x01989490
	}

	internal abstract class ExtensionQuery : Query // TypeDefIndex: 2903
	{
		// Fields
		protected string prefix; // 0x18
		protected string name; // 0x20
		protected XsltContext xsltContext; // 0x28
		private ResetableIterator queryIterator; // 0x30
	
		// Properties
		public override XPathNavigator Current { get; } // 0x019895C0-0x01989664 
		public override int CurrentPosition { get; } // 0x01989704-0x0198971C 
		protected string QName { get; } // 0x01989B0C-0x01989B84 
		public override int Count { get; } // 0x01989B84-0x01989BA0 
		public override XPathResultType StaticType { get; } // 0x01989BA0-0x01989BA8 
	
		// Constructors
		protected ExtensionQuery() {} // Dummy constructor
		public ExtensionQuery(string prefix, string name) {} // 0x019894A0-0x019894D8
		protected ExtensionQuery(ExtensionQuery other) {} // 0x019894D8-0x019895A8
	
		// Methods
		public override void Reset() {} // 0x019895A8-0x019895C0
		public override XPathNavigator Advance() => default; // 0x01989664-0x01989704
		protected object ProcessResult(object value) => default; // 0x0198971C-0x01989B0C
	}

	internal class Filter : AstNode // TypeDefIndex: 2904
	{
		// Fields
		private AstNode input; // 0x10
		private AstNode condition; // 0x18
	
		// Properties
		public override AstType Type { get => default; } // 0x01989BE0-0x01989BE8 
		public override XPathResultType ReturnType { get => default; } // 0x01989BE8-0x01989BF0 
		public AstNode Input { get => default; } // 0x01989BF0-0x01989BF8 
		public AstNode Condition { get => default; } // 0x01989BF8-0x01989C00 
	
		// Constructors
		public Filter() {} // Dummy constructor
		public Filter(AstNode input, AstNode condition) {} // 0x01989BA8-0x01989BE0
	}

	internal sealed class FilterQuery : BaseAxisQuery // TypeDefIndex: 2905
	{
		// Fields
		private Query cond; // 0x58
		private bool noPosition; // 0x60
	
		// Properties
		public Query Condition { get => default; } // 0x01989CC8-0x01989CD0 
		public override QueryProps Properties { get => default; } // 0x0198A41C-0x0198A450 
	
		// Constructors
		public FilterQuery() {} // Dummy constructor
		public FilterQuery(Query qyParent, Query cond, bool noPosition) {} // 0x01989C00-0x01989C3C
		private FilterQuery(FilterQuery other) {} // 0x01989C3C-0x01989C7C
	
		// Methods
		public override void Reset() {} // 0x01989C7C-0x01989CC8
		public override void SetXsltContext(XsltContext input) {} // 0x01989CD0-0x01989DBC
		public override XPathNavigator Advance() => default; // 0x01989DBC-0x01989E18
		internal bool EvaluatePredicate() => default; // 0x01989E18-0x01989F90
		public override XPathNavigator MatchNode(XPathNavigator current) => default; // 0x01989F90-0x0198A41C
		public override XPathNodeIterator Clone() => default; // 0x0198A450-0x0198A4B0
		public override void PrintQuery(XmlWriter w) {} // 0x0198A4B0-0x0198A5A4
	}

	internal sealed class FollowingQuery : BaseAxisQuery // TypeDefIndex: 2906
	{
		// Fields
		private XPathNavigator input; // 0x58
		private XPathNodeIterator iterator; // 0x60
	
		// Constructors
		public FollowingQuery() {} // Dummy constructor
		public FollowingQuery(Query qyInput, string name, string prefix, XPathNodeType typeTest) {} // 0x0198AB24-0x0198AB28
		private FollowingQuery(FollowingQuery other) {} // 0x0198AB28-0x0198AB88
	
		// Methods
		public override void Reset() {} // 0x0198AB88-0x0198ABB8
		public override XPathNavigator Advance() => default; // 0x0198ABB8-0x0198ADE4
		public override XPathNodeIterator Clone() => default; // 0x0198ADE4-0x0198AE44
	}

	internal sealed class FollSiblingQuery : BaseAxisQuery // TypeDefIndex: 2907
	{
		// Fields
		private ClonableStack<XPathNavigator> elementStk; // 0x58
		private List<XPathNavigator> parentStk; // 0x60
		private XPathNavigator nextInput; // 0x68
	
		// Constructors
		public FollSiblingQuery() {} // Dummy constructor
		public FollSiblingQuery(Query qyInput, string name, string prefix, XPathNodeType type) {} // 0x0198A5A4-0x0198A66C
		private FollSiblingQuery(FollSiblingQuery other) {} // 0x0198A66C-0x0198A734
	
		// Methods
		public override void Reset() {} // 0x0198A734-0x0198A7BC
		private bool Visited(XPathNavigator nav) => default; // 0x0198A7BC-0x0198A8BC
		private XPathNavigator FetchInput() => default; // 0x0198A8BC-0x0198A928
		public override XPathNavigator Advance() => default; // 0x0198A928-0x0198AAC4
		public override XPathNodeIterator Clone() => default; // 0x0198AAC4-0x0198AB24
	}

	internal class ForwardPositionQuery : CacheOutputQuery // TypeDefIndex: 2908
	{
		// Constructors
		public ForwardPositionQuery() {} // Dummy constructor
		public ForwardPositionQuery(Query input) {} // 0x0198AE44-0x0198AE48
		protected ForwardPositionQuery(ForwardPositionQuery other) {} // 0x0198AE48-0x0198AE4C
	
		// Methods
		public override object Evaluate(XPathNodeIterator context) => default; // 0x0198AE4C-0x0198AF00
		public override XPathNavigator MatchNode(XPathNavigator context) => default; // 0x0198AF00-0x0198AF24
		public override XPathNodeIterator Clone() => default; // 0x0198AF24-0x0198AF84
	}

	internal class Function : AstNode // TypeDefIndex: 2909
	{
		// Fields
		private FunctionType functionType; // 0x10
		private ArrayList argumentList; // 0x18
		private string name; // 0x20
		private string prefix; // 0x28
		internal static XPathResultType[] ReturnTypes; // 0x00
	
		// Properties
		public override AstType Type { get => default; } // 0x0198B168-0x0198B170 
		public override XPathResultType ReturnType { get => default; } // 0x0198B170-0x0198B208 
		public FunctionType TypeOfFunction { get => default; } // 0x0198B208-0x0198B210 
		public ArrayList ArgumentList { get => default; } // 0x0198B210-0x0198B218 
		public string Prefix { get => default; } // 0x0198B218-0x0198B220 
		public string Name { get => default; } // 0x0198B220-0x0198B228 
	
		// Nested types
		public enum FunctionType // TypeDefIndex: 2910
		{
			FuncLast = 0,
			FuncPosition = 1,
			FuncCount = 2,
			FuncID = 3,
			FuncLocalName = 4,
			FuncNameSpaceUri = 5,
			FuncName = 6,
			FuncString = 7,
			FuncBoolean = 8,
			FuncNumber = 9,
			FuncTrue = 10,
			FuncFalse = 11,
			FuncNot = 12,
			FuncConcat = 13,
			FuncStartsWith = 14,
			FuncContains = 15,
			FuncSubstringBefore = 16,
			FuncSubstringAfter = 17,
			FuncSubstring = 18,
			FuncStringLength = 19,
			FuncNormalize = 20,
			FuncTranslate = 21,
			FuncLang = 22,
			FuncSum = 23,
			FuncFloor = 24,
			FuncCeiling = 25,
			FuncRound = 26,
			FuncUserDefined = 27
		}
	
		// Constructors
		public Function() {} // Dummy constructor
		public Function(FunctionType ftype, ArrayList argumentList) {} // 0x0198AF84-0x0198B008
		public Function(string prefix, string name, ArrayList argumentList) {} // 0x0198B008-0x0198B0A0
		public Function(FunctionType ftype) {} // 0x0198B0A0-0x0198B0CC
		public Function(FunctionType ftype, AstNode arg) {} // 0x0198B0CC-0x0198B168
		static Function() {} // 0x0198B228-0x0198B2A4
	}

	internal sealed class FunctionQuery : ExtensionQuery // TypeDefIndex: 2911
	{
		// Fields
		private IList<Query> args; // 0x38
		private IXsltContextFunction function; // 0x40
	
		// Properties
		public override XPathResultType StaticType { get => default; } // 0x0198BF88-0x0198C050 
	
		// Constructors
		public FunctionQuery() {} // Dummy constructor
		public FunctionQuery(string prefix, string name, List<Query> args) {} // 0x0198B2A4-0x0198B2E4
		private FunctionQuery(FunctionQuery other) {} // 0x0198B2E4-0x0198B4C4
	
		// Methods
		public override void SetXsltContext(XsltContext context) {} // 0x0198B4C4-0x0198B98C
		public override object Evaluate(XPathNodeIterator nodeIterator) => default; // 0x0198B98C-0x0198BE70
		public override XPathNavigator MatchNode(XPathNavigator navigator) => default; // 0x0198BE70-0x0198BF88
		public override XPathNodeIterator Clone() => default; // 0x0198C050-0x0198C0B0
		public override void PrintQuery(XmlWriter w) {} // 0x0198C0B0-0x0198C3B8
	}

	internal class Group : AstNode // TypeDefIndex: 2912
	{
		// Fields
		private AstNode groupNode; // 0x10
	
		// Properties
		public override AstType Type { get => default; } // 0x0198C3E4-0x0198C3EC 
		public override XPathResultType ReturnType { get => default; } // 0x0198C3EC-0x0198C3F4 
		public AstNode GroupNode { get => default; } // 0x0198C3F4-0x0198C3FC 
	
		// Constructors
		public Group() {} // Dummy constructor
		public Group(AstNode groupNode) {} // 0x0198C3B8-0x0198C3E4
	}

	internal sealed class GroupQuery : BaseAxisQuery // TypeDefIndex: 2913
	{
		// Properties
		public override XPathResultType StaticType { get => default; } // 0x0198C4D4-0x0198C4F8 
		public override QueryProps Properties { get => default; } // 0x0198C4F8-0x0198C500 
	
		// Constructors
		public GroupQuery() {} // Dummy constructor
		public GroupQuery(Query qy) {} // 0x0198C3FC-0x0198C400
		private GroupQuery(GroupQuery other) {} // 0x0198C400-0x0198C404
	
		// Methods
		public override XPathNavigator Advance() => default; // 0x0198C404-0x0198C450
		public override object Evaluate(XPathNodeIterator nodeIterator) => default; // 0x0198C450-0x0198C474
		public override XPathNodeIterator Clone() => default; // 0x0198C474-0x0198C4D4
	}

	internal sealed class IDQuery : CacheOutputQuery // TypeDefIndex: 2914
	{
		// Constructors
		public IDQuery() {} // Dummy constructor
		public IDQuery(Query arg) {} // 0x0198C500-0x0198C504
		private IDQuery(IDQuery other) {} // 0x0198C504-0x0198C508
	
		// Methods
		public override object Evaluate(XPathNodeIterator context) => default; // 0x0198C508-0x0198C764
		private void ProcessIds(XPathNavigator contextNode, string val) {} // 0x0198C840-0x0198C938
		public override XPathNavigator MatchNode(XPathNavigator context) => default; // 0x0198C938-0x0198C9FC
		public override XPathNodeIterator Clone() => default; // 0x0198C9FC-0x0198CA5C
	}

	internal class IteratorFilter : XPathNodeIterator // TypeDefIndex: 2915
	{
		// Fields
		private XPathNodeIterator innerIterator; // 0x18
		private string name; // 0x20
		private int position; // 0x28
	
		// Properties
		public override XPathNavigator Current { get => default; } // 0x0198CB14-0x0198CB34 
		public override int CurrentPosition { get => default; } // 0x0198CB34-0x0198CB3C 
	
		// Constructors
		public IteratorFilter() {} // Dummy constructor
		internal IteratorFilter(XPathNodeIterator innerIterator, string name) {} // 0x01987FF8-0x01988030
		private IteratorFilter(IteratorFilter it) {} // 0x0198CA5C-0x0198CAB4
	
		// Methods
		public override XPathNodeIterator Clone() => default; // 0x0198CAB4-0x0198CB14
		public override bool MoveNext() => default; // 0x0198CB3C-0x0198CBC4
	}

	internal sealed class LogicalExpr : ValueQuery // TypeDefIndex: 2916
	{
		// Fields
		private Operator.Op op; // 0x14
		private Query opnd1; // 0x18
		private Query opnd2; // 0x20
		private static readonly cmpXslt[][] CompXsltE; // 0x00
		private static readonly cmpXslt[][] CompXsltO; // 0x08
	
		// Properties
		public override XPathResultType StaticType { get => default; } // 0x0198F3C4-0x0198F3CC 
	
		// Nested types
		private delegate bool cmpXslt(Operator.Op op, object val1, object val2); // TypeDefIndex: 2917; 0x0198CF6C-0x0198D21C
	
		private struct NodeSet // TypeDefIndex: 2918
		{
			// Fields
			private Query opnd; // 0x00
			private XPathNavigator current; // 0x08
	
			// Properties
			public string Value { get => default; } // 0x00AF1A94-0x00AF1AB4 
	
			// Constructors
			public NodeSet(object opnd) : this() {
				this.opnd = default;
				current = default;
			} // 0x00AF1A24-0x00AF1A2C
	
			// Methods
			public bool MoveNext() => default; // 0x00AF1A2C-0x00AF1A74
			public void Reset() {} // 0x00AF1A74-0x00AF1A94
		}
	
		// Constructors
		public LogicalExpr() {} // Dummy constructor
		public LogicalExpr(Operator.Op op, Query opnd1, Query opnd2) {} // 0x0198CBC4-0x0198CC04
		private LogicalExpr(LogicalExpr other) {} // 0x0198CC04-0x0198CC54
		static LogicalExpr() {} // 0x0198F4EC-0x019900C0
	
		// Methods
		public override void SetXsltContext(XsltContext context) {} // 0x0198CC54-0x0198CCA8
		public override object Evaluate(XPathNodeIterator nodeIterator) => default; // 0x0198CCA8-0x0198CED8
		private static bool cmpQueryQueryE(Operator.Op op, object val1, object val2) => default; // 0x0198D21C-0x0198D488
		private static bool cmpQueryQueryO(Operator.Op op, object val1, object val2) => default; // 0x0198D488-0x0198D680
		private static bool cmpQueryNumber(Operator.Op op, object val1, object val2) => default; // 0x0198D758-0x0198D8D8
		private static bool cmpQueryStringE(Operator.Op op, object val1, object val2) => default; // 0x0198D8D8-0x0198D9E8
		private static bool cmpQueryStringO(Operator.Op op, object val1, object val2) => default; // 0x0198DA24-0x0198DB88
		private static bool cmpRtfQueryE(Operator.Op op, object val1, object val2) => default; // 0x0198DBE0-0x0198DCF0
		private static bool cmpRtfQueryO(Operator.Op op, object val1, object val2) => default; // 0x0198DDA4-0x0198DF00
		private static bool cmpQueryBoolE(Operator.Op op, object val1, object val2) => default; // 0x0198DF00-0x0198E008
		private static bool cmpQueryBoolO(Operator.Op op, object val1, object val2) => default; // 0x0198E020-0x0198E178
		private static bool cmpBoolBoolE(Operator.Op op, bool n1, bool n2) => default; // 0x0198E008-0x0198E020
		private static bool cmpBoolBoolE(Operator.Op op, object val1, object val2) => default; // 0x0198E18C-0x0198E288
		private static bool cmpBoolBoolO(Operator.Op op, object val1, object val2) => default; // 0x0198E288-0x0198E3D4
		private static bool cmpBoolNumberE(Operator.Op op, object val1, object val2) => default; // 0x0198E3D4-0x0198E4DC
		private static bool cmpBoolNumberO(Operator.Op op, object val1, object val2) => default; // 0x0198E4DC-0x0198E624
		private static bool cmpBoolStringE(Operator.Op op, object val1, object val2) => default; // 0x0198E624-0x0198E718
		private static bool cmpRtfBoolE(Operator.Op op, object val1, object val2) => default; // 0x0198E718-0x0198E7F4
		private static bool cmpBoolStringO(Operator.Op op, object val1, object val2) => default; // 0x0198E7F4-0x0198E938
		private static bool cmpRtfBoolO(Operator.Op op, object val1, object val2) => default; // 0x0198E938-0x0198EA60
		private static bool cmpNumberNumber(Operator.Op op, double n1, double n2) => default; // 0x0198D6E8-0x0198D758
		private static bool cmpNumberNumberO(Operator.Op op, double n1, double n2) => default; // 0x0198DB88-0x0198DBE0
		private static bool cmpNumberNumber(Operator.Op op, object val1, object val2) => default; // 0x0198EA60-0x0198EBB0
		private static bool cmpStringNumber(Operator.Op op, object val1, object val2) => default; // 0x0198EBB0-0x0198ECFC
		private static bool cmpRtfNumber(Operator.Op op, object val1, object val2) => default; // 0x0198ECFC-0x0198EE28
		private static bool cmpStringStringE(Operator.Op op, string n1, string n2) => default; // 0x0198D9E8-0x0198DA24
		private static bool cmpStringStringE(Operator.Op op, object val1, object val2) => default; // 0x0198EE28-0x0198EEF4
		private static bool cmpRtfStringE(Operator.Op op, object val1, object val2) => default; // 0x0198EEF4-0x0198EFAC
		private static bool cmpRtfRtfE(Operator.Op op, object val1, object val2) => default; // 0x0198EFAC-0x0198F050
		private static bool cmpStringStringO(Operator.Op op, object val1, object val2) => default; // 0x0198F050-0x0198F174
		private static bool cmpRtfStringO(Operator.Op op, object val1, object val2) => default; // 0x0198F174-0x0198F27C
		private static bool cmpRtfRtfO(Operator.Op op, object val1, object val2) => default; // 0x0198F27C-0x0198F364
		public override XPathNodeIterator Clone() => default; // 0x0198F364-0x0198F3C4
		private static string Rtf(object o) => default; // 0x0198DCF0-0x0198DDA4
		public override void PrintQuery(XmlWriter w) {} // 0x0198F3CC-0x0198F4EC
	}

	internal sealed class MergeFilterQuery : CacheOutputQuery // TypeDefIndex: 2919
	{
		// Fields
		private Query child; // 0x28
	
		// Constructors
		public MergeFilterQuery() {} // Dummy constructor
		public MergeFilterQuery(Query input, Query child) {} // 0x0199019C-0x019901C4
		private MergeFilterQuery(MergeFilterQuery other) {} // 0x019901C4-0x019901FC
	
		// Methods
		public override void SetXsltContext(XsltContext xsltContext) {} // 0x019901FC-0x01990250
		public override object Evaluate(XPathNodeIterator nodeIterator) => default; // 0x01990250-0x019902E0
		public override XPathNavigator MatchNode(XPathNavigator current) => default; // 0x019902E0-0x01990410
		public override XPathNodeIterator Clone() => default; // 0x01990410-0x01990470
		public override void PrintQuery(XmlWriter w) {} // 0x01990470-0x01990508
	}

	internal sealed class NamespaceQuery : BaseAxisQuery // TypeDefIndex: 2920
	{
		// Fields
		private bool onNamespace; // 0x54
	
		// Constructors
		public NamespaceQuery() {} // Dummy constructor
		public NamespaceQuery(Query qyParent, string Name, string Prefix, XPathNodeType Type) {} // 0x01990508-0x0199050C
		private NamespaceQuery(NamespaceQuery other) {} // 0x0199050C-0x01990540
	
		// Methods
		public override void Reset() {} // 0x01990540-0x01990570
		public override XPathNavigator Advance() => default; // 0x01990570-0x01990628
		public override bool matches(XPathNavigator e) => default; // 0x01990628-0x019906B4
		public override XPathNodeIterator Clone() => default; // 0x019906B4-0x01990714
	}

	internal sealed class NodeFunctions : ValueQuery // TypeDefIndex: 2921
	{
		// Fields
		private Query arg; // 0x18
		private Function.FunctionType funcType; // 0x20
		private XsltContext xsltContext; // 0x28
	
		// Properties
		public override XPathResultType StaticType { get => default; } // 0x01990A2C-0x01990AC4 
	
		// Constructors
		public NodeFunctions() {} // Dummy constructor
		public NodeFunctions(Function.FunctionType funcType, Query arg) {} // 0x01990714-0x01990750
	
		// Methods
		public override void SetXsltContext(XsltContext context) {} // 0x01990750-0x019907C4
		private XPathNavigator EvaluateArg(XPathNodeIterator context) => default; // 0x019907C4-0x01990828
		public override object Evaluate(XPathNodeIterator context) => default; // 0x01990828-0x01990A2C
		public override XPathNodeIterator Clone() => default; // 0x01990AC4-0x01990B58
		public override void PrintQuery(XmlWriter w) {} // 0x01990B58-0x01990C5C
	}

	internal sealed class NumberFunctions : ValueQuery // TypeDefIndex: 2922
	{
		// Fields
		private Query arg; // 0x18
		private Function.FunctionType ftype; // 0x20
	
		// Properties
		public override XPathResultType StaticType { get => default; } // 0x019912F8-0x01991300 
	
		// Constructors
		public NumberFunctions() {} // Dummy constructor
		public NumberFunctions(Function.FunctionType ftype, Query arg) {} // 0x01990C5C-0x01990C98
		private NumberFunctions(NumberFunctions other) {} // 0x01990C98-0x01990CDC
	
		// Methods
		public override void SetXsltContext(XsltContext context) {} // 0x01990CDC-0x01990CF8
		internal static double Number(bool arg) => default; // 0x0198E178-0x0198E18C
		internal static double Number(string arg) => default; // 0x0198D680-0x0198D6E8
		public override object Evaluate(XPathNodeIterator nodeIterator) => default; // 0x01990CF8-0x01990DDC
		private double Number(XPathNodeIterator nodeIterator) => default; // 0x01990DDC-0x0199103C
		private double Sum(XPathNodeIterator nodeIterator) => default; // 0x0199103C-0x019910BC
		private double Floor(XPathNodeIterator nodeIterator) => default; // 0x019910BC-0x01991188
		private double Ceiling(XPathNodeIterator nodeIterator) => default; // 0x01991188-0x01991254
		private double Round(XPathNodeIterator nodeIterator) => default; // 0x01991254-0x019912F8
		public override XPathNodeIterator Clone() => default; // 0x01991300-0x01991360
		public override void PrintQuery(XmlWriter w) {} // 0x01991360-0x01991464
	}

	internal sealed class NumericExpr : ValueQuery // TypeDefIndex: 2923
	{
		// Fields
		private Operator.Op op; // 0x14
		private Query opnd1; // 0x18
		private Query opnd2; // 0x20
	
		// Properties
		public override XPathResultType StaticType { get => default; } // 0x01991754-0x0199175C 
	
		// Constructors
		public NumericExpr() {} // Dummy constructor
		public NumericExpr(Operator.Op op, Query opnd1, Query opnd2) {} // 0x01991464-0x01991568
		private NumericExpr(NumericExpr other) {} // 0x01991568-0x019915B8
	
		// Methods
		public override void SetXsltContext(XsltContext context) {} // 0x019915B8-0x0199160C
		public override object Evaluate(XPathNodeIterator nodeIterator) => default; // 0x0199160C-0x01991708
		private static double GetValue(Operator.Op op, double n1, double n2) => default; // 0x01991708-0x01991754
		public override XPathNodeIterator Clone() => default; // 0x0199175C-0x019917BC
		public override void PrintQuery(XmlWriter w) {} // 0x019917BC-0x019918DC
	}

	internal class Operand : AstNode // TypeDefIndex: 2924
	{
		// Fields
		private XPathResultType type; // 0x10
		private object val; // 0x18
	
		// Properties
		public override AstType Type { get => default; } // 0x01991A04-0x01991A0C 
		public override XPathResultType ReturnType { get => default; } // 0x01991A0C-0x01991A14 
		public object OperandValue { get => default; } // 0x01991A14-0x01991A1C 
	
		// Constructors
		public Operand() {} // Dummy constructor
		public Operand(string val) {} // 0x019918DC-0x01991910
		public Operand(double val) {} // 0x01991910-0x01991988
		public Operand(bool val) {} // 0x01991988-0x01991A04
	}

	internal sealed class OperandQuery : ValueQuery // TypeDefIndex: 2925
	{
		// Fields
		internal object val; // 0x18
	
		// Properties
		public override XPathResultType StaticType { get => default; } // 0x01991A50-0x01991A58 
	
		// Constructors
		public OperandQuery() {} // Dummy constructor
		public OperandQuery(object val) {} // 0x01991A1C-0x01991A48
	
		// Methods
		public override object Evaluate(XPathNodeIterator nodeIterator) => default; // 0x01991A48-0x01991A50
		public override XPathNodeIterator Clone() => default; // 0x01991A58-0x01991A5C
		public override void PrintQuery(XmlWriter w) {} // 0x01991A5C-0x01991B6C
	}

	internal class Operator : AstNode // TypeDefIndex: 2926
	{
		// Fields
		private static Op[] invertOp; // 0x00
		private Op opType; // 0x10
		private AstNode opnd1; // 0x18
		private AstNode opnd2; // 0x20
	
		// Properties
		public override AstType Type { get => default; } // 0x01991BAC-0x01991BB4 
		public override XPathResultType ReturnType { get => default; } // 0x01991BB4-0x01991BD8 
		public Op OperatorType { get => default; } // 0x01991BD8-0x01991BE0 
		public AstNode Operand1 { get => default; } // 0x01991BE0-0x01991BE8 
		public AstNode Operand2 { get => default; } // 0x01991BE8-0x01991BF0 
	
		// Nested types
		public enum Op // TypeDefIndex: 2927
		{
			INVALID = 0,
			OR = 1,
			AND = 2,
			EQ = 3,
			NE = 4,
			LT = 5,
			LE = 6,
			GT = 7,
			GE = 8,
			PLUS = 9,
			MINUS = 10,
			MUL = 11,
			DIV = 12,
			MOD = 13,
			UNION = 14
		}
	
		// Constructors
		public Operator() {} // Dummy constructor
		public Operator(Op op, AstNode opnd1, AstNode opnd2) {} // 0x01991B6C-0x01991BAC
		static Operator() {} // 0x01991BF0-0x01991C6C
	
		// Methods
		public static Op InvertOperator(Op op) => default; // 0x0198CED8-0x0198CF6C
	}

	internal sealed class ParentQuery : CacheAxisQuery // TypeDefIndex: 2928
	{
		// Constructors
		public ParentQuery() {} // Dummy constructor
		public ParentQuery(Query qyInput, string Name, string Prefix, XPathNodeType Type) {} // 0x01991C6C-0x01991C70
		private ParentQuery(ParentQuery other) {} // 0x01991C70-0x01991C74
	
		// Methods
		public override object Evaluate(XPathNodeIterator context) => default; // 0x01991C74-0x01991D10
		public override XPathNodeIterator Clone() => default; // 0x01991D10-0x01991D70
	}

	internal sealed class PrecedingQuery : BaseAxisQuery // TypeDefIndex: 2929
	{
		// Fields
		private XPathNodeIterator workIterator; // 0x58
		private ClonableStack<XPathNavigator> ancestorStk; // 0x60
	
		// Properties
		public override QueryProps Properties { get => default; } // 0x01992564-0x0199256C 
	
		// Constructors
		public PrecedingQuery() {} // Dummy constructor
		public PrecedingQuery(Query qyInput, string name, string prefix, XPathNodeType typeTest) {} // 0x019920F8-0x01992198
		private PrecedingQuery(PrecedingQuery other) {} // 0x01992198-0x0199222C
	
		// Methods
		public override void Reset() {} // 0x0199222C-0x019922A4
		public override XPathNavigator Advance() => default; // 0x019922A4-0x01992504
		public override XPathNodeIterator Clone() => default; // 0x01992504-0x01992564
	}

	internal class PreSiblingQuery : CacheAxisQuery // TypeDefIndex: 2930
	{
		// Properties
		public override QueryProps Properties { get => default; } // 0x019920F0-0x019920F8 
	
		// Constructors
		public PreSiblingQuery() {} // Dummy constructor
		public PreSiblingQuery(Query qyInput, string name, string prefix, XPathNodeType typeTest) {} // 0x01991D70-0x01991D74
		protected PreSiblingQuery(PreSiblingQuery other) {} // 0x01991D74-0x01991D78
	
		// Methods
		private bool NotVisited(XPathNavigator nav, List<XPathNavigator> parentStk) => default; // 0x01991D78-0x01991E74
		public override object Evaluate(XPathNodeIterator context) => default; // 0x01991E74-0x01992090
		public override XPathNodeIterator Clone() => default; // 0x01992090-0x019920F0
	}

	internal enum QueryProps // TypeDefIndex: 2931
	{
		None = 0,
		Position = 1,
		Count = 2,
		Cached = 4,
		Reverse = 8,
		Merge = 16
	}

	// [DebuggerDisplay] // 0x00A22E2C-0x00A22E64
	internal abstract class Query : ResetableIterator // TypeDefIndex: 2932
	{
		// Fields
		public const XPathResultType XPathResultType_Navigator = (XPathResultType) 4; // Metadata: 0x003F27F2
	
		// Properties
		public override int Count { get; } // 0x0199259C-0x0199267C 
		public virtual double XsltDefaultPriority { get; } // 0x019926D4-0x019926DC 
		public abstract XPathResultType StaticType { get; }
		public virtual QueryProps Properties { get; } // 0x0199256C-0x01992574 
	
		// Constructors
		public Query() {} // 0x01985FBC-0x01985FC4
		protected Query(Query other) {} // 0x01985FC4-0x01985FCC
	
		// Methods
		public override bool MoveNext() => default; // 0x01992574-0x0199259C
		public virtual void SetXsltContext(XsltContext context) {} // 0x0199267C-0x01992680
		public abstract object Evaluate(XPathNodeIterator nodeIterator);
		public abstract XPathNavigator Advance();
		public virtual XPathNavigator MatchNode(XPathNavigator current) => default; // 0x01992680-0x019926D4
		public static Query Clone(Query input) => default; // 0x01985FCC-0x01986060
		protected static XPathNodeIterator Clone(XPathNodeIterator input) => default; // 0x01987E9C-0x01987EB0
		protected static XPathNavigator Clone(XPathNavigator input) => default; // 0x019875C8-0x019875E0
		public bool Insert(List<XPathNavigator> buffer, XPathNavigator nav) => default; // 0x01989270-0x019893D8
		private static int GetMedian(int l, int r) => default; // 0x019926DC-0x019926E8
		public static XmlNodeOrder CompareNodes(XPathNavigator l, XPathNavigator r) => default; // 0x0198794C-0x01987A64
		// [Conditional] // 0x00A25E90-0x00A25EC8
		private void AssertDOD(List<XPathNavigator> buffer, XPathNavigator nav, int pos) {} // 0x019926E8-0x0199281C
		// [Conditional] // 0x00A25EC8-0x00A25F00
		public static void AssertQuery(Query query) {} // 0x0199281C-0x019929BC
		protected XPathResultType GetXPathType(object value) => default; // 0x0198C764-0x0198C840
		public virtual void PrintQuery(XmlWriter w) {} // 0x019929BC-0x01992A50
	}

	internal sealed class QueryBuilder // TypeDefIndex: 2933
	{
		// Fields
		private string query; // 0x10
		private bool allowVar; // 0x18
		private bool allowKey; // 0x19
		private bool allowCurrent; // 0x1A
		private bool needContext; // 0x1B
		private BaseAxisQuery firstInput; // 0x20
		private int parseDepth; // 0x28
		private const int MaxParseDepth = 1024; // Metadata: 0x003F27F6
	
		// Nested types
		private enum Flags // TypeDefIndex: 2934
		{
			None = 0,
			SmartDesc = 1,
			PosFilter = 2,
			Filter = 4
		}
	
		private enum Props // TypeDefIndex: 2935
		{
			None = 0,
			PosFilter = 1,
			HasPosition = 2,
			HasLast = 4,
			NonFlat = 8
		}
	
		// Constructors
		public QueryBuilder() {} // 0x01988388-0x01988390
	
		// Methods
		private void Reset() {} // 0x01992A50-0x01992A5C
		private Query ProcessAxis(Axis root, Flags flags, out Props props) {
			props = default;
			return default;
		} // 0x01992A5C-0x01993080
		private bool CanBeNumber(Query q) => default; // 0x019933CC-0x01993430
		private Query ProcessFilter(Filter root, Flags flags, out Props props) {
			props = default;
			return default;
		} // 0x01993430-0x01993820
		private Query ProcessOperator(Operator root, out Props props) {
			props = default;
			return default;
		} // 0x01993820-0x01993994
		private Query ProcessVariable(Variable root) => default; // 0x01993994-0x01993A4C
		private Query ProcessFunction(Function root, out Props props) {
			props = default;
			return default;
		} // 0x01993A4C-0x01994050
		private List<Query> ProcessArguments(ArrayList args, out Props props) {
			props = default;
			return default;
		} // 0x01994050-0x019941CC
		private Query ProcessNode(AstNode root, Flags flags, out Props props) {
			props = default;
			return default;
		} // 0x01993080-0x019933CC
		private Query Build(AstNode root, string query) => default; // 0x019941CC-0x01994200
		internal Query Build(string query, bool allowVar, bool allowKey) => default; // 0x01994200-0x019942C4
		internal Query Build(string query, out bool needContext) {
			needContext = default;
			return default;
		} // 0x01988390-0x019883C4
		internal Query BuildPatternQuery(string query, bool allowVar, bool allowKey) => default; // 0x019942C4-0x01994384
		internal Query BuildPatternQuery(string query, out bool needContext) {
			needContext = default;
			return default;
		} // 0x01994384-0x0199BF04
	}

	internal abstract class ResetableIterator : XPathNodeIterator // TypeDefIndex: 2936
	{
		// Properties
		public abstract int CurrentPosition { get; }
	
		// Constructors
		public ResetableIterator() {} // 0x00FBB5D8-0x00FBB604
		protected ResetableIterator(ResetableIterator other) {} // 0x00FBB604-0x00FBB63C
	
		// Methods
		protected void ResetCount() {} // 0x00FBB63C-0x00FBB648
		public abstract void Reset();
		public virtual bool MoveToPosition(int pos) => default; // 0x00FBB648-0x00FBB6C8
	}

	internal sealed class ReversePositionQuery : ForwardPositionQuery // TypeDefIndex: 2937
	{
		// Properties
		public override int CurrentPosition { get => default; } // 0x00FBB73C-0x00FBB798 
		public override QueryProps Properties { get => default; } // 0x00FBB798-0x00FBB7B4 
	
		// Constructors
		public ReversePositionQuery() {} // Dummy constructor
		public ReversePositionQuery(Query input) {} // 0x00FBB6C8-0x00FBB6D0
		private ReversePositionQuery(ReversePositionQuery other) {} // 0x00FBB6D0-0x00FBB6D8
	
		// Methods
		public override XPathNodeIterator Clone() => default; // 0x00FBB6D8-0x00FBB73C
	}

	internal class Root : AstNode // TypeDefIndex: 2938
	{
		// Properties
		public override AstType Type { get => default; } // 0x00FBB7BC-0x00FBB7C4 
		public override XPathResultType ReturnType { get => default; } // 0x00FBB7C4-0x00FBB7CC 
	
		// Constructors
		public Root() {} // 0x00FBB7B4-0x00FBB7BC
	}

	internal sealed class SortQuery : Query // TypeDefIndex: 2939
	{
		// Fields
		private List<MS.Internal.Xml.XPath.SortKey> results; // 0x18
		private XPathSortComparer comparer; // 0x20
		private Query qyInput; // 0x28
	
		// Properties
		public override XPathNavigator Current { get => default; } // 0x00FBC004-0x00FBC08C 
		public override XPathResultType StaticType { get => default; } // 0x00FBC3AC-0x00FBC3B4 
		public override int CurrentPosition { get => default; } // 0x00FBC3B4-0x00FBC3BC 
		public override int Count { get => default; } // 0x00FBC3BC-0x00FBC40C 
		public override QueryProps Properties { get => default; } // 0x00FBC40C-0x00FBC414 
	
		// Constructors
		public SortQuery() {} // Dummy constructor
		public SortQuery(Query qyInput) {} // 0x00FBB924-0x00FBB9C8
		private SortQuery(SortQuery other) {} // 0x00FBB9D0-0x00FBBA88
	
		// Methods
		public override void Reset() {} // 0x00FBBC60-0x00FBBC68
		public override void SetXsltContext(XsltContext xsltContext) {} // 0x00FBBC68-0x00FBBD38
		private void BuildResultsList() {} // 0x00FBBD38-0x00FBBE98
		public override object Evaluate(XPathNodeIterator context) => default; // 0x00FBBED4-0x00FBBF68
		public override XPathNavigator Advance() => default; // 0x00FBBF68-0x00FBC004
		internal void AddSort(Query evalQuery, IComparer comparer) {} // 0x00FBC08C-0x00FBC0A4
		public override XPathNodeIterator Clone() => default; // 0x00FBC34C-0x00FBC3AC
		public override void PrintQuery(XmlWriter w) {} // 0x00FBC414-0x00FBC4E4
	}

	internal sealed class SortKey // TypeDefIndex: 2940
	{
		// Fields
		private int numKeys; // 0x10
		private object[] keys; // 0x18
		private int originalPosition; // 0x20
		private XPathNavigator node; // 0x28
	
		// Properties
		public object this[int index] { get => default; set {} } // 0x00FBB858-0x00FBB894 0x00FBB894-0x00FBB90C
		public int NumKeys { get => default; } // 0x00FBB90C-0x00FBB914 
		public int OriginalPosition { get => default; } // 0x00FBB914-0x00FBB91C 
		public XPathNavigator Node { get => default; } // 0x00FBB91C-0x00FBB924 
	
		// Constructors
		public SortKey() {} // Dummy constructor
		public SortKey(int numKeys, int originalPosition, XPathNavigator node) {} // 0x00FBB7CC-0x00FBB858
	}

	internal sealed class XPathSortComparer : IComparer<MS.Internal.Xml.XPath.SortKey> // TypeDefIndex: 2941
	{
		// Fields
		private const int minSize = 3; // Metadata: 0x003F281E
		private Query[] expressions; // 0x10
		private IComparer[] comparers; // 0x18
		private int numSorts; // 0x20
	
		// Properties
		public int NumSorts { get => default; } // 0x00FC5384-0x00FC538C 
	
		// Constructors
		public XPathSortComparer(int size) {} // 0x00FC52F0-0x00FC5384
		public XPathSortComparer() {} // 0x00FBB9C8-0x00FBB9D0
	
		// Methods
		public void AddSort(Query evalQuery, IComparer comparer) {} // 0x00FBC0A4-0x00FBC34C
		public Query Expression(int i) => default; // 0x00FBBE98-0x00FBBED4
		int IComparer<SortKey>.Compare(MS.Internal.Xml.XPath.SortKey x, MS.Internal.Xml.XPath.SortKey y) => default; // 0x00FC538C-0x00FC54E8
		internal XPathSortComparer Clone() => default; // 0x00FBBA88-0x00FBBC60
	}

	internal sealed class StringFunctions : ValueQuery // TypeDefIndex: 2942
	{
		// Fields
		private Function.FunctionType funcType; // 0x14
		private IList<Query> argList; // 0x18
		private static readonly CompareInfo compareInfo; // 0x00
	
		// Properties
		public override XPathResultType StaticType { get => default; } // 0x00FBE328-0x00FBE35C 
	
		// Constructors
		public StringFunctions() {} // Dummy constructor
		public StringFunctions(Function.FunctionType funcType, IList<Query> argList) {} // 0x00FBC4E4-0x00FBC520
		private StringFunctions(StringFunctions other) {} // 0x00FBC528-0x00FBC710
		static StringFunctions() {} // 0x00FBE6D4-0x00FBE764
	
		// Methods
		public override void SetXsltContext(XsltContext context) {} // 0x00FBC718-0x00FBC884
		public override object Evaluate(XPathNodeIterator nodeIterator) => default; // 0x00FBC884-0x00FBC9F8
		internal static string toString(double num) => default; // 0x00FBE268-0x00FBE2CC
		internal static string toString(bool b) => default; // 0x00FBE2CC-0x00FBE328
		private string toString(XPathNodeIterator nodeIterator) => default; // 0x00FBC9F8-0x00FBCD8C
		private string Concat(XPathNodeIterator nodeIterator) => default; // 0x00FBCD8C-0x00FBCF54
		private bool StartsWith(XPathNodeIterator nodeIterator) => default; // 0x00FBCF54-0x00FBD118
		private bool Contains(XPathNodeIterator nodeIterator) => default; // 0x00FBD118-0x00FBD2F8
		private string SubstringBefore(XPathNodeIterator nodeIterator) => default; // 0x00FBD2F8-0x00FBD51C
		private string SubstringAfter(XPathNodeIterator nodeIterator) => default; // 0x00FBD51C-0x00FBD73C
		private string Substring(XPathNodeIterator nodeIterator) => default; // 0x00FBD73C-0x00FBDB50
		private double StringLength(XPathNodeIterator nodeIterator) => default; // 0x00FBDB50-0x00FBDCE4
		private string Normalize(XPathNodeIterator nodeIterator) => default; // 0x00FBDCE4-0x00FBDF80
		private string Translate(XPathNodeIterator nodeIterator) => default; // 0x00FBDF80-0x00FBE268
		public override XPathNodeIterator Clone() => default; // 0x00FBE35C-0x00FBE3BC
		public override void PrintQuery(XmlWriter w) {} // 0x00FBE3BC-0x00FBE6D4
	}

	internal sealed class UnionExpr : Query // TypeDefIndex: 2943
	{
		// Fields
		internal Query qy1; // 0x18
		internal Query qy2; // 0x20
		private bool advance1; // 0x28
		private bool advance2; // 0x29
		private XPathNavigator currentNode; // 0x30
		private XPathNavigator nextNode; // 0x38
	
		// Properties
		public override XPathResultType StaticType { get => default; } // 0x00FBEADC-0x00FBEAE4 
		public override XPathNavigator Current { get => default; } // 0x00FBEB44-0x00FBEB4C 
		public override int CurrentPosition { get => default; } // 0x00FBEB4C-0x00FBEBAC 
	
		// Constructors
		public UnionExpr() {} // Dummy constructor
		public UnionExpr(Query query1, Query query2) {} // 0x00FBE764-0x00FBE7A4
		private UnionExpr(UnionExpr other) {} // 0x00FBE7A4-0x00FBE824
	
		// Methods
		public override void Reset() {} // 0x00FBE824-0x00FBE878
		public override void SetXsltContext(XsltContext xsltContext) {} // 0x00FBE878-0x00FBE8CC
		public override object Evaluate(XPathNodeIterator context) => default; // 0x00FBE8CC-0x00FBE93C
		private XPathNavigator ProcessSamePosition(XPathNavigator result) => default; // 0x00FBE93C-0x00FBE950
		private XPathNavigator ProcessBeforePosition(XPathNavigator res1, XPathNavigator res2) => default; // 0x00FBE950-0x00FBE964
		private XPathNavigator ProcessAfterPosition(XPathNavigator res1, XPathNavigator res2) => default; // 0x00FBE964-0x00FBE978
		public override XPathNavigator Advance() => default; // 0x00FBE978-0x00FBEA70
		public override XPathNavigator MatchNode(XPathNavigator xsltContext) => default; // 0x00FBEA70-0x00FBEADC
		public override XPathNodeIterator Clone() => default; // 0x00FBEAE4-0x00FBEB44
		public override void PrintQuery(XmlWriter w) {} // 0x00FBEBAC-0x00FBEC44
	}

	internal abstract class ValueQuery : Query // TypeDefIndex: 2944
	{
		// Properties
		public sealed override XPathNavigator Current { get; } // 0x00FBEC48-0x00FBEC9C 
		public sealed override int CurrentPosition { get; } // 0x00FBEC9C-0x00FBECF0 
		public sealed override int Count { get; } // 0x00FBECF0-0x00FBED44 
	
		// Constructors
		public ValueQuery() {} // 0x00FBC520-0x00FBC528
		protected ValueQuery(ValueQuery other) {} // 0x00FBC710-0x00FBC718
	
		// Methods
		public sealed override void Reset() {} // 0x00FBEC44-0x00FBEC48
		public sealed override XPathNavigator Advance() => default; // 0x00FBED44-0x00FBED98
	}

	internal class Variable : AstNode // TypeDefIndex: 2945
	{
		// Fields
		private string localname; // 0x10
		private string prefix; // 0x18
	
		// Properties
		public override AstType Type { get => default; } // 0x00FBEDD0-0x00FBEDD8 
		public override XPathResultType ReturnType { get => default; } // 0x00FBEDD8-0x00FBEDE0 
		public string Localname { get => default; } // 0x00FBEDE0-0x00FBEDE8 
		public string Prefix { get => default; } // 0x00FBEDE8-0x00FBEDF0 
	
		// Constructors
		public Variable() {} // Dummy constructor
		public Variable(string name, string prefix) {} // 0x00FBED98-0x00FBEDD0
	}

	internal sealed class VariableQuery : ExtensionQuery // TypeDefIndex: 2946
	{
		// Fields
		private IXsltContextVariable variable; // 0x38
	
		// Properties
		public override XPathResultType StaticType { get => default; } // 0x00FBF008-0x00FBF084 
	
		// Constructors
		public VariableQuery() {} // Dummy constructor
		public VariableQuery(string name, string prefix) {} // 0x00FBEDF0-0x00FBEE04
		private VariableQuery(VariableQuery other) {} // 0x00FBEE04-0x00FBEE3C
	
		// Methods
		public override void SetXsltContext(XsltContext context) {} // 0x00FBEE3C-0x00FBEF0C
		public override object Evaluate(XPathNodeIterator nodeIterator) => default; // 0x00FBEF0C-0x00FBF008
		public override XPathNodeIterator Clone() => default; // 0x00FBF084-0x00FBF0E4
		public override void PrintQuery(XmlWriter w) {} // 0x00FBF0E4-0x00FBF1BC
	}

	internal class XPathAncestorIterator : XPathAxisIterator // TypeDefIndex: 2947
	{
		// Constructors
		public XPathAncestorIterator() {} // Dummy constructor
		public XPathAncestorIterator(XPathNavigator nav, XPathNodeType type, bool matchSelf) {} // 0x00FBF1BC-0x00FBF20C
		public XPathAncestorIterator(XPathNavigator nav, string name, string namespaceURI, bool matchSelf) {} // 0x00FBF25C-0x00FBF264
		public XPathAncestorIterator(XPathAncestorIterator other) {} // 0x00FBF348-0x00FBF34C
	
		// Methods
		public override bool MoveNext() => default; // 0x00FBF3D0-0x00FBF46C
		public override XPathNodeIterator Clone() => default; // 0x00FBF46C-0x00FBF4CC
	}

	internal sealed class XPathAncestorQuery : CacheAxisQuery // TypeDefIndex: 2948
	{
		// Fields
		private bool matchSelf; // 0x60
	
		// Properties
		public override int CurrentPosition { get => default; } // 0x00FBF6B4-0x00FBF710 
		public override QueryProps Properties { get => default; } // 0x00FBF710-0x00FBF72C 
	
		// Constructors
		public XPathAncestorQuery() {} // Dummy constructor
		public XPathAncestorQuery(Query qyInput, string name, string prefix, XPathNodeType typeTest, bool matchSelf) {} // 0x00FBF4CC-0x00FBF4FC
		private XPathAncestorQuery(XPathAncestorQuery other) {} // 0x00FBF4FC-0x00FBF534
	
		// Methods
		public override object Evaluate(XPathNodeIterator context) => default; // 0x00FBF534-0x00FBF654
		public override XPathNodeIterator Clone() => default; // 0x00FBF654-0x00FBF6B4
		public override void PrintQuery(XmlWriter w) {} // 0x00FBF72C-0x00FBF8CC
	}

	// [DebuggerDisplay] // 0x00A22E9C-0x00A22ED4
	internal class XPathArrayIterator : ResetableIterator // TypeDefIndex: 2949
	{
		// Fields
		protected IList list; // 0x18
		protected int index; // 0x20
	
		// Properties
		public IList AsList { get => default; } // 0x00FBFAA0-0x00FBFAA8 
		public override XPathNavigator Current { get => default; } // 0x00FBFB08-0x00FBFCAC 
		public override int CurrentPosition { get => default; } // 0x00FBFCAC-0x00FBFCB4 
		public override int Count { get => default; } // 0x00FBFCB4-0x00FBFD68 
		private new object debuggerDisplayProxy { get => default; } // 0x00FBFF04-0x00FBFF8C 
	
		// Constructors
		public XPathArrayIterator() {} // Dummy constructor
		public XPathArrayIterator(IList list) {} // 0x00FBF8CC-0x00FBF900
		public XPathArrayIterator(XPathArrayIterator it) {} // 0x00FBF900-0x00FBF948
		public XPathArrayIterator(XPathNodeIterator nodeIterator) {} // 0x00FBF948-0x00FBFAA0
	
		// Methods
		public override XPathNodeIterator Clone() => default; // 0x00FBFAA8-0x00FBFB08
		public override bool MoveNext() => default; // 0x00FBFD68-0x00FBFE4C
		public override void Reset() {} // 0x00FBFE4C-0x00FBFE54
		public override IEnumerator GetEnumerator() => default; // 0x00FBFE54-0x00FBFF04
	}

	internal abstract class XPathAxisIterator : XPathNodeIterator // TypeDefIndex: 2950
	{
		// Fields
		internal XPathNavigator nav; // 0x18
		internal XPathNodeType type; // 0x20
		internal string name; // 0x28
		internal string uri; // 0x30
		internal int position; // 0x38
		internal bool matchSelf; // 0x3C
		internal bool first; // 0x3D
	
		// Properties
		public override XPathNavigator Current { get; } // 0x00FBFFD4-0x00FBFFDC 
		public override int CurrentPosition { get; } // 0x00FBFFDC-0x00FBFFE4 
		protected virtual bool Matches { get; } // 0x00FBFFE4-0x00FC0124 
	
		// Constructors
		protected XPathAxisIterator() {} // Dummy constructor
		public XPathAxisIterator(XPathNavigator nav, bool matchSelf) {} // 0x00FBFF8C-0x00FBFFD4
		public XPathAxisIterator(XPathNavigator nav, XPathNodeType type, bool matchSelf) {} // 0x00FBF20C-0x00FBF25C
		public XPathAxisIterator(XPathNavigator nav, string name, string namespaceURI, bool matchSelf) {} // 0x00FBF264-0x00FBF348
		public XPathAxisIterator(XPathAxisIterator it) {} // 0x00FBF34C-0x00FBF3D0
	}

	internal class XPathChildIterator : XPathAxisIterator // TypeDefIndex: 2951
	{
		// Constructors
		public XPathChildIterator() {} // Dummy constructor
		public XPathChildIterator(XPathNavigator nav, XPathNodeType type) {} // 0x00FC0124-0x00FC016C
		public XPathChildIterator(XPathNavigator nav, string name, string namespaceURI) {} // 0x00FC016C-0x00FC0174
		public XPathChildIterator(XPathChildIterator it) {} // 0x00FC0174-0x00FC0178
	
		// Methods
		public override XPathNodeIterator Clone() => default; // 0x00FC0178-0x00FC01D8
		public override bool MoveNext() => default; // 0x00FC01D8-0x00FC0258
	}

	internal class XPathDescendantIterator : XPathAxisIterator // TypeDefIndex: 2952
	{
		// Fields
		private int level; // 0x40
	
		// Constructors
		public XPathDescendantIterator() {} // Dummy constructor
		public XPathDescendantIterator(XPathNavigator nav, XPathNodeType type, bool matchSelf) {} // 0x00FC0570-0x00FC05C0
		public XPathDescendantIterator(XPathNavigator nav, string name, string namespaceURI, bool matchSelf) {} // 0x00FC05C0-0x00FC05C8
		public XPathDescendantIterator(XPathDescendantIterator it) {} // 0x00FC05C8-0x00FC05FC
	
		// Methods
		public override XPathNodeIterator Clone() => default; // 0x00FC05FC-0x00FC065C
		public override bool MoveNext() => default; // 0x00FC065C-0x00FC0754
	}

	internal sealed class XPathEmptyIterator : ResetableIterator // TypeDefIndex: 2953
	{
		// Fields
		public static XPathEmptyIterator Instance; // 0x00
	
		// Properties
		public override XPathNavigator Current { get => default; } // 0x00FC0784-0x00FC078C 
		public override int CurrentPosition { get => default; } // 0x00FC078C-0x00FC0794 
		public override int Count { get => default; } // 0x00FC0794-0x00FC079C 
	
		// Constructors
		private XPathEmptyIterator() {} // 0x00FC0754-0x00FC0780
		static XPathEmptyIterator() {} // 0x00FC07A8-0x00FC0814
	
		// Methods
		public override XPathNodeIterator Clone() => default; // 0x00FC0780-0x00FC0784
		public override bool MoveNext() => default; // 0x00FC079C-0x00FC07A4
		public override void Reset() {} // 0x00FC07A4-0x00FC07A8
	}

	internal class XPathMultyIterator : ResetableIterator // TypeDefIndex: 2954
	{
		// Fields
		protected ResetableIterator[] arr; // 0x18
		protected int firstNotEmpty; // 0x20
		protected int position; // 0x24
	
		// Properties
		public override XPathNavigator Current { get => default; } // 0x00FC0EB0-0x00FC0EFC 
		public override int CurrentPosition { get => default; } // 0x00FC0EFC-0x00FC0F04 
	
		// Constructors
		public XPathMultyIterator() {} // Dummy constructor
		public XPathMultyIterator(ArrayList inputArray) {} // 0x00FC0814-0x00FC09BC
		public XPathMultyIterator(XPathMultyIterator it) {} // 0x00FC0D98-0x00FC0E50
	
		// Methods
		private void Init() {} // 0x00FC09BC-0x00FC0A3C
		private bool Advance(int pos) => default; // 0x00FC0A3C-0x00FC0B40
		private bool SiftItem(int item) => default; // 0x00FC0B40-0x00FC0D20
		public override void Reset() {} // 0x00FC0D20-0x00FC0D98
		public override XPathNodeIterator Clone() => default; // 0x00FC0E50-0x00FC0EB0
		public override bool MoveNext() => default; // 0x00FC0F04-0x00FC0F94
	}

	internal class XPathParser // TypeDefIndex: 2955
	{
		// Fields
		private XPathScanner scanner; // 0x10
		private int parseDepth; // 0x18
		private const int MaxParseDepth = 200; // Metadata: 0x003F2822
		private static readonly XPathResultType[] temparray1; // 0x00
		private static readonly XPathResultType[] temparray2; // 0x08
		private static readonly XPathResultType[] temparray3; // 0x10
		private static readonly XPathResultType[] temparray4; // 0x18
		private static readonly XPathResultType[] temparray5; // 0x20
		private static readonly XPathResultType[] temparray6; // 0x28
		private static readonly XPathResultType[] temparray7; // 0x30
		private static readonly XPathResultType[] temparray8; // 0x38
		private static readonly XPathResultType[] temparray9; // 0x40
		private static Hashtable functionTable; // 0x48
		private static Hashtable AxesTable; // 0x50
	
		// Nested types
		private class ParamInfo // TypeDefIndex: 2956
		{
			// Fields
			private Function.FunctionType ftype; // 0x10
			private int minargs; // 0x14
			private int maxargs; // 0x18
			private XPathResultType[] argTypes; // 0x20
	
			// Properties
			public Function.FunctionType FType { get => default; } // 0x00FC4A18-0x00FC4A20 
			public int Minargs { get => default; } // 0x00FC4A20-0x00FC4A28 
			public int Maxargs { get => default; } // 0x00FC4A28-0x00FC4A30 
			public XPathResultType[] ArgTypes { get => default; } // 0x00FC4A30-0x00FC4A38 
	
			// Constructors
			public ParamInfo() {} // Dummy constructor
			internal ParamInfo(Function.FunctionType ftype, int minargs, int maxargs, XPathResultType[] argTypes) {} // 0x00FC4484-0x00FC44D4
		}
	
		// Constructors
		public XPathParser() {} // Dummy constructor
		private XPathParser(XPathScanner scanner) {} // 0x00FC0F94-0x00FC0FC0
		static XPathParser() {} // 0x00FC4820-0x00FC4A18
	
		// Methods
		public static AstNode ParseXPathExpresion(string xpathExpresion) => default; // 0x00FC0FC0-0x00FC1090
		public static AstNode ParseXPathPattern(string xpathPattern) => default; // 0x00FC11E4-0x00FC12B4
		private AstNode ParseExpresion(AstNode qyInput) => default; // 0x00FC1148-0x00FC11E4
		private AstNode ParseOrExpr(AstNode qyInput) => default; // 0x00FC1384-0x00FC1470
		private AstNode ParseAndExpr(AstNode qyInput) => default; // 0x00FC1470-0x00FC155C
		private AstNode ParseEqualityExpr(AstNode qyInput) => default; // 0x00FC15C4-0x00FC16B0
		private AstNode ParseRelationalExpr(AstNode qyInput) => default; // 0x00FC16B0-0x00FC17C4
		private AstNode ParseAdditiveExpr(AstNode qyInput) => default; // 0x00FC17C4-0x00FC18B0
		private AstNode ParseMultiplicativeExpr(AstNode qyInput) => default; // 0x00FC18B0-0x00FC19D8
		private AstNode ParseUnaryExpr(AstNode qyInput) => default; // 0x00FC19D8-0x00FC1AB4
		private AstNode ParseUnionExpr(AstNode qyInput) => default; // 0x00FC1AB4-0x00FC1BC0
		private static bool IsNodeType(XPathScanner scaner) => default; // 0x00FC1D70-0x00FC1E48
		private AstNode ParsePathExpr(AstNode qyInput) => default; // 0x00FC1BC0-0x00FC1CE0
		private AstNode ParseFilterExpr(AstNode qyInput) => default; // 0x00FC1F08-0x00FC1FCC
		private AstNode ParsePredicate(AstNode qyInput) => default; // 0x00FC23D8-0x00FC2448
		private AstNode ParseLocationPath(AstNode qyInput) => default; // 0x00FC20A0-0x00FC21E8
		private AstNode ParseRelativeLocationPath(AstNode qyInput) => default; // 0x00FC1FCC-0x00FC20A0
		private static bool IsStep(XPathScanner.LexKind lexKind) => default; // 0x00FC2474-0x00FC24BC
		private AstNode ParseStep(AstNode qyInput) => default; // 0x00FC24BC-0x00FC2654
		private AstNode ParseNodeTest(AstNode qyInput, Axis.AxisType axisType, XPathNodeType nodeType) => default; // 0x00FC2750-0x00FC2A00
		private static bool IsPrimaryExpr(XPathScanner scanner) => default; // 0x00FC1E48-0x00FC1F08
		private AstNode ParsePrimaryExpr(AstNode qyInput) => default; // 0x00FC21E8-0x00FC23D8
		private AstNode ParseMethod(AstNode qyInput) => default; // 0x00FC2A98-0x00FC3020
		private AstNode ParsePattern(AstNode qyInput) => default; // 0x00FC12B4-0x00FC1384
		private AstNode ParseLocationPathPattern(AstNode qyInput) => default; // 0x00FC3020-0x00FC31A4
		private AstNode ParseIdKeyPattern(AstNode qyInput) => default; // 0x00FC31A4-0x00FC34CC
		private AstNode ParseRelativePathPattern(AstNode qyInput) => default; // 0x00FC34CC-0x00FC35A0
		private AstNode ParseStepPattern(AstNode qyInput) => default; // 0x00FC35A0-0x00FC36FC
		private void CheckToken(XPathScanner.LexKind t) {} // 0x00FC2A00-0x00FC2A98
		private void PassToken(XPathScanner.LexKind t) {} // 0x00FC2448-0x00FC2474
		private void NextLex() {} // 0x00FC15AC-0x00FC15C4
		private bool TestOp(string op) => default; // 0x00FC155C-0x00FC15AC
		private void CheckNodeSet(XPathResultType t) {} // 0x00FC1CE0-0x00FC1D70
		private static Hashtable CreateFunctionTable() => default; // 0x00FC3A8C-0x00FC4484
		private static Hashtable CreateAxesTable() => default; // 0x00FC44D4-0x00FC4820
		private Axis.AxisType GetAxis(XPathScanner scaner) => default; // 0x00FC2654-0x00FC2750
	}

	internal sealed class XPathScanner // TypeDefIndex: 2957
	{
		// Fields
		private string xpathExpr; // 0x10
		private int xpathExprIndex; // 0x18
		private LexKind kind; // 0x1C
		private char currentChar; // 0x20
		private string name; // 0x28
		private string prefix; // 0x30
		private string stringValue; // 0x38
		private double numberValue; // 0x40
		private bool canBeFunction; // 0x48
		private XmlCharType xmlCharType; // 0x50
	
		// Properties
		public string SourceText { get => default; } // 0x00FC4A98-0x00FC4AA0 
		private char CurerntChar { get => default; } // 0x00FC4AA0-0x00FC4AA8 
		public LexKind Kind { get => default; } // 0x00FC4AA8-0x00FC4AB0 
		public string Name { get => default; } // 0x00FC4AB0-0x00FC4AB8 
		public string Prefix { get => default; } // 0x00FC4AB8-0x00FC4AC0 
		public string StringValue { get => default; } // 0x00FC4AC0-0x00FC4AC8 
		public double NumberValue { get => default; } // 0x00FC4AC8-0x00FC4AD0 
		public bool CanBeFunction { get => default; } // 0x00FC4AD0-0x00FC4AD8 
	
		// Nested types
		public enum LexKind // TypeDefIndex: 2958
		{
			Bang = 33,
			Quote = 34,
			Dollar = 36,
			Apos = 39,
			LParens = 40,
			RParens = 41,
			Star = 42,
			Plus = 43,
			Comma = 44,
			Minus = 45,
			Dot = 46,
			Slash = 47,
			Lt = 60,
			Eq = 61,
			Gt = 62,
			At = 64,
			And = 65,
			DotDot = 68,
			Eof = 69,
			Ge = 71,
			Le = 76,
			Ne = 78,
			Or = 79,
			SlashSlash = 83,
			LBracket = 91,
			RBracket = 93,
			Axe = 97,
			Number = 100,
			Name = 110,
			String = 115,
			Union = 124
		}
	
		// Constructors
		public XPathScanner() {} // Dummy constructor
		public XPathScanner(string xpathExpr) {} // 0x00FC1090-0x00FC1148
	
		// Methods
		private bool NextChar() => default; // 0x00FC4A38-0x00FC4A98
		private void SkipSpace() {} // 0x00FC4AD8-0x00FC4B18
		public bool NextLex() => default; // 0x00FC36FC-0x00FC3A8C
		private double ScanNumber() => default; // 0x00FC4CB8-0x00FC4DA8
		private double ScanFraction() => default; // 0x00FC4B18-0x00FC4BE0
		private string ScanString() => default; // 0x00FC4BE0-0x00FC4CB8
		private string ScanName() => default; // 0x00FC4DA8-0x00FC4E24
	}

	internal class XPathSelectionIterator : ResetableIterator // TypeDefIndex: 2959
	{
		// Fields
		private XPathNavigator nav; // 0x18
		private Query query; // 0x20
		private int position; // 0x28
	
		// Properties
		public override int Count { get => default; } // 0x00FC5008-0x00FC5028 
		public override XPathNavigator Current { get => default; } // 0x00FC5028-0x00FC5030 
		public override int CurrentPosition { get => default; } // 0x00FC5030-0x00FC5038 
	
		// Constructors
		public XPathSelectionIterator() {} // Dummy constructor
		internal XPathSelectionIterator(XPathNavigator nav, Query query) {} // 0x00FC4E24-0x00FC4E80
		protected XPathSelectionIterator(XPathSelectionIterator it) {} // 0x00FC4E80-0x00FC4F60
	
		// Methods
		public override void Reset() {} // 0x00FC4F60-0x00FC4F80
		public override bool MoveNext() => default; // 0x00FC4F80-0x00FC5008
		public override XPathNodeIterator Clone() => default; // 0x00FC5038-0x00FC5098
	}

	internal sealed class XPathSelfQuery : BaseAxisQuery // TypeDefIndex: 2960
	{
		// Constructors
		public XPathSelfQuery() {} // Dummy constructor
		public XPathSelfQuery(Query qyInput, string Name, string Prefix, XPathNodeType Type) {} // 0x00FC5098-0x00FC50A0
		private XPathSelfQuery(XPathSelfQuery other) {} // 0x00FC50A0-0x00FC50A8
	
		// Methods
		public override XPathNavigator Advance() => default; // 0x00FC50A8-0x00FC5110
		public override XPathNodeIterator Clone() => default; // 0x00FC5110-0x00FC5174
	}

	internal class XPathSingletonIterator : ResetableIterator // TypeDefIndex: 2961
	{
		// Fields
		private XPathNavigator nav; // 0x18
		private int position; // 0x20
	
		// Properties
		public override XPathNavigator Current { get => default; } // 0x00FC52B0-0x00FC52B8 
		public override int CurrentPosition { get => default; } // 0x00FC52B8-0x00FC52C0 
		public override int Count { get => default; } // 0x00FC52C0-0x00FC52C8 
	
		// Constructors
		public XPathSingletonIterator() {} // Dummy constructor
		public XPathSingletonIterator(XPathNavigator nav) {} // 0x00FC5174-0x00FC51A8
		public XPathSingletonIterator(XPathNavigator nav, bool moved) {} // 0x00FC51A8-0x00FC51F4
		public XPathSingletonIterator(XPathSingletonIterator it) {} // 0x00FC51F4-0x00FC5250
	
		// Methods
		public override XPathNodeIterator Clone() => default; // 0x00FC5250-0x00FC52B0
		public override bool MoveNext() => default; // 0x00FC52C8-0x00FC52E8
		public override void Reset() {} // 0x00FC52E8-0x00FC52F0
	}
}

namespace MS.Internal.Xml.Cache
{
	internal enum TextBlockType // TypeDefIndex: 2962
	{
		None = 0,
		Text = 4,
		SignificantWhitespace = 5,
		Whitespace = 6
	}

	internal sealed class XPathDocumentBuilder : XmlRawWriter // TypeDefIndex: 2963
	{
		// Fields
		private NodePageFactory nodePageFact; // 0x28
		private NodePageFactory nmspPageFact; // 0x40
		private TextBlockBuilder textBldr; // 0x58
		private Stack<XPathNodeRef> stkNmsp; // 0x78
		private XPathNodeInfoTable infoTable; // 0x80
		private XPathDocument doc; // 0x88
		private IXmlLineInfo lineInfo; // 0x90
		private XmlNameTable nameTable; // 0x98
		private bool atomizeNames; // 0xA0
		private XPathNode[] pageNmsp; // 0xA8
		private int idxNmsp; // 0xB0
		private XPathNode[] pageParent; // 0xB8
		private int idxParent; // 0xC0
		private XPathNode[] pageSibling; // 0xC8
		private int idxSibling; // 0xD0
		private int lineNumBase; // 0xD4
		private int linePosBase; // 0xD8
		private XmlQualifiedName idAttrName; // 0xE0
		private Hashtable elemIdMap; // 0xE8
		private XPathNodeRef[] elemNameIndex; // 0xF0
		private const int ElementIndexSize = 64; // Metadata: 0x003F28B2
	
		// Nested types
		private struct NodePageFactory // TypeDefIndex: 2964
		{
			// Fields
			private XPathNode[] page; // 0x00
			private XPathNodePageInfo pageInfo; // 0x08
			private int pageSize; // 0x10
	
			// Properties
			public XPathNode[] NextNodePage { get => default; } // 0x00AF1564-0x00AF156C 
			public int NextNodeIndex { get => default; } // 0x00AF156C-0x00AF1588 
	
			// Methods
			public void Init(int initialPageSize) {} // 0x00AF155C-0x00AF1564
			public void AllocateSlot(out XPathNode[] page, out int idx) {
				page = default;
				idx = default;
			} // 0x00AF1588-0x00AF15CC
		}
	
		private struct TextBlockBuilder // TypeDefIndex: 2965
		{
			// Fields
			private IXmlLineInfo lineInfo; // 0x00
			private TextBlockType textType; // 0x08
			private string text; // 0x10
			private int lineNum; // 0x18
			private int linePos; // 0x1C
	
			// Properties
			public TextBlockType TextType { get => default; } // 0x00AF15D8-0x00AF15E0 
			public bool HasText { get => default; } // 0x00AF15E0-0x00AF15F0 
			public int LineNumber { get => default; } // 0x00AF15F0-0x00AF15F8 
			public int LinePosition { get => default; } // 0x00AF15F8-0x00AF1600 
	
			// Methods
			public void Initialize(IXmlLineInfo lineInfo) {} // 0x00AF15CC-0x00AF15D8
			public void WriteTextBlock(string text, TextBlockType textType) {} // 0x00AF1600-0x00AF1608
			public string ReadText() => default; // 0x00AF1608-0x00AF164C
		}
	
		// Constructors
		public XPathDocumentBuilder() {} // Dummy constructor
		public XPathDocumentBuilder(XPathDocument doc, IXmlLineInfo lineInfo, string baseUri, XPathDocument.LoadFlags flags) {} // 0x0197E774-0x0197E8F0
	
		// Methods
		public void Initialize(XPathDocument doc, IXmlLineInfo lineInfo, string baseUri, XPathDocument.LoadFlags flags) {} // 0x0197E8F0-0x0197EB10
		public override void WriteDocType(string name, string pubid, string sysid, string subset) {} // 0x0197EE48-0x0197EE4C
		public override void WriteStartElement(string prefix, string localName, string ns) {} // 0x0197EE4C-0x0197EECC
		public void WriteStartElement(string prefix, string localName, string ns, string baseUri) {} // 0x0197EECC-0x0197F0B8
		public override void WriteEndElement() {} // 0x0197F258-0x0197F260
		public override void WriteFullEndElement() {} // 0x0197F4A4-0x0197F4AC
		internal override void WriteEndElement(string prefix, string localName, string namespaceName) {} // 0x0197F4AC-0x0197F4B4
		internal override void WriteFullEndElement(string prefix, string localName, string namespaceName) {} // 0x0197F4B4-0x0197F5A4
		public void WriteEndElement(bool allowShortcutTag) {} // 0x0197F260-0x0197F4A4
		public override void WriteStartAttribute(string prefix, string localName, string namespaceName) {} // 0x0197F70C-0x0197F7F8
		public override void WriteEndAttribute() {} // 0x0197F7F8-0x0197F9AC
		public override void WriteCData(string text) {} // 0x0197F9AC-0x0197F9B8
		public override void WriteComment(string text) {} // 0x0197F9C0-0x0197FA68
		public override void WriteProcessingInstruction(string name, string text) {} // 0x0197FA68-0x0197FAD8
		public void WriteProcessingInstruction(string name, string text, string baseUri) {} // 0x0197FAD8-0x0197FBB4
		public override void WriteWhitespace(string ws) {} // 0x0197FBB4-0x0197FBC0
		public override void WriteString(string text) {} // 0x0197FBC0-0x0197FBCC
		public override void WriteChars(char[] buffer, int index, int count) {} // 0x0197FBCC-0x0197FC04
		public override void WriteRaw(string data) {} // 0x0197FC04-0x0197FC10
		public override void WriteRaw(char[] buffer, int index, int count) {} // 0x0197FC10-0x0197FDC8
		public void WriteString(string text, TextBlockType textType) {} // 0x0197F9B8-0x0197F9C0
		public override void WriteEntityRef(string name) {} // 0x0197FDC8-0x0197FE28
		public override void WriteCharEntity(char ch) {} // 0x0197FE28-0x0197FEC8
		public override void WriteSurrogateCharEntity(char lowChar, char highChar) {} // 0x0197FEC8-0x0197FF78
		public override void Close() {} // 0x0197FF78-0x01980074
		public override void Flush() {} // 0x01980074-0x01980078
		internal override void WriteXmlDeclaration(XmlStandalone standalone) {} // 0x01980078-0x0198007C
		internal override void WriteXmlDeclaration(string xmldecl) {} // 0x0198007C-0x01980080
		internal override void StartElementContent() {} // 0x01980080-0x01980084
		internal override void WriteNamespaceDeclaration(string prefix, string namespaceName) {} // 0x01980084-0x01980494
		public void CreateIdTables(IDtdInfo dtdInfo) {} // 0x01980494-0x01980C08
		private XPathNodeRef LinkSimilarElements(XPathNode[] pagePrev, int idxPrev, XPathNode[] pageNext, int idxNext) => default; // 0x0197F1F4-0x0197F258
		private int NewNamespaceNode(out XPathNode[] page, string prefix, string namespaceUri, XPathNode[] pageElem, int idxElem) {
			page = default;
			return default;
		} // 0x0197ECD4-0x0197EE48
		private int NewNode(out XPathNode[] page, XPathNodeType xptyp, string localName, string namespaceUri, string prefix, string baseUri) {
			page = default;
			return default;
		} // 0x0197EB78-0x0197ECD4
		private void ComputeLineInfo(bool isTextNode, out int lineNumOffset, out int linePosOffset) {
			lineNumOffset = default;
			linePosOffset = default;
		} // 0x01980C08-0x01980D98
		private void AddSibling(XPathNodeType xptyp, string localName, string namespaceUri, string prefix, string baseUri) {} // 0x0197F0B8-0x0197F1F4
		private void CachedTextNode() {} // 0x0197F5A4-0x0197F70C
	}

	internal abstract class XPathDocumentBaseIterator : XPathNodeIterator // TypeDefIndex: 2966
	{
		// Fields
		protected XPathDocumentNavigator ctxt; // 0x18
		protected int pos; // 0x20
	
		// Properties
		public override XPathNavigator Current { get; } // 0x0197E764-0x0197E76C 
		public override int CurrentPosition { get; } // 0x0197E76C-0x0197E774 
	
		// Constructors
		protected XPathDocumentBaseIterator() {} // Dummy constructor
		protected XPathDocumentBaseIterator(XPathDocumentNavigator ctxt) {} // 0x0197E620-0x0197E698
		protected XPathDocumentBaseIterator(XPathDocumentBaseIterator iter) {} // 0x0197E6D8-0x0197E764
	}

	internal class XPathDocumentElementChildIterator : XPathDocumentBaseIterator // TypeDefIndex: 2967
	{
		// Fields
		private string localName; // 0x28
		private string namespaceUri; // 0x30
	
		// Constructors
		public XPathDocumentElementChildIterator() {} // Dummy constructor
		public XPathDocumentElementChildIterator(XPathDocumentNavigator parent, string name, string namespaceURI) {} // 0x01981030-0x0198110C
		public XPathDocumentElementChildIterator(XPathDocumentElementChildIterator iter) {} // 0x0198110C-0x01981148
	
		// Methods
		public override XPathNodeIterator Clone() => default; // 0x01981148-0x019811A8
		public override bool MoveNext() => default; // 0x019811A8-0x01981214
	}

	internal class XPathDocumentKindChildIterator : XPathDocumentBaseIterator // TypeDefIndex: 2968
	{
		// Fields
		private XPathNodeType typ; // 0x24
	
		// Constructors
		public XPathDocumentKindChildIterator() {} // Dummy constructor
		public XPathDocumentKindChildIterator(XPathDocumentNavigator parent, XPathNodeType typ) {} // 0x01981548-0x01981570
		public XPathDocumentKindChildIterator(XPathDocumentKindChildIterator iter) {} // 0x01981570-0x019815A4
	
		// Methods
		public override XPathNodeIterator Clone() => default; // 0x019815A4-0x01981604
		public override bool MoveNext() => default; // 0x01981604-0x0198166C
	}

	internal class XPathDocumentElementDescendantIterator : XPathDocumentBaseIterator // TypeDefIndex: 2969
	{
		// Fields
		private XPathDocumentNavigator end; // 0x28
		private string localName; // 0x30
		private string namespaceUri; // 0x38
		private bool matchSelf; // 0x40
	
		// Constructors
		public XPathDocumentElementDescendantIterator() {} // Dummy constructor
		public XPathDocumentElementDescendantIterator(XPathDocumentNavigator root, string name, string namespaceURI, bool matchSelf) {} // 0x01981214-0x01981354
		public XPathDocumentElementDescendantIterator(XPathDocumentElementDescendantIterator iter) {} // 0x01981354-0x019813A0
	
		// Methods
		public override XPathNodeIterator Clone() => default; // 0x019813A0-0x01981400
		public override bool MoveNext() => default; // 0x01981400-0x01981488
	}

	internal class XPathDocumentKindDescendantIterator : XPathDocumentBaseIterator // TypeDefIndex: 2970
	{
		// Fields
		private XPathDocumentNavigator end; // 0x28
		private XPathNodeType typ; // 0x30
		private bool matchSelf; // 0x34
	
		// Constructors
		public XPathDocumentKindDescendantIterator() {} // Dummy constructor
		public XPathDocumentKindDescendantIterator(XPathDocumentNavigator root, XPathNodeType typ, bool matchSelf) {} // 0x0198166C-0x01981740
		public XPathDocumentKindDescendantIterator(XPathDocumentKindDescendantIterator iter) {} // 0x01981740-0x01981784
	
		// Methods
		public override XPathNodeIterator Clone() => default; // 0x01981784-0x019817E4
		public override bool MoveNext() => default; // 0x019817E4-0x0198186C
	}

	internal sealed class XPathDocumentNavigator : XPathNavigator, IXmlLineInfo // TypeDefIndex: 2971
	{
		// Fields
		private XPathNode[] pageCurrent; // 0x10
		private XPathNode[] pageParent; // 0x18
		private int idxCurrent; // 0x20
		private int idxParent; // 0x24
		private string atomizedLocalName; // 0x28
	
		// Properties
		public override string Value { get => default; } // 0x019819BC-0x01981BC8 
		public override XPathNodeType NodeType { get => default; } // 0x01981E54-0x01981EA4 
		public override string LocalName { get => default; } // 0x01981EA4-0x01981EEC 
		public override string NamespaceURI { get => default; } // 0x01981EEC-0x01981F50 
		public override string Name { get => default; } // 0x01981F50-0x01982010 
		public override string Prefix { get => default; } // 0x01982010-0x01982058 
		public override string BaseURI { get => default; } // 0x01982058-0x01982158 
		public override bool IsEmptyElement { get => default; } // 0x01982158-0x019821A8 
		public override XmlNameTable NameTable { get => default; } // 0x019821A8-0x01982214 
		public override bool HasAttributes { get => default; } // 0x0198234C-0x0198239C 
		public override bool HasChildren { get => default; } // 0x01982F2C-0x01982F70 
		internal override string UniqueId { get => default; } // 0x01984478-0x019846FC 
		public override object UnderlyingObject { get => default; } // 0x019846FC-0x0198470C 
		public int LineNumber { get => default; } // 0x0198475C-0x019847F4 
		public int LinePosition { get => default; } // 0x019847F4-0x019848D8 
	
		// Constructors
		public XPathDocumentNavigator() {} // Dummy constructor
		public XPathDocumentNavigator(XPathNode[] pageCurrent, int idxCurrent, XPathNode[] pageParent, int idxParent) {} // 0x01981928-0x019819BC
		public XPathDocumentNavigator(XPathDocumentNavigator nav) {} // 0x0197E698-0x0197E6D8
	
		// Methods
		public override XPathNavigator Clone() => default; // 0x01981DD0-0x01981E54
		public override bool MoveToFirstAttribute() => default; // 0x01982214-0x01982260
		public override bool MoveToNextAttribute() => default; // 0x019822B4-0x019822C4
		public override bool MoveToAttribute(string localName, string namespaceURI) => default; // 0x0198239C-0x01982458
		public override bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope) => default; // 0x019825AC-0x019826AC
		public override bool MoveToNextNamespace(XPathNamespaceScope scope) => default; // 0x01982870-0x01982984
		public override bool MoveToNext() => default; // 0x01982984-0x01982994
		public override bool MoveToPrevious() => default; // 0x01982A10-0x01982A30
		public override bool MoveToFirstChild() => default; // 0x01982B20-0x01982BD4
		public override bool MoveToParent() => default; // 0x01982CC4-0x01982CF0
		public override bool MoveTo(XPathNavigator other) => default; // 0x01982D54-0x01982DF4
		public override bool MoveToId(string id) => default; // 0x01982DF4-0x01982E70
		public override bool IsSamePosition(XPathNavigator other) => default; // 0x01982E70-0x01982F2C
		public override void MoveToRoot() {} // 0x01982F70-0x01983000
		public override bool MoveToChild(string localName, string namespaceURI) => default; // 0x01983000-0x01983080
		public override bool MoveToNext(string localName, string namespaceURI) => default; // 0x019831B0-0x01983230
		public override bool MoveToChild(XPathNodeType type) => default; // 0x0198330C-0x019833D0
		public override bool MoveToNext(XPathNodeType type) => default; // 0x01983538-0x01983550
		public override bool MoveToFollowing(string localName, string namespaceURI, XPathNavigator end) => default; // 0x01983680-0x019837C0
		public override bool MoveToFollowing(XPathNodeType type, XPathNavigator end) => default; // 0x01983B00-0x01983D78
		public override XPathNodeIterator SelectChildren(XPathNodeType type) => default; // 0x01983F0C-0x01983F7C
		public override XPathNodeIterator SelectChildren(string name, string namespaceURI) => default; // 0x01983F7C-0x01984020
		public override XPathNodeIterator SelectDescendants(XPathNodeType type, bool matchSelf) => default; // 0x01984020-0x01984098
		public override XPathNodeIterator SelectDescendants(string name, string namespaceURI, bool matchSelf) => default; // 0x01984098-0x01984154
		public override XmlNodeOrder ComparePosition(XPathNavigator other) => default; // 0x01984154-0x0198427C
		public override bool IsDescendant(XPathNavigator other) => default; // 0x01984320-0x01984434
		private int GetPrimaryLocation() => default; // 0x0198427C-0x0198429C
		private int GetSecondaryLocation() => default; // 0x0198429C-0x01984320
		public bool HasLineInfo() => default; // 0x0198470C-0x0198475C
		public int GetPositionHashCode() => default; // 0x019848D8-0x0198492C
		public bool IsElementMatch(string localName, string namespaceURI) => default; // 0x01981488-0x01981548
		public bool IsContentKindMatch(XPathNodeType typ) => default; // 0x0198492C-0x01984AF0
		public bool IsKindMatch(XPathNodeType typ) => default; // 0x0198186C-0x01981928
		private int GetFollowingEnd(XPathDocumentNavigator end, bool useParentOfVirtual, out XPathNode[] pageEnd) {
			pageEnd = default;
			return default;
		} // 0x019837C0-0x01983874
	}

	internal struct XPathNode // TypeDefIndex: 2972
	{
		// Fields
		private XPathNodeInfoAtom info; // 0x00
		private ushort idxSibling; // 0x08
		private ushort idxParent; // 0x0A
		private ushort idxSimilar; // 0x0C
		private ushort posOffset; // 0x0E
		private uint props; // 0x10
		private string value; // 0x18
		private const uint NodeTypeMask = 15; // Metadata: 0x003F28B6
		private const uint HasAttributeBit = 16; // Metadata: 0x003F28BA
		private const uint HasContentChildBit = 32; // Metadata: 0x003F28BE
		private const uint HasElementChildBit = 64; // Metadata: 0x003F28C2
		private const uint HasCollapsedTextBit = 128; // Metadata: 0x003F28C6
		private const uint AllowShortcutTagBit = 256; // Metadata: 0x003F28CA
		private const uint HasNmspDeclsBit = 512; // Metadata: 0x003F28CE
		private const uint LineNumberMask = 16776192; // Metadata: 0x003F28D2
		private const int LineNumberShift = 10; // Metadata: 0x003F28D6
		private const int CollapsedPositionShift = 24; // Metadata: 0x003F28DA
		public const int MaxLineNumberOffset = 16383; // Metadata: 0x003F28DE
		public const int MaxLinePositionOffset = 65535; // Metadata: 0x003F28E2
		public const int MaxCollapsedPositionOffset = 255; // Metadata: 0x003F28E6
	
		// Properties
		public XPathNodeType NodeType { get => default; } // 0x00AF164C-0x00AF1658 
		public string Prefix { get => default; } // 0x00AF1658-0x00AF1674 
		public string LocalName { get => default; } // 0x00AF1674-0x00AF1690 
		public string Name { get => default; } // 0x00AF1690-0x00AF1698 
		public string NamespaceUri { get => default; } // 0x00AF1698-0x00AF16B4 
		public XPathDocument Document { get => default; } // 0x00AF16B4-0x00AF16D0 
		public string BaseUri { get => default; } // 0x00AF16D0-0x00AF16EC 
		public int LineNumber { get => default; } // 0x00AF16EC-0x00AF1714 
		public int LinePosition { get => default; } // 0x00AF1714-0x00AF1738 
		public int CollapsedLinePosition { get => default; } // 0x00AF1738-0x00AF1764 
		public XPathNodePageInfo PageInfo { get => default; } // 0x00AF1764-0x00AF1780 
		public bool IsXmlNamespaceNode { get => default; } // 0x00AF1804-0x00AF180C 
		public bool HasSibling { get => default; } // 0x00AF180C-0x00AF181C 
		public bool HasCollapsedText { get => default; } // 0x00AF181C-0x00AF1828 
		public bool HasAttribute { get => default; } // 0x00AF1828-0x00AF1834 
		public bool HasContentChild { get => default; } // 0x00AF1834-0x00AF1840 
		public bool HasElementChild { get => default; } // 0x00AF1840-0x00AF184C 
		public bool IsAttrNmsp { get => default; } // 0x00AF184C-0x00AF1864 
		public bool IsText { get => default; } // 0x00AF1864-0x00AF186C 
		public bool HasNamespaceDecls { get => default; set {} } // 0x00AF186C-0x00AF1878 0x00AF1878-0x00AF1894
		public bool AllowShortcutTag { get => default; } // 0x00AF1894-0x00AF18A0 
		public int LocalNameHashCode { get => default; } // 0x00AF18A0-0x00AF18BC 
		public string Value { get => default; } // 0x00AF18BC-0x00AF18C4 
	
		// Methods
		public int GetRoot(out XPathNode[] pageNode) {
			pageNode = default;
			return default;
		} // 0x00AF1780-0x00AF1788
		public int GetParent(out XPathNode[] pageNode) {
			pageNode = default;
			return default;
		} // 0x00AF1788-0x00AF17AC
		public int GetSibling(out XPathNode[] pageNode) {
			pageNode = default;
			return default;
		} // 0x00AF17AC-0x00AF17D0
		public int GetSimilarElement(out XPathNode[] pageNode) {
			pageNode = default;
			return default;
		} // 0x00AF17D0-0x00AF17F4
		public bool NameMatch(string localName, string namespaceName) => default; // 0x00AF17F4-0x00AF17FC
		public bool ElementMatch(string localName, string namespaceName) => default; // 0x00AF17FC-0x00AF1804
		public void Create(XPathNodePageInfo pageInfo) {} // 0x00AF18C4-0x00AF18CC
		public void Create(XPathNodeInfoAtom info, XPathNodeType xptyp, int idxParent) {} // 0x00AF18CC-0x00AF18DC
		public void SetLineInfoOffsets(int lineNumOffset, int linePosOffset) {} // 0x00AF18DC-0x00AF18F0
		public void SetCollapsedLineInfoOffset(int posOffset) {} // 0x00AF18F0-0x00AF1900
		public void SetValue(string value) {} // 0x00AF1900-0x00AF1908
		public void SetEmptyValue(bool allowShortcutTag) {} // 0x00AF1908-0x00AF1914
		public void SetCollapsedValue(string value) {} // 0x00AF1914-0x00AF192C
		public void SetParentProperties(XPathNodeType xptyp) {} // 0x00AF192C-0x00AF1960
		public void SetSibling(XPathNodeInfoTable infoTable, XPathNode[] pageSibling, int idxSibling) {} // 0x00AF1960-0x00AF1968
		public void SetSimilarElement(XPathNodeInfoTable infoTable, XPathNode[] pageSimilar, int idxSimilar) {} // 0x00AF1968-0x00AF19AC
	}

	internal struct XPathNodeRef // TypeDefIndex: 2973
	{
		// Fields
		private XPathNode[] page; // 0x00
		private int idx; // 0x08
	
		// Properties
		public static XPathNodeRef Null { get => default; } // 0x01985838-0x01985874 
		public bool IsNull { get => default; } // 0x00AF19B8-0x00AF19C8 
		public XPathNode[] Page { get => default; } // 0x00AF19C8-0x00AF19D0 
		public int Index { get => default; } // 0x00AF19D0-0x00AF19D8 
	
		// Constructors
		public XPathNodeRef(XPathNode[] page, int idx) : this() {
			this.page = default;
			this.idx = default;
		} // 0x00AF19AC-0x00AF19B8
	
		// Methods
		public override int GetHashCode() => default; // 0x00AF19D8-0x00AF1A24
	}

	internal abstract class XPathNodeHelper // TypeDefIndex: 2974
	{
		// Constructors
		protected XPathNodeHelper() {} // 0x01984DDC-0x01984DE4
	
		// Methods
		public static int GetLocalNamespaces(XPathNode[] pageElem, int idxElem, out XPathNode[] pageNmsp) {
			pageNmsp = default;
			return default;
		} // 0x019826AC-0x0198271C
		public static int GetInScopeNamespaces(XPathNode[] pageElem, int idxElem, out XPathNode[] pageNmsp) {
			pageNmsp = default;
			return default;
		} // 0x0198271C-0x01982870
		public static bool GetFirstAttribute(ref XPathNode[] pageNode, ref int idxNode) => default; // 0x01982260-0x019822B4
		public static bool GetNextAttribute(ref XPathNode[] pageNode, ref int idxNode) => default; // 0x019822C4-0x0198234C
		public static bool GetContentChild(ref XPathNode[] pageNode, ref int idxNode) => default; // 0x01982BD4-0x01982CC4
		public static bool GetContentSibling(ref XPathNode[] pageNode, ref int idxNode) => default; // 0x01982994-0x01982A10
		public static bool GetParent(ref XPathNode[] pageNode, ref int idxNode) => default; // 0x01982CF0-0x01982D54
		public static int GetLocation(XPathNode[] pageNode, int idxNode) => default; // 0x01984434-0x01984478
		public static bool GetElementChild(ref XPathNode[] pageNode, ref int idxNode, string localName, string namespaceName) => default; // 0x01983080-0x019831B0
		public static bool GetElementSibling(ref XPathNode[] pageNode, ref int idxNode, string localName, string namespaceName) => default; // 0x01983230-0x0198330C
		public static bool GetContentChild(ref XPathNode[] pageNode, ref int idxNode, XPathNodeType typ) => default; // 0x019833D0-0x01983538
		public static bool GetContentSibling(ref XPathNode[] pageNode, ref int idxNode, XPathNodeType typ) => default; // 0x01983550-0x01983680
		public static bool GetPreviousContentSibling(ref XPathNode[] pageNode, ref int idxNode) => default; // 0x01982A30-0x01982B20
		public static bool GetPreviousElementSibling(ref XPathNode[] pageNode, ref int idxNode, string localName, string namespaceName) => default; // 0x01984B88-0x01984C64
		public static bool GetPreviousContentSibling(ref XPathNode[] pageNode, ref int idxNode, XPathNodeType typ) => default; // 0x01984C64-0x01984D68
		public static bool GetAttribute(ref XPathNode[] pageNode, ref int idxNode, string localName, string namespaceName) => default; // 0x01982458-0x019825AC
		public static bool GetFollowing(ref XPathNode[] pageNode, ref int idxNode) => default; // 0x01984D68-0x01984DDC
		public static bool GetElementFollowing(ref XPathNode[] pageCurrent, ref int idxCurrent, XPathNode[] pageEnd, int idxEnd, string localName, string namespaceName) => default; // 0x01983874-0x01983B00
		public static bool GetContentFollowing(ref XPathNode[] pageCurrent, ref int idxCurrent, XPathNode[] pageEnd, int idxEnd, XPathNodeType typ) => default; // 0x01983D78-0x01983F0C
		public static bool GetTextFollowing(ref XPathNode[] pageCurrent, ref int idxCurrent, XPathNode[] pageEnd, int idxEnd) => default; // 0x01981C64-0x01981DD0
		public static bool GetNonDescendant(ref XPathNode[] pageNode, ref int idxNode) => default; // 0x01981BC8-0x01981C64
		private static void GetChild(ref XPathNode[] pageNode, ref int idxNode) {} // 0x01984B24-0x01984B88
	}

	internal sealed class XPathNodePageInfo // TypeDefIndex: 2975
	{
		// Fields
		private int pageNum; // 0x10
		private int nodeCount; // 0x14
		private XPathNode[] pagePrev; // 0x18
		private XPathNode[] pageNext; // 0x20
	
		// Properties
		public int PageNumber { get => default; } // 0x01985808-0x01985810 
		public int NodeCount { get => default; set {} } // 0x01985810-0x01985818 0x01985818-0x01985820
		public XPathNode[] PreviousPage { get => default; } // 0x01985820-0x01985828 
		public XPathNode[] NextPage { get => default; set {} } // 0x01985828-0x01985830 0x01985830-0x01985838
	
		// Constructors
		public XPathNodePageInfo() {} // Dummy constructor
		public XPathNodePageInfo(XPathNode[] pagePrev, int pageNum) {} // 0x01980F60-0x01981030
	}

	internal sealed class XPathNodeInfoAtom // TypeDefIndex: 2976
	{
		// Fields
		private string localName; // 0x10
		private string namespaceUri; // 0x18
		private string prefix; // 0x20
		private string baseUri; // 0x28
		private XPathNode[] pageParent; // 0x30
		private XPathNode[] pageSibling; // 0x38
		private XPathNode[] pageSimilar; // 0x40
		private XPathDocument doc; // 0x48
		private int lineNumBase; // 0x50
		private int linePosBase; // 0x54
		private int hashCode; // 0x58
		private int localNameHash; // 0x5C
		private XPathNodeInfoAtom next; // 0x60
		private XPathNodePageInfo pageInfo; // 0x68
	
		// Properties
		public XPathNodePageInfo PageInfo { get => default; } // 0x01984F18-0x01984F20 
		public string LocalName { get => default; } // 0x01984F20-0x01984F28 
		public string NamespaceUri { get => default; } // 0x01984F28-0x01984F30 
		public string Prefix { get => default; } // 0x01984F30-0x01984F38 
		public string BaseUri { get => default; } // 0x01984F38-0x01984F40 
		public XPathNode[] SiblingPage { get => default; } // 0x01984F40-0x01984F48 
		public XPathNode[] SimilarElementPage { get => default; } // 0x01984F48-0x01984F50 
		public XPathNode[] ParentPage { get => default; } // 0x01984F50-0x01984F58 
		public XPathDocument Document { get => default; } // 0x01984F58-0x01984F60 
		public int LineNumberBase { get => default; } // 0x01984F60-0x01984F68 
		public int LinePositionBase { get => default; } // 0x01984F68-0x01984F70 
		public int LocalNameHashCode { get => default; } // 0x01984F70-0x01984F78 
		public XPathNodeInfoAtom Next { get => default; set {} } // 0x01984F78-0x01984F80 0x01984F80-0x01984F88
	
		// Constructors
		public XPathNodeInfoAtom() {} // Dummy constructor
		public XPathNodeInfoAtom(XPathNodePageInfo pageInfo) {} // 0x01984AF0-0x01984B24
		public XPathNodeInfoAtom(string localName, string namespaceUri, string prefix, string baseUri, XPathNode[] pageParent, XPathNode[] pageSibling, XPathNode[] pageSimilar, XPathDocument doc, int lineNumBase, int linePosBase) {} // 0x01984DE4-0x01984E84
	
		// Methods
		public void Init(string localName, string namespaceUri, string prefix, string baseUri, XPathNode[] pageParent, XPathNode[] pageSibling, XPathNode[] pageSimilar, XPathDocument doc, int lineNumBase, int linePosBase) {} // 0x01984E84-0x01984F18
		public override int GetHashCode() => default; // 0x01984F88-0x01985048
		public override bool Equals(object other) => default; // 0x01985048-0x01985180
		public override string ToString() => default; // 0x01985180-0x01985460
	}

	internal sealed class XPathNodeInfoTable // TypeDefIndex: 2977
	{
		// Fields
		private XPathNodeInfoAtom[] hashTable; // 0x10
		private int sizeTable; // 0x18
		private XPathNodeInfoAtom infoCached; // 0x20
		private const int DefaultTableSize = 32; // Metadata: 0x003F28EA
	
		// Constructors
		public XPathNodeInfoTable() {} // 0x0197EB10-0x0197EB78
	
		// Methods
		public XPathNodeInfoAtom Create(string localName, string namespaceUri, string prefix, string baseUri, XPathNode[] pageParent, XPathNode[] pageSibling, XPathNode[] pageSimilar, XPathDocument doc, int lineNumBase, int linePosBase) => default; // 0x01980D98-0x01980F60
		private XPathNodeInfoAtom Atomize(XPathNodeInfoAtom info) => default; // 0x01985460-0x019855CC
		private void AddInfo(XPathNodeInfoAtom info) {} // 0x019855CC-0x01985688
		public override string ToString() => default; // 0x01985688-0x01985808
	}
}

internal static class AssemblyRef // TypeDefIndex: 4271
{
	// Fields
	internal const string SystemConfiguration = "System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x0040F7B1
	internal const string System = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x0040F80C
	public const string EcmaPublicKey = "b77a5c561934e089"; // Metadata: 0x0040F859
	public const string FrameworkPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9"; // Metadata: 0x0040F86D
	public const string FrameworkPublicKeyFull2 = "00240000048000009400000006020000002400005253413100040000010001008D56C76F9E8649383049F383C44BE0EC204181822A6C31CF5EB7EF486944D032188EA1D3920763712CCB12D75FB77E9811149E6148E5D32FBAAB37611C1878DDC19E20EF135D0CB2CFF2BFEC3D115810C3D9069638FE4BE215DBF795861920E5AB6F7DB2E2CEEF136AC23D5DD2BF031700AEC232F6C6B1C785B4305C123B37AB"; // Metadata: 0x0040F9B1
	public const string MicrosoftPublicKey = "b03f5f7f11d50a3a"; // Metadata: 0x0040FAF5
	public const string MicrosoftJScript = "Microsoft.JScript, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x0040FB09
	public const string MicrosoftVSDesigner = "Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x0040FB61
	public const string SystemData = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x0040FBBC
	public const string SystemDesign = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x0040FC0E
	public const string SystemDrawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x0040FC62
	public const string SystemWeb = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x0040FCB7
	public const string SystemWebExtensions = "System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x0040FD08
	public const string SystemWindowsForms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x0040FD64
}

internal static class Consts // TypeDefIndex: 4272
{
	// Fields
	public const string MonoVersion = "5.11.0.0"; // Metadata: 0x0040FDBF
	public const string MonoCompany = "Mono development team"; // Metadata: 0x0040FDCB
	public const string MonoProduct = "Mono Common Language Infrastructure"; // Metadata: 0x0040FDE4
	public const string MonoCopyright = "(c) Various Mono authors"; // Metadata: 0x0040FE0B
	public const int MonoCorlibVersion = 1051100001; // Metadata: 0x0040FE27
	public const string FxVersion = "4.0.0.0"; // Metadata: 0x0040FE2B
	public const string FxFileVersion = "4.0.30319.17020"; // Metadata: 0x0040FE36
	public const string EnvironmentVersion = "4.0.30319.17020"; // Metadata: 0x0040FE49
	public const string VsVersion = "0.0.0.0"; // Metadata: 0x0040FE5C
	public const string VsFileVersion = "11.0.0.0"; // Metadata: 0x0040FE67
	private const string PublicKeyToken = "b77a5c561934e089"; // Metadata: 0x0040FE73
	public const string AssemblyI18N = "I18N, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x0040FE87
	public const string AssemblyMicrosoft_JScript = "Microsoft.JScript, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x0040FED2
	public const string AssemblyMicrosoft_VisualStudio = "Microsoft.VisualStudio, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x0040FF2A
	public const string AssemblyMicrosoft_VisualStudio_Web = "Microsoft.VisualStudio.Web, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x0040FF87
	public const string AssemblyMicrosoft_VSDesigner = "Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x0040FFE8
	public const string AssemblyMono_Http = "Mono.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x00410043
	public const string AssemblyMono_Posix = "Mono.Posix, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x00410093
	public const string AssemblyMono_Security = "Mono.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x004100E4
	public const string AssemblyMono_Messaging_RabbitMQ = "Mono.Messaging.RabbitMQ, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"; // Metadata: 0x00410138
	public const string AssemblyCorlib = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x00410196
	public const string AssemblySystem = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x004101E5
	public const string AssemblySystem_Data = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x00410232
	public const string AssemblySystem_Design = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x00410284
	public const string AssemblySystem_DirectoryServices = "System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x004102D8
	public const string AssemblySystem_Drawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x00410337
	public const string AssemblySystem_Drawing_Design = "System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x0041038C
	public const string AssemblySystem_Messaging = "System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x004103E8
	public const string AssemblySystem_Security = "System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x0041043F
	public const string AssemblySystem_ServiceProcess = "System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x00410495
	public const string AssemblySystem_Web = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"; // Metadata: 0x004104F1
	public const string AssemblySystem_Windows_Forms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x00410542
	public const string AssemblySystem_2_0 = "System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x0041059D
	public const string AssemblySystemCore_3_5 = "System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x004105EA
	public const string AssemblySystem_Core = "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x0041063C
	public const string WindowsBase_3_0 = "WindowsBase, Version=3.0.0.0, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x0041068E
	public const string AssemblyWindowsBase = "WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x004106CF
	public const string AssemblyPresentationCore_3_5 = "PresentationCore, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x00410721
	public const string AssemblyPresentationCore_4_0 = "PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x00410778
	public const string AssemblyPresentationFramework_3_5 = "PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; // Metadata: 0x004107CF
	public const string AssemblySystemServiceModel_3_0 = "System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"; // Metadata: 0x0041082B
}

internal sealed class Locale // TypeDefIndex: 4273
{
	// Constructors
	private Locale() {} // 0x019BC3E8-0x019BC3F0

	// Methods
	public static string GetText(string msg) => default; // 0x019BC3F0-0x019BC3F4
	public static string GetText(string fmt, params /* 0x00A35B58-0x00A35B68 */ object[] args) => default; // 0x019BC3F4-0x019BC3FC
}

internal static class SR // TypeDefIndex: 4521
{
	// Fields
	public const string RTL = "RTL_False"; // Metadata: 0x0041287C
	public const string ContinueButtonText = "Continue"; // Metadata: 0x00412889
	public const string DebugMessageTruncated = "{0}...\n<truncated>"; // Metadata: 0x00412895
	public const string DebugAssertTitleShort = "Assertion Failed"; // Metadata: 0x004128AB
	public const string DebugAssertTitle = "Assertion Failed: Cancel=Debug, OK=Continue"; // Metadata: 0x004128BF
	public const string NotSupported = "This operation is not supported."; // Metadata: 0x004128EE
	public const string DebugLaunchFailed = "Cannot launch the debugger.  Make sure that a Microsoft (R) .NET Framework debugger is properly installed."; // Metadata: 0x00412912
	public const string DebugLaunchFailedTitle = "Microsoft .NET Framework Debug Launch Failure"; // Metadata: 0x00412980
	public const string ObjectDisposed = "Object {0} has been disposed and can no longer be used."; // Metadata: 0x004129B1
	public const string ExceptionOccurred = "An exception occurred writing trace output to log file \'{0}\'. {1}"; // Metadata: 0x004129EC
	public const string MustAddListener = "Only TraceListeners can be added to a TraceListenerCollection."; // Metadata: 0x00412A31
	public const string ToStringNull = "(null)"; // Metadata: 0x00412A73
	public const string EnumConverterInvalidValue = "The value \'{0}\' is not a valid value for the enum \'{1}\'."; // Metadata: 0x00412A7D
	public const string ConvertFromException = "{0} cannot convert from {1}."; // Metadata: 0x00412AB9
	public const string ConvertToException = "\'{0}\' is unable to convert \'{1}\' to \'{2}\'."; // Metadata: 0x00412AD9
	public const string ConvertInvalidPrimitive = "{0} is not a valid value for {1}."; // Metadata: 0x00412B07
	public const string ErrorMissingPropertyAccessors = "Accessor methods for the {0} property are missing."; // Metadata: 0x00412B2C
	public const string ErrorInvalidPropertyType = "Invalid type for the {0} property."; // Metadata: 0x00412B62
	public const string ErrorMissingEventAccessors = "Accessor methods for the {0} event are missing."; // Metadata: 0x00412B88
	public const string ErrorInvalidEventHandler = "Invalid event handler for the {0} event."; // Metadata: 0x00412BBB
	public const string ErrorInvalidEventType = "Invalid type for the {0} event."; // Metadata: 0x00412BE7
	public const string InvalidMemberName = "Invalid member name."; // Metadata: 0x00412C0A
	public const string ErrorBadExtenderType = "The {0} extender provider is not compatible with the {1} type."; // Metadata: 0x00412C22
	public const string NullableConverterBadCtorArg = "The specified type is not a nullable type."; // Metadata: 0x00412C64
	public const string TypeDescriptorExpectedElementType = "Expected types in the collection to be of type {0}."; // Metadata: 0x00412C92
	public const string TypeDescriptorSameAssociation = "Cannot create an association when the primary and secondary objects are the same."; // Metadata: 0x00412CC9
	public const string TypeDescriptorAlreadyAssociated = "The primary and secondary objects are already associated with each other."; // Metadata: 0x00412D1E
	public const string TypeDescriptorProviderError = "The type description provider {0} has returned null from {1} which is illegal."; // Metadata: 0x00412D6B
	public const string TypeDescriptorUnsupportedRemoteObject = "The object {0} is being remoted by a proxy that does not support interface discovery.  This type of remoted object is not supported."; // Metadata: 0x00412DBD
	public const string TypeDescriptorArgsCountMismatch = "The number of elements in the Type and Object arrays must match."; // Metadata: 0x00412E45
	public const string ErrorCreateSystemEvents = "Failed to create system events window thread."; // Metadata: 0x00412E89
	public const string ErrorCreateTimer = "Cannot create timer."; // Metadata: 0x00412EBA
	public const string ErrorKillTimer = "Cannot end timer."; // Metadata: 0x00412ED2
	public const string ErrorSystemEventsNotSupported = "System event notifications are not supported under the current context. Server processes, for example, may not support global system event notifications."; // Metadata: 0x00412EE7
	public const string ErrorGetTempPath = "Cannot get temporary file name"; // Metadata: 0x00412F84
	public const string CHECKOUTCanceled = "The checkout was canceled by the user."; // Metadata: 0x00412FA6
	public const string ErrorInvalidServiceInstance = "The service instance must derive from or implement {0}."; // Metadata: 0x00412FD0
	public const string ErrorServiceExists = "The service {0} already exists in the service container."; // Metadata: 0x0041300B
	public const string Argument_InvalidNumberStyles = "An undefined NumberStyles value is being used."; // Metadata: 0x00413047
	public const string Argument_InvalidHexStyle = "With the AllowHexSpecifier bit set in the enum bit field, the only other valid bits that can be combined into the enum value must be a subset of those in HexNumber."; // Metadata: 0x00413079
	public const string Argument_ByteArrayLengthMustBeAMultipleOf4 = "The Byte[] length must be a multiple of 4."; // Metadata: 0x00413121
	public const string Argument_InvalidCharactersInString = "The string contained an invalid character."; // Metadata: 0x0041314F
	public const string Argument_ParsedStringWasInvalid = "The parsed string was invalid."; // Metadata: 0x0041317D
	public const string Argument_MustBeBigInt = "The parameter must be a BigInteger."; // Metadata: 0x0041319F
	public const string Format_InvalidFormatSpecifier = "Format specifier was invalid."; // Metadata: 0x004131C6
	public const string Format_TooLarge = "The value is too large to be represented by this format specifier."; // Metadata: 0x004131E7
	public const string ArgumentOutOfRange_MustBeLessThanUInt32MaxValue = "The value must be less than UInt32.MaxValue (2^32)."; // Metadata: 0x0041322D
	public const string ArgumentOutOfRange_MustBeNonNeg = "The number must be greater than or equal to zero."; // Metadata: 0x00413264
	public const string NotSupported_NumberStyle = "The NumberStyle option is not supported."; // Metadata: 0x00413299
	public const string Overflow_BigIntInfinity = "BigInteger cannot represent infinity."; // Metadata: 0x004132C5
	public const string Overflow_NotANumber = "The value is not a number."; // Metadata: 0x004132EE
	public const string Overflow_ParseBigInteger = "The value could not be parsed."; // Metadata: 0x0041330C
	public const string Overflow_Int32 = "Value was either too large or too small for an Int32."; // Metadata: 0x0041332E
	public const string Overflow_Int64 = "Value was either too large or too small for an Int64."; // Metadata: 0x00413367
	public const string Overflow_UInt32 = "Value was either too large or too small for a UInt32."; // Metadata: 0x004133A0
	public const string Overflow_UInt64 = "Value was either too large or too small for a UInt64."; // Metadata: 0x004133D9
	public const string Overflow_Decimal = "Value was either too large or too small for a Decimal."; // Metadata: 0x00413412
	public const string Argument_FrameworkNameTooShort = "FrameworkName cannot have less than two components or more than three components."; // Metadata: 0x0041344C
	public const string Argument_FrameworkNameInvalid = "FrameworkName is invalid."; // Metadata: 0x004134A1
	public const string Argument_FrameworkNameInvalidVersion = "FrameworkName version component is invalid."; // Metadata: 0x004134BE
	public const string Argument_FrameworkNameMissingVersion = "FrameworkName version component is missing."; // Metadata: 0x004134ED
	public const string ArgumentNull_Key = "Key cannot be null."; // Metadata: 0x0041351C
	public const string Argument_InvalidValue = "Argument {0} should be larger than {1}."; // Metadata: 0x00413533
	public const string Arg_MultiRank = "Multi dimension array is not supported on this operation."; // Metadata: 0x0041355E
	public const string Barrier_ctor_ArgumentOutOfRange = "The participantCount argument must be non-negative and less than or equal to 32767."; // Metadata: 0x0041359B
	public const string Barrier_AddParticipants_NonPositive_ArgumentOutOfRange = "The participantCount argument must be a positive value."; // Metadata: 0x004135F2
	public const string Barrier_AddParticipants_Overflow_ArgumentOutOfRange = "Adding participantCount participants would result in the number of participants exceeding the maximum number allowed."; // Metadata: 0x0041362D
	public const string Barrier_InvalidOperation_CalledFromPHA = "This method may not be called from within the postPhaseAction."; // Metadata: 0x004136A6
	public const string Barrier_RemoveParticipants_NonPositive_ArgumentOutOfRange = "The participantCount argument must be a positive value."; // Metadata: 0x004136E8
	public const string Barrier_RemoveParticipants_ArgumentOutOfRange = "The participantCount argument must be less than or equal the number of participants."; // Metadata: 0x00413723
	public const string Barrier_RemoveParticipants_InvalidOperation = "The participantCount argument is greater than the number of participants that haven\'t yet arrived at the barrier in this phase."; // Metadata: 0x0041377B
	public const string Barrier_SignalAndWait_ArgumentOutOfRange = "The specified timeout must represent a value between -1 and Int32.MaxValue, inclusive."; // Metadata: 0x004137FE
	public const string Barrier_SignalAndWait_InvalidOperation_ZeroTotal = "The barrier has no registered participants."; // Metadata: 0x00413858
	public const string Barrier_SignalAndWait_InvalidOperation_ThreadsExceeded = "The number of threads using the barrier exceeded the total number of registered participants."; // Metadata: 0x00413887
	public const string Barrier_Dispose = "The barrier has been disposed."; // Metadata: 0x004138E8
	public const string BarrierPostPhaseException = "The postPhaseAction failed with an exception."; // Metadata: 0x0041390A
	public const string UriTypeConverter_ConvertFrom_CannotConvert = "{0} cannot convert from {1}."; // Metadata: 0x0041393B
	public const string UriTypeConverter_ConvertTo_CannotConvert = "{0} cannot convert {1} to {2}."; // Metadata: 0x0041395B
	public const string ISupportInitializeDescr = "Specifies support for transacted initialization."; // Metadata: 0x0041397D
	public const string CantModifyListSortDescriptionCollection = "Once a ListSortDescriptionCollection has been created it can\'t be modified."; // Metadata: 0x004139B1
	public const string Argument_NullComment = "The \'Comment\' property of the CodeCommentStatement \'{0}\' cannot be null."; // Metadata: 0x00413A00
	public const string InvalidPrimitiveType = "Invalid Primitive Type: {0}. Consider using CodeObjectCreateExpression."; // Metadata: 0x00413A4C
	public const string Cannot_Specify_Both_Compiler_Path_And_Version = "Cannot specify both the \'{0}\' and \'{1}\' CodeDom provider options to choose a compiler. Please remove one of them."; // Metadata: 0x00413A97
	public const string CodeGenOutputWriter = "The output writer for code generation and the writer supplied don\'t match and cannot be used. This is generally caused by a bad implementation of a CodeGenerator derived class."; // Metadata: 0x00413B0C
	public const string CodeGenReentrance = "This code generation API cannot be called while the generator is being used to generate something else."; // Metadata: 0x00413BC0
	public const string InvalidLanguageIdentifier = "The identifier:\"{0}\" on the property:\"{1}\" of type:\"{2}\" is not a valid language-independent identifier name. Check to see if CodeGenerator.IsValidLanguageIndependentIdentifier allows the identifier name."; // Metadata: 0x00413C2B
	public const string InvalidTypeName = "The type name:\"{0}\" on the property:\"{1}\" of type:\"{2}\" is not a valid language-independent type name."; // Metadata: 0x00413CFB
	public const string Empty_attribute = "The \'{0}\' attribute cannot be an empty string."; // Metadata: 0x00413D65
	public const string Invalid_nonnegative_integer_attribute = "The \'{0}\' attribute must be a non-negative integer."; // Metadata: 0x00413D97
	public const string CodeDomProvider_NotDefined = "There is no CodeDom provider defined for the language."; // Metadata: 0x00413DCE
	public const string Language_Names_Cannot_Be_Empty = "You need to specify a non-empty String for a language name in the CodeDom configuration section."; // Metadata: 0x00413E08
	public const string Extension_Names_Cannot_Be_Empty_Or_Non_Period_Based = "An extension name in the CodeDom configuration section must be a non-empty string which starts with a period."; // Metadata: 0x00413E6C
	public const string Unable_To_Locate_Type = "The CodeDom provider type \"{0}\" could not be located."; // Metadata: 0x00413EDD
	public const string NotSupported_CodeDomAPI = "This CodeDomProvider does not support this method."; // Metadata: 0x00413F16
	public const string ArityDoesntMatch = "The total arity specified in \'{0}\' does not match the number of TypeArguments supplied.  There were \'{1}\' TypeArguments supplied."; // Metadata: 0x00413F4C
	public const string PartialTrustErrorTextReplacement = "<The original value of this property potentially contains file system information and has been suppressed.>"; // Metadata: 0x00413FD1
	public const string PartialTrustIllegalProvider = "When used in partial trust, langID must be C#, VB, J#, or JScript, and the language provider must be in the global assembly cache."; // Metadata: 0x00414040
	public const string IllegalAssemblyReference = "Assembly references cannot begin with \'-\', or contain a \'/\' or \'\\\'."; // Metadata: 0x004140C6
	public const string NullOrEmpty_Value_in_Property = "The \'{0}\' property cannot contain null or empty strings."; // Metadata: 0x0041410D
	public const string AutoGen_Comment_Line1 = "auto-generated>"; // Metadata: 0x00414149
	public const string AutoGen_Comment_Line2 = "This code was generated by a tool."; // Metadata: 0x0041415C
	public const string AutoGen_Comment_Line3 = "Runtime Version:"; // Metadata: 0x00414182
	public const string AutoGen_Comment_Line4 = "Changes to this file may cause incorrect behavior and will be lost if"; // Metadata: 0x00414196
	public const string AutoGen_Comment_Line5 = "the code is regenerated."; // Metadata: 0x004141DF
	public const string CantContainNullEntries = "Array \'{0}\' cannot contain null entries."; // Metadata: 0x004141FB
	public const string InvalidPathCharsInChecksum = "The CodeChecksumPragma file name \'{0}\' contains invalid path characters."; // Metadata: 0x00414227
	public const string InvalidRegion = "The region directive \'{0}\' contains invalid characters.  RegionText cannot contain any new line characters."; // Metadata: 0x00414273
	public const string Provider_does_not_support_options = "This CodeDomProvider type does not have a constructor that takes providerOptions - \"{0}\""; // Metadata: 0x004142E2
	public const string MetaExtenderName = "{0} on {1}"; // Metadata: 0x0041433E
	public const string InvalidEnumArgument = "The value of argument \'{0}\' ({1}) is invalid for Enum type \'{2}\'."; // Metadata: 0x0041434C
	public const string InvalidArgument = "\'{1}\' is not a valid value for \'{0}\'."; // Metadata: 0x00414391
	public const string InvalidNullArgument = "Null is not a valid value for {0}."; // Metadata: 0x004143BA
	public const string LicExceptionTypeOnly = "A valid license cannot be granted for the type {0}. Contact the manufacturer of the component for more information."; // Metadata: 0x004143E0
	public const string LicExceptionTypeAndInstance = "An instance of type \'{1}\' was being created, and a valid license could not be granted for the type \'{0}\'. Please,  contact the manufacturer of the component for more information."; // Metadata: 0x00414457
	public const string LicMgrContextCannotBeChanged = "The CurrentContext property of the LicenseManager is currently locked and cannot be changed."; // Metadata: 0x0041450D
	public const string LicMgrAlreadyLocked = "The CurrentContext property of the LicenseManager is already locked by another user."; // Metadata: 0x0041456D
	public const string LicMgrDifferentUser = "The CurrentContext property of the LicenseManager can only be unlocked with the same contextUser."; // Metadata: 0x004145C5
	public const string InvalidElementType = "Element type {0} is not supported."; // Metadata: 0x0041462A
	public const string InvalidIdentifier = "Identifier \'{0}\' is not valid."; // Metadata: 0x00414650
	public const string ExecFailedToCreate = "Failed to create file {0}."; // Metadata: 0x00414672
	public const string ExecTimeout = "Timed out waiting for a program to execute. The command being executed was {0}."; // Metadata: 0x00414690
	public const string ExecBadreturn = "An invalid return code was encountered waiting for a program to execute. The command being executed was {0}."; // Metadata: 0x004146E3
	public const string ExecCantGetRetCode = "Unable to get the return code for a program being executed. The command that was being executed was \'{0}\'."; // Metadata: 0x00414753
	public const string ExecCantExec = "Cannot execute a program. The command being executed was {0}."; // Metadata: 0x004147C1
	public const string ExecCantRevert = "Cannot execute a program. Impersonation failed."; // Metadata: 0x00414802
	public const string CompilerNotFound = "Compiler executable file {0} cannot be found."; // Metadata: 0x00414835
	public const string DuplicateFileName = "The file name \'{0}\' was already in the collection."; // Metadata: 0x00414866
	public const string CollectionReadOnly = "Collection is read-only."; // Metadata: 0x0041489C
	public const string BitVectorFull = "Bit vector is full."; // Metadata: 0x004148B8
	public const string ArrayConverterText = "{0} Array"; // Metadata: 0x004148CF
	public const string CollectionConverterText = "(Collection)"; // Metadata: 0x004148DC
	public const string MultilineStringConverterText = "(Text)"; // Metadata: 0x004148EC
	public const string CultureInfoConverterDefaultCultureString = "(Default)"; // Metadata: 0x004148F6
	public const string CultureInfoConverterInvalidCulture = "The {0} culture cannot be converted to a CultureInfo object on this computer."; // Metadata: 0x00414903
	public const string InvalidPrimitive = "The text {0} is not a valid {1}."; // Metadata: 0x00414954
	public const string TimerInvalidInterval = "\'{0}\' is not a valid value for \'Interval\'. \'Interval\' must be greater than {1}."; // Metadata: 0x00414978
	public const string TraceSwitchLevelTooHigh = "Attempted to set {0} to a value that is too high.  Setting level to TraceLevel.Verbose"; // Metadata: 0x004149CB
	public const string TraceSwitchLevelTooLow = "Attempted to set {0} to a value that is too low.  Setting level to TraceLevel.Off"; // Metadata: 0x00414A25
	public const string TraceSwitchInvalidLevel = "The Level must be set to a value in the enumeration TraceLevel."; // Metadata: 0x00414A7A
	public const string TraceListenerIndentSize = "The IndentSize property must be non-negative."; // Metadata: 0x00414ABD
	public const string TraceListenerFail = "Fail:"; // Metadata: 0x00414AEE
	public const string TraceAsTraceSource = "Trace"; // Metadata: 0x00414AF7
	public const string InvalidLowBoundArgument = "\'{1}\' is not a valid value for \'{0}\'. \'{0}\' must be greater than {2}."; // Metadata: 0x00414B00
	public const string DuplicateComponentName = "Duplicate component name \'{0}\'.  Component names must be unique and case-insensitive."; // Metadata: 0x00414B49
	public const string NotImplemented = "{0}: Not implemented"; // Metadata: 0x00414BA2
	public const string OutOfMemory = "Could not allocate needed memory."; // Metadata: 0x00414BBA
	public const string EOF = "End of data stream encountered."; // Metadata: 0x00414BDF
	public const string IOError = "Unknown input/output failure."; // Metadata: 0x00414C02
	public const string BadChar = "Unexpected Character: \'{0}\'."; // Metadata: 0x00414C23
	public const string toStringNone = "(none)"; // Metadata: 0x00414C43
	public const string toStringUnknown = "(unknown)"; // Metadata: 0x00414C4D
	public const string InvalidEnum = "{0} is not a valid {1} value."; // Metadata: 0x00414C5A
	public const string IndexOutOfRange = "Index {0} is out of range."; // Metadata: 0x00414C7B
	public const string ErrorPropertyAccessorException = "Property accessor \'{0}\' on object \'{1}\' threw the following exception:\'{2}\'"; // Metadata: 0x00414C99
	public const string InvalidOperation = "Invalid operation."; // Metadata: 0x00414CE8
	public const string EmptyStack = "Stack has no items in it."; // Metadata: 0x00414CFE
	public const string PerformanceCounterDesc = "Represents a Windows performance counter component."; // Metadata: 0x00414D1B
	public const string PCCategoryName = "Category name of the performance counter object."; // Metadata: 0x00414D52
	public const string PCCounterName = "Counter name of the performance counter object."; // Metadata: 0x00414D86
	public const string PCInstanceName = "Instance name of the performance counter object."; // Metadata: 0x00414DB9
	public const string PCMachineName = "Specifies the machine from where to read the performance data."; // Metadata: 0x00414DED
	public const string PCInstanceLifetime = "Specifies the lifetime of the instance."; // Metadata: 0x00414E2F
	public const string PropertyCategoryAction = "Action"; // Metadata: 0x00414E5A
	public const string PropertyCategoryAppearance = "Appearance"; // Metadata: 0x00414E64
	public const string PropertyCategoryAsynchronous = "Asynchronous"; // Metadata: 0x00414E72
	public const string PropertyCategoryBehavior = "Behavior"; // Metadata: 0x00414E82
	public const string PropertyCategoryData = "Data"; // Metadata: 0x00414E8E
	public const string PropertyCategoryDDE = "DDE"; // Metadata: 0x00414E96
	public const string PropertyCategoryDesign = "Design"; // Metadata: 0x00414E9D
	public const string PropertyCategoryDragDrop = "Drag Drop"; // Metadata: 0x00414EA7
	public const string PropertyCategoryFocus = "Focus"; // Metadata: 0x00414EB4
	public const string PropertyCategoryFont = "Font"; // Metadata: 0x00414EBD
	public const string PropertyCategoryFormat = "Format"; // Metadata: 0x00414EC5
	public const string PropertyCategoryKey = "Key"; // Metadata: 0x00414ECF
	public const string PropertyCategoryList = "List"; // Metadata: 0x00414ED6
	public const string PropertyCategoryLayout = "Layout"; // Metadata: 0x00414EDE
	public const string PropertyCategoryDefault = "Misc"; // Metadata: 0x00414EE8
	public const string PropertyCategoryMouse = "Mouse"; // Metadata: 0x00414EF0
	public const string PropertyCategoryPosition = "Position"; // Metadata: 0x00414EF9
	public const string PropertyCategoryText = "Text"; // Metadata: 0x00414F05
	public const string PropertyCategoryScale = "Scale"; // Metadata: 0x00414F0D
	public const string PropertyCategoryWindowStyle = "Window Style"; // Metadata: 0x00414F16
	public const string PropertyCategoryConfig = "Configurations"; // Metadata: 0x00414F26
	public const string ArgumentNull_ArrayWithNullElements = "The array cannot contain null elements."; // Metadata: 0x00414F38
	public const string OnlyAllowedOnce = "This operation is only allowed once per object."; // Metadata: 0x00414F63
	public const string BeginIndexNotNegative = "Start index cannot be less than 0 or greater than input length."; // Metadata: 0x00414F96
	public const string LengthNotNegative = "Length cannot be less than 0 or exceed input length."; // Metadata: 0x00414FD9
	public const string UnimplementedState = "Unimplemented state."; // Metadata: 0x00415011
	public const string UnexpectedOpcode = "Unexpected opcode in regular expression generation: {0}."; // Metadata: 0x00415029
	public const string NoResultOnFailed = "Result cannot be called on a failed Match."; // Metadata: 0x00415065
	public const string UnterminatedBracket = "Unterminated [] set."; // Metadata: 0x00415093
	public const string TooManyParens = "Too many )\'s."; // Metadata: 0x004150AB
	public const string NestedQuantify = "Nested quantifier {0}."; // Metadata: 0x004150BC
	public const string QuantifyAfterNothing = "Quantifier {x,y} following nothing."; // Metadata: 0x004150D6
	public const string InternalError = "Internal error in ScanRegex."; // Metadata: 0x004150FD
	public const string IllegalRange = "Illegal {x,y} with x > y."; // Metadata: 0x0041511D
	public const string NotEnoughParens = "Not enough )\'s."; // Metadata: 0x0041513A
	public const string BadClassInCharRange = "Cannot include class \\{0} in character range."; // Metadata: 0x0041514D
	public const string ReversedCharRange = "[x-y] range in reverse order."; // Metadata: 0x0041517E
	public const string UndefinedReference = "(?({0}) ) reference to undefined group."; // Metadata: 0x0041519F
	public const string MalformedReference = "(?({0}) ) malformed."; // Metadata: 0x004151CA
	public const string UnrecognizedGrouping = "Unrecognized grouping construct."; // Metadata: 0x004151E2
	public const string UnterminatedComment = "Unterminated (?#...) comment."; // Metadata: 0x00415206
	public const string IllegalEndEscape = "Illegal \\ at end of pattern."; // Metadata: 0x00415227
	public const string MalformedNameRef = "Malformed \\k<...> named back reference."; // Metadata: 0x00415247
	public const string UndefinedBackref = "Reference to undefined group number {0}."; // Metadata: 0x00415272
	public const string UndefinedNameRef = "Reference to undefined group name {0}."; // Metadata: 0x0041529E
	public const string TooFewHex = "Insufficient hexadecimal digits."; // Metadata: 0x004152C8
	public const string MissingControl = "Missing control character."; // Metadata: 0x004152EC
	public const string UnrecognizedControl = "Unrecognized control character."; // Metadata: 0x0041530A
	public const string UnrecognizedEscape = "Unrecognized escape sequence \\{0}."; // Metadata: 0x0041532D
	public const string IllegalCondition = "Illegal conditional (?(...)) expression."; // Metadata: 0x00415353
	public const string TooManyAlternates = "Too many | in (?()|)."; // Metadata: 0x0041537F
	public const string MakeException = "parsing \"{0}\" - {1}"; // Metadata: 0x00415398
	public const string IncompleteSlashP = "Incomplete \\p{X} character escape."; // Metadata: 0x004153AF
	public const string MalformedSlashP = "Malformed \\p{X} character escape."; // Metadata: 0x004153D5
	public const string InvalidGroupName = "Invalid group name: Group names must begin with a word character."; // Metadata: 0x004153FA
	public const string CapnumNotZero = "Capture number cannot be zero."; // Metadata: 0x0041543F
	public const string AlternationCantCapture = "Alternation conditions do not capture and cannot be named."; // Metadata: 0x00415461
	public const string AlternationCantHaveComment = "Alternation conditions cannot be comments."; // Metadata: 0x0041549F
	public const string CaptureGroupOutOfRange = "Capture group numbers must be less than or equal to Int32.MaxValue."; // Metadata: 0x004154CD
	public const string SubtractionMustBeLast = "A subtraction must be the last element in a character class."; // Metadata: 0x00415514
	public const string UnknownProperty = "Unknown property \'{0}\'."; // Metadata: 0x00415554
	public const string ReplacementError = "Replacement pattern error."; // Metadata: 0x0041556F
	public const string CountTooSmall = "Count cannot be less than -1."; // Metadata: 0x0041558D
	public const string EnumNotStarted = "Enumeration has either not started or has already finished."; // Metadata: 0x004155AE
	public const string Arg_InvalidArrayType = "Target array type is not compatible with the type of items in the collection."; // Metadata: 0x004155ED
	public const string RegexMatchTimeoutException_Occurred = "The RegEx engine has timed out while trying to match a pattern to an input string. This can occur for many reasons, including very large inputs or excessive backtracking caused by nested quantifiers, back-references and other factors."; // Metadata: 0x0041563E
	public const string IllegalDefaultRegexMatchTimeoutInAppDomain = "AppDomain data \'{0}\' contains an invalid value or object for specifying a default matching timeout for System.Text.RegularExpressions.Regex."; // Metadata: 0x0041572C
	public const string FileObject_AlreadyOpen = "The file is already open.  Call Close before trying to open the FileObject again."; // Metadata: 0x004157BC
	public const string FileObject_Closed = "The FileObject is currently closed.  Try opening it."; // Metadata: 0x00415811
	public const string FileObject_NotWhileWriting = "File information cannot be queried while open for writing."; // Metadata: 0x00415849
	public const string FileObject_FileDoesNotExist = "File information cannot be queried if the file does not exist."; // Metadata: 0x00415887
	public const string FileObject_MustBeClosed = "This operation can only be done when the FileObject is closed."; // Metadata: 0x004158C9
	public const string FileObject_MustBeFileName = "You must specify a file name, not a relative or absolute path."; // Metadata: 0x0041590B
	public const string FileObject_InvalidInternalState = "FileObject\'s open mode wasn\'t set to a valid value.  This FileObject is corrupt."; // Metadata: 0x0041594D
	public const string FileObject_PathNotSet = "The path has not been set, or is an empty string.  Please ensure you specify some path."; // Metadata: 0x004159A1
	public const string FileObject_Reading = "The file is currently open for reading.  Close the file and reopen it before attempting this."; // Metadata: 0x004159FC
	public const string FileObject_Writing = "The file is currently open for writing.  Close the file and reopen it before attempting this."; // Metadata: 0x00415A5D
	public const string FileObject_InvalidEnumeration = "Enumerator is positioned before the first line or after the last line of the file."; // Metadata: 0x00415ABE
	public const string FileObject_NoReset = "Reset is not supported on a FileLineEnumerator."; // Metadata: 0x00415B14
	public const string DirectoryObject_MustBeDirName = "You must specify a directory name, not a relative or absolute path."; // Metadata: 0x00415B47
	public const string DirectoryObjectPathDescr = "The fully qualified, or relative path to the directory you wish to read from. E.g., \"c:\\temp\"."; // Metadata: 0x00415B8E
	public const string FileObjectDetectEncodingDescr = "Determines whether the file will be parsed to see if it has a byte order mark indicating its encoding.  If it does, this will be used rather than the current specified encoding."; // Metadata: 0x00415BF0
	public const string FileObjectEncodingDescr = "The encoding to use when reading the file. UTF-8 is the default."; // Metadata: 0x00415CA5
	public const string FileObjectPathDescr = "The fully qualified, or relative path to the file you wish to read from. E.g., \"myfile.txt\"."; // Metadata: 0x00415CE9
	public const string Arg_EnumIllegalVal = "Illegal enum value: {0}."; // Metadata: 0x00415D49
	public const string Arg_OutOfRange_NeedNonNegNum = "Non-negative number required."; // Metadata: 0x00415D65
	public const string Argument_InvalidPermissionState = "Invalid permission state."; // Metadata: 0x00415D86
	public const string Argument_InvalidOidValue = "The OID value was invalid."; // Metadata: 0x00415DA3
	public const string Argument_WrongType = "Operation on type \'{0}\' attempted with target of incorrect type."; // Metadata: 0x00415DC1
	public const string Arg_EmptyOrNullString = "String cannot be empty or null."; // Metadata: 0x00415E05
	public const string Arg_EmptyOrNullArray = "Array cannot be empty or null."; // Metadata: 0x00415E28
	public const string Argument_InvalidClassAttribute = "The value of \"class\" attribute is invalid."; // Metadata: 0x00415E4A
	public const string Argument_InvalidNameType = "The value of \"nameType\" is invalid."; // Metadata: 0x00415E78
	public const string InvalidOperation_DuplicateItemNotAllowed = "Duplicate items are not allowed in the collection."; // Metadata: 0x00415E9F
	public const string Cryptography_Asn_MismatchedOidInCollection = "The AsnEncodedData object does not have the same OID for the collection."; // Metadata: 0x00415ED5
	public const string Cryptography_Cms_Envelope_Empty_Content = "Cannot create CMS enveloped for empty content."; // Metadata: 0x00415F21
	public const string Cryptography_Cms_Invalid_Recipient_Info_Type = "The recipient info type {0} is not valid."; // Metadata: 0x00415F53
	public const string Cryptography_Cms_Invalid_Subject_Identifier_Type = "The subject identifier type {0} is not valid."; // Metadata: 0x00415F80
	public const string Cryptography_Cms_Invalid_Subject_Identifier_Type_Value_Mismatch = "The subject identifier type {0} does not match the value data type {1}."; // Metadata: 0x00415FB1
	public const string Cryptography_Cms_Key_Agree_Date_Not_Available = "The Date property is not available for none KID key agree recipient."; // Metadata: 0x00415FFC
	public const string Cryptography_Cms_Key_Agree_Other_Key_Attribute_Not_Available = "The OtherKeyAttribute property is not available for none KID key agree recipient."; // Metadata: 0x00416044
	public const string Cryptography_Cms_MessageNotSigned = "The CMS message is not signed."; // Metadata: 0x00416099
	public const string Cryptography_Cms_MessageNotSignedByNoSignature = "The CMS message is not signed by NoSignature."; // Metadata: 0x004160BB
	public const string Cryptography_Cms_MessageNotEncrypted = "The CMS message is not encrypted."; // Metadata: 0x004160EC
	public const string Cryptography_Cms_Not_Supported = "The Cryptographic Message Standard (CMS) is not supported on this platform."; // Metadata: 0x00416111
	public const string Cryptography_Cms_RecipientCertificateNotFound = "The recipient certificate is not specified."; // Metadata: 0x00416160
	public const string Cryptography_Cms_Sign_Empty_Content = "Cannot create CMS signature for empty content."; // Metadata: 0x0041618F
	public const string Cryptography_Cms_Sign_No_Signature_First_Signer = "CmsSigner has to be the first signer with NoSignature."; // Metadata: 0x004161C1
	public const string Cryptography_DpApi_InvalidMemoryLength = "The length of the data should be a multiple of 16 bytes."; // Metadata: 0x004161FB
	public const string Cryptography_InvalidHandle = "{0} is an invalid handle."; // Metadata: 0x00416237
	public const string Cryptography_InvalidContextHandle = "The chain context handle is invalid."; // Metadata: 0x00416254
	public const string Cryptography_InvalidStoreHandle = "The store handle is invalid."; // Metadata: 0x0041627C
	public const string Cryptography_Oid_InvalidValue = "The OID value is invalid."; // Metadata: 0x0041629C
	public const string Cryptography_Pkcs9_ExplicitAddNotAllowed = "The PKCS 9 attribute cannot be explicitly added to the collection."; // Metadata: 0x004162B9
	public const string Cryptography_Pkcs9_InvalidOid = "The OID does not represent a valid PKCS 9 attribute."; // Metadata: 0x004162FF
	public const string Cryptography_Pkcs9_MultipleSigningTimeNotAllowed = "Cannot add multiple PKCS 9 signing time attributes."; // Metadata: 0x00416337
	public const string Cryptography_Pkcs9_AttributeMismatch = "The parameter should be a PKCS 9 attribute."; // Metadata: 0x0041636E
	public const string Cryptography_X509_AddFailed = "Adding certificate with index \'{0}\' failed."; // Metadata: 0x0041639D
	public const string Cryptography_X509_BadEncoding = "Input data cannot be coded as a valid certificate."; // Metadata: 0x004163CC
	public const string Cryptography_X509_ExportFailed = "The certificate export operation failed."; // Metadata: 0x00416402
	public const string Cryptography_X509_ExtensionMismatch = "The parameter should be an X509Extension."; // Metadata: 0x0041642E
	public const string Cryptography_X509_InvalidFindType = "Invalid find type."; // Metadata: 0x0041645B
	public const string Cryptography_X509_InvalidFindValue = "Invalid find value."; // Metadata: 0x00416471
	public const string Cryptography_X509_InvalidEncodingFormat = "Invalid encoding format."; // Metadata: 0x00416488
	public const string Cryptography_X509_InvalidContentType = "Invalid content type."; // Metadata: 0x004164A4
	public const string Cryptography_X509_KeyMismatch = "The public key of the certificate does not match the value specified."; // Metadata: 0x004164BD
	public const string Cryptography_X509_RemoveFailed = "Removing certificate with index \'{0}\' failed."; // Metadata: 0x00416506
	public const string Cryptography_X509_StoreNotOpen = "The X509 certificate store has not been opened."; // Metadata: 0x00416537
	public const string Environment_NotInteractive = "The current session is not interactive."; // Metadata: 0x0041656A
	public const string NotSupported_InvalidKeyImpl = "Only asymmetric keys that implement ICspAsymmetricAlgorithm are supported."; // Metadata: 0x00416595
	public const string NotSupported_KeyAlgorithm = "The certificate key algorithm is not supported."; // Metadata: 0x004165E3
	public const string NotSupported_PlatformRequiresNT = "This operation is only supported on Windows 2000, Windows XP, and higher."; // Metadata: 0x00416616
	public const string NotSupported_UnreadableStream = "Stream does not support reading."; // Metadata: 0x00416663
	public const string Security_InvalidValue = "The {0} value was invalid."; // Metadata: 0x00416687
	public const string Unknown_Error = "Unknown error."; // Metadata: 0x004166A5
	public const string security_ServiceNameCollection_EmptyServiceName = "A service name must not be null or empty."; // Metadata: 0x004166B7
	public const string security_ExtendedProtectionPolicy_UseDifferentConstructorForNever = "To construct a policy with PolicyEnforcement.Never, the single-parameter constructor must be used."; // Metadata: 0x004166E4
	public const string security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection = "The ServiceNameCollection must contain at least one service name."; // Metadata: 0x0041674A
	public const string security_ExtendedProtection_NoOSSupport = "This operation requires OS support for extended protection."; // Metadata: 0x0041678F
	public const string net_nonClsCompliantException = "A non-CLS Compliant Exception (i.e. an object that does not derive from System.Exception) was thrown."; // Metadata: 0x004167CE
	public const string net_illegalConfigWith = "The \'{0}\' attribute cannot appear when \'{1}\' is present."; // Metadata: 0x00416837
	public const string net_illegalConfigWithout = "The \'{0}\' attribute can only appear when \'{1}\' is present."; // Metadata: 0x00416873
	public const string net_baddate = "The value of the date string in the header is invalid."; // Metadata: 0x004168B1
	public const string net_writestarted = "This property cannot be set after writing has started."; // Metadata: 0x004168EB
	public const string net_reqsubmitted = "This operation cannot be performed after the request has been submitted."; // Metadata: 0x00416925
	public const string net_ftp_no_http_cmd = "The requested FTP command is not supported when using HTTP proxy."; // Metadata: 0x00416971
	public const string net_ftp_invalid_method_name = "FTP Method names cannot be null or empty."; // Metadata: 0x004169B6
	public const string net_ftp_invalid_renameto = "The RenameTo filename cannot be null or empty."; // Metadata: 0x004169E3
	public const string net_ftp_no_defaultcreds = "Default credentials are not supported on an FTP request."; // Metadata: 0x00416A15
	public const string net_ftpnoresponse = "This type of FTP request does not return a response stream."; // Metadata: 0x00416A51
	public const string net_ftp_response_invalid_format = "The response string \'{0}\' has invalid format."; // Metadata: 0x00416A90
	public const string net_ftp_no_offsetforhttp = "Offsets are not supported when sending an FTP request over an HTTP proxy."; // Metadata: 0x00416AC1
	public const string net_ftp_invalid_uri = "The requested URI is invalid for this FTP command."; // Metadata: 0x00416B0E
	public const string net_ftp_invalid_status_response = "The status response ({0}) is not expected in response to \'{1}\' command."; // Metadata: 0x00416B44
	public const string net_ftp_server_failed_passive = "The server failed the passive mode request with status response ({0})."; // Metadata: 0x00416B8F
	public const string net_ftp_active_address_different = "The data connection was made from an address that is different than the address to which the FTP connection was made."; // Metadata: 0x00416BD9
	public const string net_ftp_proxy_does_not_support_ssl = "SSL cannot be enabled when using a proxy."; // Metadata: 0x00416C52
	public const string net_ftp_invalid_response_filename = "The server returned the filename ({0}) which is not valid."; // Metadata: 0x00416C7F
	public const string net_ftp_unsupported_method = "This method is not supported."; // Metadata: 0x00416CBD
	public const string net_resubmitcanceled = "An error occurred on an automatic resubmission of the request."; // Metadata: 0x00416CDE
	public const string net_redirect_perm = "WebPermission demand failed for redirect URI."; // Metadata: 0x00416D20
	public const string net_resubmitprotofailed = "Cannot handle redirect from HTTP/HTTPS protocols to other dissimilar ones."; // Metadata: 0x00416D51
	public const string net_needchunked = "TransferEncoding requires the SendChunked property to be set to true."; // Metadata: 0x00416D9F
	public const string net_connarg = "Keep-Alive and Close may not be set using this property."; // Metadata: 0x00416DE8
	public const string net_no100 = "100-Continue may not be set using this property."; // Metadata: 0x00416E24
	public const string net_fromto = "The From parameter cannot be less than To."; // Metadata: 0x00416E58
	public const string net_rangetoosmall = "The From or To parameter cannot be less than 0."; // Metadata: 0x00416E86
	public const string net_invalidversion = "This protocol version is not supported."; // Metadata: 0x00416EB9
	public const string net_toosmall = "The specified value must be greater than 0."; // Metadata: 0x00416EE4
	public const string net_toolong = "The size of {0} is too long. It cannot be longer than {1} characters."; // Metadata: 0x00416F13
	public const string net_connclosed = "The underlying connection was closed: {0}."; // Metadata: 0x00416F5C
	public const string net_servererror = "The remote server returned an error: {0}."; // Metadata: 0x00416F8A
	public const string net_nouploadonget = "Cannot send a content-body with this verb-type."; // Metadata: 0x00416FB7
	public const string net_mutualauthfailed = "The requirement for mutual authentication was not met by the remote server."; // Metadata: 0x00416FEA
	public const string net_invasync = "Cannot block a call on this socket while an earlier asynchronous call is in progress."; // Metadata: 0x00417039
	public const string net_inasync = "An asynchronous call is already in progress. It must be completed or canceled before you can call this method."; // Metadata: 0x00417092
	public const string net_mustbeuri = "The {0} parameter must represent a valid Uri (see inner exception)."; // Metadata: 0x00417104
	public const string net_format_shexp = "The shell expression \'{0}\' could not be parsed because it is formatted incorrectly."; // Metadata: 0x0041714B
	public const string net_cannot_load_proxy_helper = "Failed to load the proxy script runtime environment from the Microsoft.JScript assembly."; // Metadata: 0x004171A2
	public const string net_invalid_host = "The specified value is not a valid Host header string."; // Metadata: 0x004171FE
	public const string net_repcall = "Cannot re-call BeginGetRequestStream/BeginGetResponse while a previous call is still in progress."; // Metadata: 0x00417238
	public const string net_badmethod = "Cannot set null or blank methods on request."; // Metadata: 0x0041729D
	public const string net_io_timeout_use_ge_zero = "Timeout can be only be set to \'System.Threading.Timeout.Infinite\' or a value >= 0."; // Metadata: 0x004172CD
	public const string net_io_timeout_use_gt_zero = "Timeout can be only be set to \'System.Threading.Timeout.Infinite\' or a value > 0."; // Metadata: 0x00417323
	public const string net_io_no_0timeouts = "NetworkStream does not support a 0 millisecond timeout, use a value greater than zero for the timeout instead."; // Metadata: 0x00417378
	public const string net_requestaborted = "The request was aborted: {0}."; // Metadata: 0x004173EA
	public const string net_tooManyRedirections = "Too many automatic redirections were attempted."; // Metadata: 0x0041740B
	public const string net_authmodulenotregistered = "The supplied authentication module is not registered."; // Metadata: 0x0041743E
	public const string net_authschemenotregistered = "There is no registered module for this authentication scheme."; // Metadata: 0x00417477
	public const string net_proxyschemenotsupported = "The ServicePointManager does not support proxies with the {0} scheme."; // Metadata: 0x004174B8
	public const string net_maxsrvpoints = "The maximum number of service points was exceeded."; // Metadata: 0x00417501
	public const string net_unknown_prefix = "The URI prefix is not recognized."; // Metadata: 0x00417537
	public const string net_notconnected = "The operation is not allowed on non-connected sockets."; // Metadata: 0x0041755C
	public const string net_notstream = "The operation is not allowed on non-stream oriented sockets."; // Metadata: 0x00417596
	public const string net_timeout = "The operation has timed out."; // Metadata: 0x004175D6
	public const string net_nocontentlengthonget = "Content-Length or Chunked Encoding cannot be set for an operation that does not write data."; // Metadata: 0x004175F6
	public const string net_contentlengthmissing = "When performing a write operation with AllowWriteStreamBuffering set to false, you must either set ContentLength to a non-negative number or set SendChunked to true."; // Metadata: 0x00417655
	public const string net_nonhttpproxynotallowed = "The URI scheme for the supplied IWebProxy has the illegal value \'{0}\'. Only \'http\' is supported."; // Metadata: 0x004176FE
	public const string net_nottoken = "The supplied string is not a valid HTTP token."; // Metadata: 0x00417762
	public const string net_rangetype = "A different range specifier has already been added to this request."; // Metadata: 0x00417794
	public const string net_need_writebuffering = "This request requires buffering data to succeed."; // Metadata: 0x004177DB
	public const string net_securityprotocolnotsupported = "The requested security protocol is not supported."; // Metadata: 0x0041780F
	public const string net_nodefaultcreds = "Default credentials cannot be supplied for the {0} authentication scheme."; // Metadata: 0x00417844
	public const string net_stopped = "Not listening. You must call the Start() method before calling this method."; // Metadata: 0x00417891
	public const string net_udpconnected = "Cannot send packets to an arbitrary host while connected."; // Metadata: 0x004178E0
	public const string net_no_concurrent_io_allowed = "The stream does not support concurrent IO read or write operations."; // Metadata: 0x0041791D
	public const string net_needmorethreads = "There were not enough free threads in the ThreadPool to complete the operation."; // Metadata: 0x00417964
	public const string net_MethodNotSupportedException = "This method is not supported by this class."; // Metadata: 0x004179B7
	public const string net_PropertyNotSupportedException = "This property is not supported by this class."; // Metadata: 0x004179E6
	public const string net_ProtocolNotSupportedException = "The \'{0}\' protocol is not supported by this class."; // Metadata: 0x00417A17
	public const string net_SelectModeNotSupportedException = "The \'{0}\' select mode is not supported by this class."; // Metadata: 0x00417A4D
	public const string net_InvalidSocketHandle = "The socket handle is not valid."; // Metadata: 0x00417A86
	public const string net_InvalidAddressFamily = "The AddressFamily {0} is not valid for the {1} end point, use {2} instead."; // Metadata: 0x00417AA9
	public const string net_InvalidEndPointAddressFamily = "The supplied EndPoint of AddressFamily {0} is not valid for this Socket, use {1} instead."; // Metadata: 0x00417AF7
	public const string net_InvalidSocketAddressSize = "The supplied {0} is an invalid size for the {1} end point."; // Metadata: 0x00417B54
	public const string net_invalidAddressList = "None of the discovered or specified addresses match the socket address family."; // Metadata: 0x00417B92
	public const string net_invalidPingBufferSize = "The buffer length must not exceed 65500 bytes."; // Metadata: 0x00417BE4
	public const string net_cant_perform_during_shutdown = "This operation cannot be performed while the AppDomain is shutting down."; // Metadata: 0x00417C16
	public const string net_cant_create_environment = "Unable to create another web proxy script environment at this time."; // Metadata: 0x00417C62
	public const string net_completed_result = "This operation cannot be performed on a completed asynchronous result object."; // Metadata: 0x00417CA9
	public const string net_protocol_invalid_family = "\'{0}\' Client can only accept InterNetwork or InterNetworkV6 addresses."; // Metadata: 0x00417CFA
	public const string net_protocol_invalid_multicast_family = "Multicast family is not the same as the family of the \'{0}\' Client."; // Metadata: 0x00417D44
	public const string net_empty_osinstalltype = "The Registry value \'{0}\' was either empty or not a string type."; // Metadata: 0x00417D8B
	public const string net_unknown_osinstalltype = "Unknown Windows installation type \'{0}\'."; // Metadata: 0x00417DCE
	public const string net_cant_determine_osinstalltype = "Can\'t determine OS installation type: Can\'t read key \'{0}\'. Exception message: {1}"; // Metadata: 0x00417DFA
	public const string net_osinstalltype = "Current OS installation type is \'{0}\'."; // Metadata: 0x00417E50
	public const string net_entire_body_not_written = "You must write ContentLength bytes to the request stream before calling [Begin]GetResponse."; // Metadata: 0x00417E7A
	public const string net_must_provide_request_body = "You must provide a request body if you set ContentLength>0 or SendChunked==true.  Do this by calling [Begin]GetRequestStream before [Begin]GetResponse."; // Metadata: 0x00417ED9
	public const string net_sockets_zerolist = "The parameter {0} must contain one or more elements."; // Metadata: 0x00417F74
	public const string net_sockets_blocking = "The operation is not allowed on a non-blocking Socket."; // Metadata: 0x00417FAC
	public const string net_sockets_useblocking = "Use the Blocking property to change the status of the Socket."; // Metadata: 0x00417FE6
	public const string net_sockets_select = "The operation is not allowed on objects of type {0}. Use only objects of type {1}."; // Metadata: 0x00418027
	public const string net_sockets_toolarge_select = "The {0} list contains too many items; a maximum of {1} is allowed."; // Metadata: 0x0041807D
	public const string net_sockets_empty_select = "All lists are either null or empty."; // Metadata: 0x004180C3
	public const string net_sockets_mustbind = "You must call the Bind method before performing this operation."; // Metadata: 0x004180EA
	public const string net_sockets_mustlisten = "You must call the Listen method before performing this operation."; // Metadata: 0x0041812D
	public const string net_sockets_mustnotlisten = "You may not perform this operation after calling the Listen method."; // Metadata: 0x00418172
	public const string net_sockets_mustnotbebound = "The socket must not be bound or connected."; // Metadata: 0x004181B9
	public const string net_sockets_namedmustnotbebound = "{0}: The socket must not be bound or connected."; // Metadata: 0x004181E7
	public const string net_sockets_invalid_socketinformation = "The specified value for the socket information is invalid."; // Metadata: 0x0041821A
	public const string net_sockets_invalid_ipaddress_length = "The number of specified IP addresses has to be greater than 0."; // Metadata: 0x00418258
	public const string net_sockets_invalid_optionValue = "The specified value is not a valid \'{0}\'."; // Metadata: 0x0041829A
	public const string net_sockets_invalid_optionValue_all = "The specified value is not valid."; // Metadata: 0x004182C7
	public const string net_sockets_invalid_dnsendpoint = "The parameter {0} must not be of type DnsEndPoint."; // Metadata: 0x004182EC
	public const string net_sockets_disconnectedConnect = "Once the socket has been disconnected, you can only reconnect again asynchronously, and only to a different EndPoint.  BeginConnect must be called on a thread that won\'t exit until the operation has been completed."; // Metadata: 0x00418322
	public const string net_sockets_disconnectedAccept = "Once the socket has been disconnected, you can only accept again asynchronously.  BeginAccept must be called on a thread that won\'t exit until the operation has been completed."; // Metadata: 0x004183FC
	public const string net_tcplistener_mustbestopped = "The TcpListener must not be listening before performing this operation."; // Metadata: 0x004184B0
	public const string net_sockets_no_duplicate_async = "BeginConnect cannot be called while another asynchronous operation is in progress on the same Socket."; // Metadata: 0x004184FB
	public const string net_socketopinprogress = "An asynchronous socket operation is already in progress using this SocketAsyncEventArgs instance."; // Metadata: 0x00418564
	public const string net_buffercounttoosmall = "The Buffer space specified by the Count property is insufficient for the AcceptAsync method."; // Metadata: 0x004185C9
	public const string net_multibuffernotsupported = "Multiple buffers cannot be used with this method."; // Metadata: 0x00418629
	public const string net_ambiguousbuffers = "Buffer and BufferList properties cannot both be non-null."; // Metadata: 0x0041865E
	public const string net_sockets_ipv6only = "This operation is only valid for IPv6 Sockets."; // Metadata: 0x0041869B
	public const string net_perfcounter_initialized_success = "System.Net performance counters initialization completed successful."; // Metadata: 0x004186CD
	public const string net_perfcounter_initialized_error = "System.Net performance counters initialization completed with errors. See System.Net trace file for more information."; // Metadata: 0x00418715
	public const string net_perfcounter_nocategory = "Performance counter category \'{0}\' doesn\'t exist. No System.Net performance counter values available."; // Metadata: 0x0041878E
	public const string net_perfcounter_initialization_started = "System.Net performance counter initialization started."; // Metadata: 0x004187F7
	public const string net_perfcounter_cant_queue_workitem = "Can\'t queue counter initialization logic on a thread pool thread. System.Net performance counters will not be available."; // Metadata: 0x00418831
	public const string net_config_proxy = "Error creating the Web Proxy specified in the \'system.net/defaultProxy\' configuration section."; // Metadata: 0x004188AD
	public const string net_config_proxy_module_not_public = "The specified proxy module type is not public."; // Metadata: 0x0041890F
	public const string net_config_authenticationmodules = "Error creating the modules specified in the \'system.net/authenticationModules\' configuration section."; // Metadata: 0x00418941
	public const string net_config_webrequestmodules = "Error creating the modules specified in the \'system.net/webRequestModules\' configuration section."; // Metadata: 0x004189AA
	public const string net_config_requestcaching = "Error creating the Web Request caching policy specified in the \'system.net/requestCaching\' configuration section."; // Metadata: 0x00418A0F
	public const string net_config_section_permission = "Insufficient permissions for setting the configuration section \'{0}\'."; // Metadata: 0x00418A84
	public const string net_config_element_permission = "Insufficient permissions for setting the configuration element \'{0}\'."; // Metadata: 0x00418ACD
	public const string net_config_property_permission = "Insufficient permissions for setting the configuration property \'{0}\'."; // Metadata: 0x00418B16
	public const string net_WebResponseParseError_InvalidHeaderName = "Header name is invalid"; // Metadata: 0x00418B60
	public const string net_WebResponseParseError_InvalidContentLength = "\'Content-Length\' header value is invalid"; // Metadata: 0x00418B7A
	public const string net_WebResponseParseError_IncompleteHeaderLine = "Invalid header name"; // Metadata: 0x00418BA6
	public const string net_WebResponseParseError_CrLfError = "CR must be followed by LF"; // Metadata: 0x00418BBD
	public const string net_WebResponseParseError_InvalidChunkFormat = "Response chunk format is invalid"; // Metadata: 0x00418BDA
	public const string net_WebResponseParseError_UnexpectedServerResponse = "Unexpected server response received"; // Metadata: 0x00418BFE
	public const string net_webstatus_Success = "Status success"; // Metadata: 0x00418C25
	public const string net_webstatus_NameResolutionFailure = "The remote name could not be resolved"; // Metadata: 0x00418C37
	public const string net_webstatus_ConnectFailure = "Unable to connect to the remote server"; // Metadata: 0x00418C60
	public const string net_webstatus_ReceiveFailure = "An unexpected error occurred on a receive"; // Metadata: 0x00418C8A
	public const string net_webstatus_SendFailure = "An unexpected error occurred on a send"; // Metadata: 0x00418CB7
	public const string net_webstatus_PipelineFailure = "A pipeline failure occurred"; // Metadata: 0x00418CE1
	public const string net_webstatus_RequestCanceled = "The request was canceled"; // Metadata: 0x00418D00
	public const string net_webstatus_ConnectionClosed = "The connection was closed unexpectedly"; // Metadata: 0x00418D1C
	public const string net_webstatus_TrustFailure = "Could not establish trust relationship for the SSL/TLS secure channel"; // Metadata: 0x00418D46
	public const string net_webstatus_SecureChannelFailure = "Could not create SSL/TLS secure channel"; // Metadata: 0x00418D8F
	public const string net_webstatus_ServerProtocolViolation = "The server committed a protocol violation"; // Metadata: 0x00418DBA
	public const string net_webstatus_KeepAliveFailure = "A connection that was expected to be kept alive was closed by the server"; // Metadata: 0x00418DE7
	public const string net_webstatus_ProxyNameResolutionFailure = "The proxy name could not be resolved"; // Metadata: 0x00418E33
	public const string net_webstatus_MessageLengthLimitExceeded = "The message length limit was exceeded"; // Metadata: 0x00418E5B
	public const string net_webstatus_CacheEntryNotFound = "The request cache-only policy does not allow a network request and the response is not found in cache"; // Metadata: 0x00418E84
	public const string net_webstatus_RequestProhibitedByCachePolicy = "The request could not be satisfied using a cache-only policy"; // Metadata: 0x00418EED
	public const string net_webstatus_Timeout = "The operation has timed out"; // Metadata: 0x00418F2D
	public const string net_webstatus_RequestProhibitedByProxy = "The IWebProxy object associated with the request did not allow the request to proceed"; // Metadata: 0x00418F4C
	public const string net_InvalidStatusCode = "The server returned a status code outside the valid range of 100-599."; // Metadata: 0x00418FA5
	public const string net_ftpstatuscode_ServiceNotAvailable = "Service not available, closing control connection"; // Metadata: 0x00418FEE
	public const string net_ftpstatuscode_CantOpenData = "Can\'t open data connection"; // Metadata: 0x00419023
	public const string net_ftpstatuscode_ConnectionClosed = "Connection closed; transfer aborted"; // Metadata: 0x00419041
	public const string net_ftpstatuscode_ActionNotTakenFileUnavailableOrBusy = "File unavailable (e.g., file busy)"; // Metadata: 0x00419068
	public const string net_ftpstatuscode_ActionAbortedLocalProcessingError = "Local error in processing"; // Metadata: 0x0041908E
	public const string net_ftpstatuscode_ActionNotTakenInsufficentSpace = "Insufficient storage space in system"; // Metadata: 0x004190AB
	public const string net_ftpstatuscode_CommandSyntaxError = "Syntax error, command unrecognized"; // Metadata: 0x004190D3
	public const string net_ftpstatuscode_ArgumentSyntaxError = "Syntax error in parameters or arguments"; // Metadata: 0x004190F9
	public const string net_ftpstatuscode_CommandNotImplemented = "Command not implemented"; // Metadata: 0x00419124
	public const string net_ftpstatuscode_BadCommandSequence = "Bad sequence of commands"; // Metadata: 0x0041913F
	public const string net_ftpstatuscode_NotLoggedIn = "Not logged in"; // Metadata: 0x0041915B
	public const string net_ftpstatuscode_AccountNeeded = "Need account for storing files"; // Metadata: 0x0041916C
	public const string net_ftpstatuscode_ActionNotTakenFileUnavailable = "File unavailable (e.g., file not found, no access)"; // Metadata: 0x0041918E
	public const string net_ftpstatuscode_ActionAbortedUnknownPageType = "Page type unknown"; // Metadata: 0x004191C4
	public const string net_ftpstatuscode_FileActionAborted = "Exceeded storage allocation (for current directory or data set)"; // Metadata: 0x004191D9
	public const string net_ftpstatuscode_ActionNotTakenFilenameNotAllowed = "File name not allowed"; // Metadata: 0x0041921C
	public const string net_httpstatuscode_NoContent = "No Content"; // Metadata: 0x00419235
	public const string net_httpstatuscode_NonAuthoritativeInformation = "Non Authoritative Information"; // Metadata: 0x00419243
	public const string net_httpstatuscode_ResetContent = "Reset Content"; // Metadata: 0x00419264
	public const string net_httpstatuscode_PartialContent = "Partial Content"; // Metadata: 0x00419275
	public const string net_httpstatuscode_MultipleChoices = "Multiple Choices Redirect"; // Metadata: 0x00419288
	public const string net_httpstatuscode_Ambiguous = "Ambiguous Redirect"; // Metadata: 0x004192A5
	public const string net_httpstatuscode_MovedPermanently = "Moved Permanently Redirect"; // Metadata: 0x004192BB
	public const string net_httpstatuscode_Moved = "Moved Redirect"; // Metadata: 0x004192D9
	public const string net_httpstatuscode_Found = "Found Redirect"; // Metadata: 0x004192EB
	public const string net_httpstatuscode_Redirect = "Redirect"; // Metadata: 0x004192FD
	public const string net_httpstatuscode_SeeOther = "See Other"; // Metadata: 0x00419309
	public const string net_httpstatuscode_RedirectMethod = "Redirect Method"; // Metadata: 0x00419316
	public const string net_httpstatuscode_NotModified = "Not Modified"; // Metadata: 0x00419329
	public const string net_httpstatuscode_UseProxy = "Use Proxy Redirect"; // Metadata: 0x00419339
	public const string net_httpstatuscode_TemporaryRedirect = "Temporary Redirect"; // Metadata: 0x0041934F
	public const string net_httpstatuscode_RedirectKeepVerb = "Redirect Keep Verb"; // Metadata: 0x00419365
	public const string net_httpstatuscode_BadRequest = "Bad Request"; // Metadata: 0x0041937B
	public const string net_httpstatuscode_Unauthorized = "Unauthorized"; // Metadata: 0x0041938A
	public const string net_httpstatuscode_PaymentRequired = "Payment Required"; // Metadata: 0x0041939A
	public const string net_httpstatuscode_Forbidden = "Forbidden"; // Metadata: 0x004193AE
	public const string net_httpstatuscode_NotFound = "Not Found"; // Metadata: 0x004193BB
	public const string net_httpstatuscode_MethodNotAllowed = "Method Not Allowed"; // Metadata: 0x004193C8
	public const string net_httpstatuscode_NotAcceptable = "Not Acceptable"; // Metadata: 0x004193DE
	public const string net_httpstatuscode_ProxyAuthenticationRequired = "Proxy Authentication Required"; // Metadata: 0x004193F0
	public const string net_httpstatuscode_RequestTimeout = "Request Timeout"; // Metadata: 0x00419411
	public const string net_httpstatuscode_Conflict = "Conflict"; // Metadata: 0x00419424
	public const string net_httpstatuscode_Gone = "Gone"; // Metadata: 0x00419430
	public const string net_httpstatuscode_LengthRequired = "Length Required"; // Metadata: 0x00419438
	public const string net_httpstatuscode_InternalServerError = "Internal Server Error"; // Metadata: 0x0041944B
	public const string net_httpstatuscode_NotImplemented = "Not Implemented"; // Metadata: 0x00419464
	public const string net_httpstatuscode_BadGateway = "Bad Gateway"; // Metadata: 0x00419477
	public const string net_httpstatuscode_ServiceUnavailable = "Server Unavailable"; // Metadata: 0x00419486
	public const string net_httpstatuscode_GatewayTimeout = "Gateway Timeout"; // Metadata: 0x0041949C
	public const string net_httpstatuscode_HttpVersionNotSupported = "Http Version Not Supported"; // Metadata: 0x004194AF
	public const string net_emptystringset = "This property cannot be set to an empty string."; // Metadata: 0x004194CD
	public const string net_emptystringcall = "The parameter \'{0}\' cannot be an empty string."; // Metadata: 0x00419500
	public const string net_headers_req = "This collection holds response headers and cannot contain the specified request header."; // Metadata: 0x00419532
	public const string net_headers_rsp = "This collection holds request headers and cannot contain the specified response header."; // Metadata: 0x0041958D
	public const string net_headers_toolong = "Header values cannot be longer than {0} characters."; // Metadata: 0x004195E8
	public const string net_WebHeaderInvalidCRLFChars = "Specified value has invalid CRLF characters."; // Metadata: 0x0041961F
	public const string net_WebHeaderInvalidHeaderChars = "Specified value has invalid HTTP Header characters."; // Metadata: 0x0041964F
	public const string net_WebHeaderInvalidNonAsciiChars = "Specified value has invalid non-ASCII characters."; // Metadata: 0x00419686
	public const string net_WebHeaderMissingColon = "Specified value does not have a \':\' separator."; // Metadata: 0x004196BB
	public const string net_headerrestrict = "The \'{0}\' header must be modified using the appropriate property or method."; // Metadata: 0x004196ED
	public const string net_io_completionportwasbound = "The socket has already been bound to an io completion port."; // Metadata: 0x0041973C
	public const string net_io_writefailure = "Unable to write data to the transport connection: {0}."; // Metadata: 0x0041977B
	public const string net_io_readfailure = "Unable to read data from the transport connection: {0}."; // Metadata: 0x004197B5
	public const string net_io_connectionclosed = "The connection was closed"; // Metadata: 0x004197F0
	public const string net_io_transportfailure = "Unable to create a transport connection."; // Metadata: 0x0041980D
	public const string net_io_internal_bind = "Internal Error: A socket handle could not be bound to a completion port."; // Metadata: 0x00419839
	public const string net_io_invalidnestedcall = "The {0} method cannot be called when another {1} operation is pending."; // Metadata: 0x00419885
	public const string net_io_must_be_rw_stream = "The stream has to be read/write."; // Metadata: 0x004198CF
	public const string net_io_header_id = "Found a wrong header field {0} read = {1}, expected = {2}."; // Metadata: 0x004198F3
	public const string net_io_out_range = "The byte count must not exceed {0} bytes for this stream type."; // Metadata: 0x00419931
	public const string net_io_encrypt = "The encryption operation failed, see inner exception."; // Metadata: 0x00419973
	public const string net_io_decrypt = "The decryption operation failed, see inner exception."; // Metadata: 0x004199AC
	public const string net_io_read = "The read operation failed, see inner exception."; // Metadata: 0x004199E5
	public const string net_io_write = "The write operation failed, see inner exception."; // Metadata: 0x00419A18
	public const string net_io_eof = "Received an unexpected EOF or 0 bytes from the transport stream."; // Metadata: 0x00419A4C
	public const string net_io_async_result = "The parameter: {0} is not valid. Use the object returned from corresponding Begin async call."; // Metadata: 0x00419A90
	public const string net_tls_version = "The SSL version is not supported."; // Metadata: 0x00419AF1
	public const string net_perm_target = "Cannot cast target permission type."; // Metadata: 0x00419B16
	public const string net_perm_both_regex = "Cannot subset Regex. Only support if both patterns are identical."; // Metadata: 0x00419B3D
	public const string net_perm_none = "There are no permissions to check."; // Metadata: 0x00419B82
	public const string net_perm_attrib_count = "The value for \'{0}\' must be specified."; // Metadata: 0x00419BA8
	public const string net_perm_invalid_val = "The parameter value \'{0}={1}\' is invalid."; // Metadata: 0x00419BD2
	public const string net_perm_attrib_multi = "The permission \'{0}={1}\' cannot be added. Add a separate Attribute statement."; // Metadata: 0x00419BFF
	public const string net_perm_epname = "The argument value \'{0}\' is invalid for creating a SocketPermission object."; // Metadata: 0x00419C50
	public const string net_perm_invalid_val_in_element = "The \'{0}\' element contains one or more invalid values."; // Metadata: 0x00419C9F
	public const string net_invalid_ip_addr = "IPv4 address 0.0.0.0 and IPv6 address ::0 are unspecified addresses that cannot be used as a target address."; // Metadata: 0x00419CD9
	public const string dns_bad_ip_address = "An invalid IP address was specified."; // Metadata: 0x00419D49
	public const string net_bad_mac_address = "An invalid physical address was specified."; // Metadata: 0x00419D71
	public const string net_ping = "An exception occurred during a Ping request."; // Metadata: 0x00419D9F
	public const string net_bad_ip_address_prefix = "An invalid IP address prefix was specified."; // Metadata: 0x00419DCF
	public const string net_max_ip_address_list_length_exceeded = "Too many addresses to sort. The maximum number of addresses allowed are {0}."; // Metadata: 0x00419DFE
	public const string net_ipv4_not_installed = "IPv4 is not installed."; // Metadata: 0x00419E4E
	public const string net_ipv6_not_installed = "IPv6 is not installed."; // Metadata: 0x00419E68
	public const string net_webclient = "An exception occurred during a WebClient request."; // Metadata: 0x00419E82
	public const string net_webclient_ContentType = "The Content-Type header cannot be changed from its default value for this request."; // Metadata: 0x00419EB7
	public const string net_webclient_Multipart = "The Content-Type header cannot be set to a multipart type for this request."; // Metadata: 0x00419F0D
	public const string net_webclient_no_concurrent_io_allowed = "WebClient does not support concurrent I/O operations."; // Metadata: 0x00419F5C
	public const string net_webclient_invalid_baseaddress = "The specified value is not a valid base address."; // Metadata: 0x00419F95
	public const string net_container_add_cookie = "An error occurred when adding a cookie to the container."; // Metadata: 0x00419FC9
	public const string net_cookie_invalid = "Invalid contents for cookie = \'{0}\'."; // Metadata: 0x0041A005
	public const string net_cookie_size = "The value size of the cookie is \'{0}\'. This exceeds the configured maximum size, which is \'{1}\'."; // Metadata: 0x0041A02D
	public const string net_cookie_parse_header = "An error occurred when parsing the Cookie header for Uri \'{0}\'."; // Metadata: 0x0041A091
	public const string net_cookie_attribute = "The \'{0}\'=\'{1}\' part of the cookie is invalid."; // Metadata: 0x0041A0D4
	public const string net_cookie_format = "Cookie format error."; // Metadata: 0x0041A106
	public const string net_cookie_capacity_range = "\'{0}\' has to be greater than \'{1}\' and less than \'{2}\'."; // Metadata: 0x0041A11E
	public const string net_set_token = "Failed to impersonate a thread doing authentication of a Web Request."; // Metadata: 0x0041A159
	public const string net_revert_token = "Failed to revert the thread token after authenticating a Web Request."; // Metadata: 0x0041A1A2
	public const string net_ssl_io_async_context = "Async context creation failed."; // Metadata: 0x0041A1EB
	public const string net_ssl_io_encrypt = "The encryption operation failed, see inner exception."; // Metadata: 0x0041A20D
	public const string net_ssl_io_decrypt = "The decryption operation failed, see inner exception."; // Metadata: 0x0041A246
	public const string net_ssl_io_context_expired = "The security context has expired."; // Metadata: 0x0041A27F
	public const string net_ssl_io_handshake_start = "The handshake failed. The remote side has dropped the stream."; // Metadata: 0x0041A2A4
	public const string net_ssl_io_handshake = "The handshake failed, see inner exception."; // Metadata: 0x0041A2E5
	public const string net_ssl_io_frame = "The handshake failed due to an unexpected packet format."; // Metadata: 0x0041A313
	public const string net_ssl_io_corrupted = "The stream is corrupted due to an invalid SSL version number in the SSL protocol header."; // Metadata: 0x0041A34F
	public const string net_ssl_io_cert_validation = "The remote certificate is invalid according to the validation procedure."; // Metadata: 0x0041A3AB
	public const string net_ssl_io_invalid_end_call = "{0} can only be called once for each asynchronous operation."; // Metadata: 0x0041A3F7
	public const string net_ssl_io_invalid_begin_call = "{0} cannot be called when another {1} operation is pending."; // Metadata: 0x0041A437
	public const string net_ssl_io_no_server_cert = "The server mode SSL must use a certificate with the associated private key."; // Metadata: 0x0041A476
	public const string net_auth_bad_client_creds = "The server has rejected the client credentials."; // Metadata: 0x0041A4C5
	public const string net_auth_bad_client_creds_or_target_mismatch = "Either the target name is incorrect or the server has rejected the client credentials."; // Metadata: 0x0041A4F8
	public const string net_auth_context_expectation = "A security requirement was not fulfilled during authentication. Required: {0}, negotiated: {1}."; // Metadata: 0x0041A552
	public const string net_auth_context_expectation_remote = "A remote side security requirement was not fulfilled during authentication. Try increasing the ProtectionLevel and/or ImpersonationLevel."; // Metadata: 0x0041A5B5
	public const string net_auth_supported_impl_levels = "The supported values are Identification, Impersonation or Delegation."; // Metadata: 0x0041A642
	public const string net_auth_no_anonymous_support = "The TokenImpersonationLevel.Anonymous level is not supported for authentication."; // Metadata: 0x0041A68B
	public const string net_auth_reauth = "This operation is not allowed on a security context that has already been authenticated."; // Metadata: 0x0041A6DF
	public const string net_auth_noauth = "This operation is only allowed using a successfully authenticated context."; // Metadata: 0x0041A73B
	public const string net_auth_client_server = "Once authentication is attempted as the client or server, additional authentication attempts must use the same client or server role."; // Metadata: 0x0041A789
	public const string net_auth_noencryption = "This authenticated context does not support data encryption."; // Metadata: 0x0041A812
	public const string net_auth_SSPI = "A call to SSPI failed, see inner exception."; // Metadata: 0x0041A852
	public const string net_auth_failure = "Authentication failed, see inner exception."; // Metadata: 0x0041A881
	public const string net_auth_eof = "Authentication failed because the remote party has closed the transport stream."; // Metadata: 0x0041A8B0
	public const string net_auth_alert = "Authentication failed on the remote side (the stream might still be available for additional authentication attempts)."; // Metadata: 0x0041A903
	public const string net_auth_ignored_reauth = "Re-authentication failed because the remote party continued to encrypt more than {0} bytes before answering re-authentication."; // Metadata: 0x0041A97D
	public const string net_auth_empty_read = "Protocol error: cannot proceed with SSPI handshake because an empty blob was received."; // Metadata: 0x0041A9FF
	public const string net_auth_must_specify_extended_protection_scheme = "An extended protection policy must specify either a custom channel binding or a custom service name collection."; // Metadata: 0x0041AA59
	public const string net_frame_size = "Received an invalid authentication frame. The message size is limited to {0} bytes, attempted to read {1} bytes."; // Metadata: 0x0041AACC
	public const string net_frame_read_io = "Received incomplete authentication message. Remote party has probably closed the connection."; // Metadata: 0x0041AB40
	public const string net_frame_read_size = "Cannot determine the frame size or a corrupted frame was received."; // Metadata: 0x0041ABA0
	public const string net_frame_max_size = "The payload size is limited to {0}, attempted set it to {1}."; // Metadata: 0x0041ABE6
	public const string net_jscript_load = "The proxy JScript file threw an exception while being initialized: {0}."; // Metadata: 0x0041AC26
	public const string net_proxy_not_gmt = "The specified value is not a valid GMT time."; // Metadata: 0x0041AC71
	public const string net_proxy_invalid_dayofweek = "The specified value is not a valid day of the week."; // Metadata: 0x0041ACA1
	public const string net_proxy_invalid_url_format = "The system proxy settings contain an invalid proxy server setting: \'{0}\'."; // Metadata: 0x0041ACD8
	public const string net_param_not_string = "Argument must be a string instead of {0}."; // Metadata: 0x0041AD25
	public const string net_value_cannot_be_negative = "The specified value cannot be negative."; // Metadata: 0x0041AD52
	public const string net_invalid_offset = "Value of offset cannot be negative or greater than the length of the buffer."; // Metadata: 0x0041AD7D
	public const string net_offset_plus_count = "Sum of offset and count cannot be greater than the length of the buffer."; // Metadata: 0x0041ADCD
	public const string net_cannot_be_false = "The specified value cannot be false."; // Metadata: 0x0041AE19
	public const string net_cache_shadowstream_not_writable = "Shadow stream must be writable."; // Metadata: 0x0041AE41
	public const string net_cache_validator_fail = "The validation method {0}() returned a failure for this request."; // Metadata: 0x0041AE64
	public const string net_cache_access_denied = "For this RequestCache object, {0} access is denied."; // Metadata: 0x0041AEA8
	public const string net_cache_validator_result = "The validation method {0}() returned the unexpected status: {1}."; // Metadata: 0x0041AEDF
	public const string net_cache_retrieve_failure = "Cache retrieve failed: {0}."; // Metadata: 0x0041AF23
	public const string net_cache_not_supported_body = "The cached response is not supported for a request with a content body."; // Metadata: 0x0041AF42
	public const string net_cache_not_supported_command = "The cached response is not supported for a request with the specified request method."; // Metadata: 0x0041AF8D
	public const string net_cache_not_accept_response = "The cache protocol refused the server response. To allow automatic request retrying, set request.AllowAutoRedirect to true."; // Metadata: 0x0041AFE6
	public const string net_cache_method_failed = "The request (Method = {0}) cannot be served from the cache and will fail because of the effective CachePolicy: {1}."; // Metadata: 0x0041B065
	public const string net_cache_key_failed = "The request failed because no cache entry (CacheKey = {0}) was found and the effective CachePolicy is {1}."; // Metadata: 0x0041B0DC
	public const string net_cache_no_stream = "The cache protocol returned a cached response but the cache entry is invalid because it has a null stream. (Cache Key = {0})."; // Metadata: 0x0041B14A
	public const string net_cache_unsupported_partial_stream = "A partial content stream does not support this operation or some method argument is out of range."; // Metadata: 0x0041B1CB
	public const string net_cache_not_configured = "No cache protocol is available for this request."; // Metadata: 0x0041B230
	public const string net_cache_non_seekable_stream_not_supported = "The transport stream instance passed in the RangeStream constructor is not seekable and therefore is not supported."; // Metadata: 0x0041B264
	public const string net_invalid_cast = "Invalid cast from {0} to {1}."; // Metadata: 0x0041B2DB
	public const string net_collection_readonly = "The collection is read-only."; // Metadata: 0x0041B2FC
	public const string net_not_ipermission = "Specified value does not contain \'IPermission\' as its tag."; // Metadata: 0x0041B31C
	public const string net_no_classname = "Specified value does not contain a \'class\' attribute."; // Metadata: 0x0041B35A
	public const string net_no_typename = "The value class attribute is not valid."; // Metadata: 0x0041B393
	public const string net_servicePointAddressNotSupportedInHostMode = "This property is not supported for protocols that do not use URI."; // Metadata: 0x0041B3BE
	public const string net_Websockets_WebSocketBaseFaulted = "An exception caused the WebSocket to enter the Aborted state. Please see the InnerException, if present, for more details."; // Metadata: 0x0041B403
	public const string net_WebSockets_Generic = "An internal WebSocket error occurred. Please see the innerException, if present, for more details."; // Metadata: 0x0041B481
	public const string net_WebSockets_NotAWebSocket_Generic = "A WebSocket operation was called on a request or response that is not a WebSocket."; // Metadata: 0x0041B4E7
	public const string net_WebSockets_UnsupportedWebSocketVersion_Generic = "Unsupported WebSocket version."; // Metadata: 0x0041B53D
	public const string net_WebSockets_HeaderError_Generic = "The WebSocket request or response contained unsupported header(s)."; // Metadata: 0x0041B55F
	public const string net_WebSockets_UnsupportedProtocol_Generic = "The WebSocket request or response operation was called with unsupported protocol(s)."; // Metadata: 0x0041B5A5
	public const string net_WebSockets_ClientSecWebSocketProtocolsBlank = "The WebSocket client sent a blank \'{0}\' header; this is not allowed by the WebSocket protocol specification. The client should omit the header if the client is not negotiating any sub-protocols."; // Metadata: 0x0041B5FD
	public const string net_WebSockets_InvalidState_Generic = "The WebSocket instance cannot be used for communication because it has been transitioned into an invalid state."; // Metadata: 0x0041B6C3
	public const string net_WebSockets_InvalidMessageType_Generic = "The received  message type is invalid after calling {0}. {0} should only be used if no more data is expected from the remote endpoint. Use \'{1}\' instead to keep being able to receive data but close the output channel."; // Metadata: 0x0041B736
	public const string net_WebSockets_ConnectionClosedPrematurely_Generic = "The remote party closed the WebSocket connection without completing the close handshake."; // Metadata: 0x0041B813
	public const string net_WebSockets_Scheme = "Only Uris starting with \'ws://\' or \'wss://\' are supported."; // Metadata: 0x0041B86F
	public const string net_WebSockets_AlreadyStarted = "The WebSocket has already been started."; // Metadata: 0x0041B8AD
	public const string net_WebSockets_Connect101Expected = "The server returned status code \'{0}\' when status code \'101\' was expected."; // Metadata: 0x0041B8D8
	public const string net_WebSockets_InvalidResponseHeader = "The \'{0}\' header value \'{1}\' is invalid."; // Metadata: 0x0041B926
	public const string net_WebSockets_NotConnected = "The WebSocket is not connected."; // Metadata: 0x0041B952
	public const string net_WebSockets_InvalidRegistration = "The WebSocket schemes must be registered with the HttpWebRequest class."; // Metadata: 0x0041B975
	public const string net_WebSockets_NoDuplicateProtocol = "Duplicate protocols are not allowed: \'{0}\'."; // Metadata: 0x0041B9C0
	public const string net_log_exception = "Exception in {0}::{1} - {2}."; // Metadata: 0x0041B9EF
	public const string net_log_sspi_enumerating_security_packages = "Enumerating security packages:"; // Metadata: 0x0041BA0F
	public const string net_log_sspi_security_package_not_found = "Security package \'{0}\' was not found."; // Metadata: 0x0041BA31
	public const string net_log_sspi_security_context_input_buffer = "{0}(In-Buffer length={1}, Out-Buffer length={2}, returned code={3})."; // Metadata: 0x0041BA5A
	public const string net_log_sspi_security_context_input_buffers = "{0}(In-Buffers count={1}, Out-Buffer length={2}, returned code={3})."; // Metadata: 0x0041BAA2
	public const string net_log_sspi_selected_cipher_suite = "{0}(Protocol={1}, Cipher={2} {3} bit strength, Hash={4} {5} bit strength, Key Exchange={6} {7} bit strength)."; // Metadata: 0x0041BAEA
	public const string net_log_remote_certificate = "Remote certificate: {0}."; // Metadata: 0x0041BB5B
	public const string net_log_locating_private_key_for_certificate = "Locating the private key for the certificate: {0}."; // Metadata: 0x0041BB77
	public const string net_log_cert_is_of_type_2 = "Certificate is of type X509Certificate2 and contains the private key."; // Metadata: 0x0041BBAD
	public const string net_log_found_cert_in_store = "Found the certificate in the {0} store."; // Metadata: 0x0041BBF6
	public const string net_log_did_not_find_cert_in_store = "Cannot find the certificate in either the LocalMachine store or the CurrentUser store."; // Metadata: 0x0041BC21
	public const string net_log_open_store_failed = "Opening Certificate store {0} failed, exception: {1}."; // Metadata: 0x0041BC7B
	public const string net_log_got_certificate_from_delegate = "Got a certificate from the client delegate."; // Metadata: 0x0041BCB4
	public const string net_log_no_delegate_and_have_no_client_cert = "Client delegate did not provide a certificate; and there are not other user-provided certificates. Need to attempt a session restart."; // Metadata: 0x0041BCE3
	public const string net_log_no_delegate_but_have_client_cert = "Client delegate did not provide a certificate; but there are other user-provided certificates\"."; // Metadata: 0x0041BD6C
	public const string net_log_attempting_restart_using_cert = "Attempting to restart the session using the user-provided certificate: {0}."; // Metadata: 0x0041BDCF
	public const string net_log_no_issuers_try_all_certs = "We have user-provided certificates. The server has not specified any issuers, so try all the certificates."; // Metadata: 0x0041BE1E
	public const string net_log_server_issuers_look_for_matching_certs = "We have user-provided certificates. The server has specified {0} issuer(s). Looking for certificates that match any of the issuers."; // Metadata: 0x0041BE8C
	public const string net_log_selected_cert = "Selected certificate: {0}."; // Metadata: 0x0041BF13
	public const string net_log_n_certs_after_filtering = "Left with {0} client certificates to choose from."; // Metadata: 0x0041BF31
	public const string net_log_finding_matching_certs = "Trying to find a matching certificate in the certificate store."; // Metadata: 0x0041BF66
	public const string net_log_using_cached_credential = "Using the cached credential handle."; // Metadata: 0x0041BFA9
	public const string net_log_remote_cert_user_declared_valid = "Remote certificate was verified as valid by the user."; // Metadata: 0x0041BFD0
	public const string net_log_remote_cert_user_declared_invalid = "Remote certificate was verified as invalid by the user."; // Metadata: 0x0041C009
	public const string net_log_remote_cert_has_no_errors = "Remote certificate has no errors."; // Metadata: 0x0041C044
	public const string net_log_remote_cert_has_errors = "Remote certificate has errors:"; // Metadata: 0x0041C069
	public const string net_log_remote_cert_not_available = "The remote server did not provide a certificate."; // Metadata: 0x0041C08B
	public const string net_log_remote_cert_name_mismatch = "Certificate name mismatch."; // Metadata: 0x0041C0BF
	public const string net_log_proxy_autodetect_script_location_parse_error = "WebProxy failed to parse the auto-detected location of a proxy script:\"{0}\" into a Uri."; // Metadata: 0x0041C0DD
	public const string net_log_proxy_autodetect_failed = "WebProxy failed to autodetect a Uri for a proxy script."; // Metadata: 0x0041C138
	public const string net_log_proxy_script_execution_error = "WebProxy caught an exception while executing the ScriptReturn script: {0}."; // Metadata: 0x0041C173
	public const string net_log_proxy_script_download_compile_error = "WebProxy caught an exception while  downloading/compiling the proxy script: {0}."; // Metadata: 0x0041C1C1
	public const string net_log_proxy_system_setting_update = "ScriptEngine was notified of a potential change in the system\'s proxy settings and will update WebProxy settings."; // Metadata: 0x0041C215
	public const string net_log_proxy_update_due_to_ip_config_change = "ScriptEngine was notified of a change in the IP configuration and will update WebProxy settings."; // Metadata: 0x0041C28A
	public const string net_log_proxy_called_with_null_parameter = "{0} was called with a null \'{1}\' parameter."; // Metadata: 0x0041C2EE
	public const string net_log_proxy_called_with_invalid_parameter = "{0} was called with an invalid parameter."; // Metadata: 0x0041C31D
	public const string net_log_proxy_ras_supported = "RAS supported: {0}"; // Metadata: 0x0041C34A
	public const string net_log_proxy_ras_notsupported_exception = "RAS is not supported. Can\'t create RasHelper instance."; // Metadata: 0x0041C360
	public const string net_log_proxy_winhttp_cant_open_session = "Can\'t open WinHttp session. Error code: {0}."; // Metadata: 0x0041C39A
	public const string net_log_proxy_winhttp_getproxy_failed = "Can\'t retrieve proxy settings for Uri \'{0}\'. Error code: {1}."; // Metadata: 0x0041C3CA
	public const string net_log_proxy_winhttp_timeout_error = "Can\'t specify proxy discovery timeout. Error code: {0}."; // Metadata: 0x0041C40B
	public const string net_log_cache_validation_failed_resubmit = "Resubmitting this request because cache cannot validate the response."; // Metadata: 0x0041C446
	public const string net_log_cache_refused_server_response = "Caching protocol has refused the server response. To allow automatic request retrying set request.AllowAutoRedirect=true."; // Metadata: 0x0041C48F
	public const string net_log_cache_ftp_proxy_doesnt_support_partial = "This FTP request is configured to use a proxy through HTTP protocol. Cache revalidation and partially cached responses are not supported."; // Metadata: 0x0041C50C
	public const string net_log_cache_ftp_method = "FTP request method={0}."; // Metadata: 0x0041C599
	public const string net_log_cache_ftp_supports_bin_only = "Caching is not supported for non-binary FTP request mode."; // Metadata: 0x0041C5B4
	public const string net_log_cache_replacing_entry_with_HTTP_200 = "Replacing cache entry metadata with \'HTTP/1.1 200 OK\' status line to satisfy HTTP cache protocol logic."; // Metadata: 0x0041C5F1
	public const string net_log_cache_now_time = "[Now Time (UTC)] = {0}."; // Metadata: 0x0041C65C
	public const string net_log_cache_max_age_absolute = "[MaxAge] Absolute time expiration check (sensitive to clock skew), cache Expires: {0}."; // Metadata: 0x0041C677
	public const string net_log_cache_age1 = "[Age1] Now - LastSynchronized = [Age1] Now - LastSynchronized = {0}, Last Synchronized: {1}."; // Metadata: 0x0041C6D1
	public const string net_log_cache_age1_date_header = "[Age1] NowTime-Date Header = {0}, Date Header: {1}."; // Metadata: 0x0041C731
	public const string net_log_cache_age1_last_synchronized = "[Age1] Now - LastSynchronized + AgeHeader = {0}, Last Synchronized: {1}."; // Metadata: 0x0041C768
	public const string net_log_cache_age1_last_synchronized_age_header = "[Age1] Now - LastSynchronized + AgeHeader = {0}, Last Synchronized: {1}, Age Header: {2}."; // Metadata: 0x0041C7B4
	public const string net_log_cache_age2 = "[Age2] AgeHeader = {0}."; // Metadata: 0x0041C811
	public const string net_log_cache_max_age_cache_s_max_age = "[MaxAge] Cache s_MaxAge = {0}."; // Metadata: 0x0041C82C
	public const string net_log_cache_max_age_expires_date = "[MaxAge] Cache Expires - Date = {0}, Expires: {1}."; // Metadata: 0x0041C84E
	public const string net_log_cache_max_age_cache_max_age = "[MaxAge] Cache MaxAge = {0}."; // Metadata: 0x0041C884
	public const string net_log_cache_no_max_age_use_10_percent = "[MaxAge] Cannot compute Cache MaxAge, use 10% since LastModified: {0}, LastModified: {1}."; // Metadata: 0x0041C8A4
	public const string net_log_cache_no_max_age_use_default = "[MaxAge] Cannot compute Cache MaxAge, using default RequestCacheValidator.UnspecifiedMaxAge: {0}."; // Metadata: 0x0041C901
	public const string net_log_cache_validator_invalid_for_policy = "This validator should not be called for policy : {0}."; // Metadata: 0x0041C966
	public const string net_log_cache_response_last_modified = "Response LastModified={0},  ContentLength= {1}."; // Metadata: 0x0041C99F
	public const string net_log_cache_cache_last_modified = "Cache    LastModified={0},  ContentLength= {1}."; // Metadata: 0x0041C9D2
	public const string net_log_cache_partial_and_non_zero_content_offset = "A Cache Entry is partial and the user request has non zero ContentOffset = {0}. A restart from cache is not supported for partial cache entries."; // Metadata: 0x0041CA05
	public const string net_log_cache_response_valid_based_on_policy = "Response is valid based on Policy = {0}."; // Metadata: 0x0041CA99
	public const string net_log_cache_null_response_failure = "Response is null so this Request should fail."; // Metadata: 0x0041CAC5
	public const string net_log_cache_ftp_response_status = "FTP Response Status={0}, {1}."; // Metadata: 0x0041CAF6
	public const string net_log_cache_resp_valid_based_on_retry = "Accept this response as valid based on the retry count = {0}."; // Metadata: 0x0041CB17
	public const string net_log_cache_no_update_based_on_method = "Cache is not updated based on the request Method = {0}."; // Metadata: 0x0041CB58
	public const string net_log_cache_removed_existing_invalid_entry = "Existing entry is removed because it was found invalid."; // Metadata: 0x0041CB93
	public const string net_log_cache_not_updated_based_on_policy = "Cache is not updated based on Policy = {0}."; // Metadata: 0x0041CBCE
	public const string net_log_cache_not_updated_because_no_response = "Cache is not updated because there is no response associated with the request."; // Metadata: 0x0041CBFD
	public const string net_log_cache_removed_existing_based_on_method = "Existing cache entry is removed based on the request Method = {0}."; // Metadata: 0x0041CC4F
	public const string net_log_cache_existing_not_removed_because_unexpected_response_status = "Existing cache entry should but cannot be removed due to unexpected response Status = ({0}) {1}."; // Metadata: 0x0041CC95
	public const string net_log_cache_removed_existing_based_on_policy = "Existing cache entry is removed based on Policy = {0}."; // Metadata: 0x0041CCF9
	public const string net_log_cache_not_updated_based_on_ftp_response_status = "Cache is not updated based on the FTP response status. Expected = {0}, actual = {1}."; // Metadata: 0x0041CD33
	public const string net_log_cache_update_not_supported_for_ftp_restart = "Cache update is not supported for restarted FTP responses. Restart offset = {0}."; // Metadata: 0x0041CD8B
	public const string net_log_cache_removed_entry_because_ftp_restart_response_changed = "Existing cache entry is removed since a restarted response was changed on the server, cache LastModified date = {0}, new LastModified date = {1}."; // Metadata: 0x0041CDDF
	public const string net_log_cache_last_synchronized = "The cache entry last synchronized time = {0}."; // Metadata: 0x0041CE74
	public const string net_log_cache_suppress_update_because_synched_last_minute = "Suppressing cache update since the entry was synchronized within the last minute."; // Metadata: 0x0041CEA5
	public const string net_log_cache_updating_last_synchronized = "Updating cache entry last synchronized time = {0}."; // Metadata: 0x0041CEFA
	public const string net_log_cache_cannot_remove = "{0} Cannot Remove (throw): Key = {1}, Error = {2}."; // Metadata: 0x0041CF30
	public const string net_log_cache_key_status = "{0}, Key = {1}, -> Status = {2}."; // Metadata: 0x0041CF66
	public const string net_log_cache_key_remove_failed_status = "{0}, Key = {1}, Remove operation failed -> Status = {2}."; // Metadata: 0x0041CF8A
	public const string net_log_cache_usecount_file = "{0}, UseCount = {1}, File = {2}."; // Metadata: 0x0041CFC6
	public const string net_log_cache_stream = "{0}, stream = {1}."; // Metadata: 0x0041CFEA
	public const string net_log_cache_filename = "{0} -> Filename = {1}, Status = {2}."; // Metadata: 0x0041D000
	public const string net_log_cache_lookup_failed = "{0}, Lookup operation failed -> {1}."; // Metadata: 0x0041D028
	public const string net_log_cache_exception = "{0}, Exception = {1}."; // Metadata: 0x0041D050
	public const string net_log_cache_expected_length = "Expected length (0=none)= {0}."; // Metadata: 0x0041D069
	public const string net_log_cache_last_modified = "LastModified    (0=none)= {0}."; // Metadata: 0x0041D08B
	public const string net_log_cache_expires = "Expires         (0=none)= {0}."; // Metadata: 0x0041D0AD
	public const string net_log_cache_max_stale = "MaxStale (sec)          = {0}."; // Metadata: 0x0041D0CF
	public const string net_log_cache_dumping_metadata = "...Dumping Metadata..."; // Metadata: 0x0041D0F1
	public const string net_log_cache_create_failed = "Create operation failed -> {0}."; // Metadata: 0x0041D10B
	public const string net_log_cache_set_expires = "Set Expires               ={0}."; // Metadata: 0x0041D12E
	public const string net_log_cache_set_last_modified = "Set LastModified          ={0}."; // Metadata: 0x0041D151
	public const string net_log_cache_set_last_synchronized = "Set LastSynchronized      ={0}."; // Metadata: 0x0041D174
	public const string net_log_cache_enable_max_stale = "Enable MaxStale (sec) ={0}."; // Metadata: 0x0041D197
	public const string net_log_cache_disable_max_stale = "Disable MaxStale (set to 0)."; // Metadata: 0x0041D1B6
	public const string net_log_cache_set_new_metadata = "Set new Metadata."; // Metadata: 0x0041D1D6
	public const string net_log_cache_dumping = "...Dumping..."; // Metadata: 0x0041D1EB
	public const string net_log_cache_key = "{0}, Key = {1}."; // Metadata: 0x0041D1FC
	public const string net_log_cache_no_commit = "{0}, Nothing was written to the stream, do not commit that cache entry."; // Metadata: 0x0041D20F
	public const string net_log_cache_error_deleting_filename = "{0}, Error deleting a Filename = {1}."; // Metadata: 0x0041D25A
	public const string net_log_cache_update_failed = "{0}, Key = {1}, Update operation failed -> {2}."; // Metadata: 0x0041D283
	public const string net_log_cache_delete_failed = "{0}, Key = {1}, Delete operation failed -> {2}."; // Metadata: 0x0041D2B6
	public const string net_log_cache_commit_failed = "{0}, Key = {1}, Commit operation failed -> {2}."; // Metadata: 0x0041D2E9
	public const string net_log_cache_committed_as_partial = "{0}, Key = {1}, Committed entry as partial, not cached bytes count = {2}."; // Metadata: 0x0041D31C
	public const string net_log_cache_max_stale_and_update_status = "{0}, MaxStale = {1}, Update Status = {2}."; // Metadata: 0x0041D369
	public const string net_log_cache_failing_request_with_exception = "Failing request with the WebExceptionStatus = {0}."; // Metadata: 0x0041D396
	public const string net_log_cache_request_method = "Request Method = {0}."; // Metadata: 0x0041D3CC
	public const string net_log_cache_http_status_parse_failure = "Cannot Parse Cache HTTP Status Line: {0}."; // Metadata: 0x0041D3E5
	public const string net_log_cache_http_status_line = "Entry Status Line = HTTP/{0} {1} {2}."; // Metadata: 0x0041D412
	public const string net_log_cache_cache_control = "Cache Cache-Control = {0}."; // Metadata: 0x0041D43B
	public const string net_log_cache_invalid_http_version = "The cached version is invalid, assuming HTTP 1.0."; // Metadata: 0x0041D459
	public const string net_log_cache_no_http_response_header = "This Cache Entry does not carry HTTP response headers."; // Metadata: 0x0041D48E
	public const string net_log_cache_http_header_parse_error = "Cannot parse HTTP headers in entry metadata, offending string: {0}."; // Metadata: 0x0041D4C8
	public const string net_log_cache_metadata_name_value_parse_error = "Cannot parse all strings in system metadata as \"name:value\", offending string: {0}."; // Metadata: 0x0041D50F
	public const string net_log_cache_content_range_error = "Invalid format of Response Content-Range:{0}."; // Metadata: 0x0041D566
	public const string net_log_cache_cache_control_error = "Invalid CacheControl header = {0}."; // Metadata: 0x0041D597
	public const string net_log_cache_unexpected_status = "The cache protocol method {0} has returned unexpected status: {1}."; // Metadata: 0x0041D5BD
	public const string net_log_cache_object_and_exception = "{0} exception: {1}."; // Metadata: 0x0041D603
	public const string net_log_cache_revalidation_not_needed = "{0}, No cache entry revalidation is needed."; // Metadata: 0x0041D61A
	public const string net_log_cache_not_updated_based_on_cache_protocol_status = "{0}, Cache is not updated based on the current cache protocol status = {1}."; // Metadata: 0x0041D649
	public const string net_log_cache_closing_cache_stream = "{0}: {1} Closing effective cache stream, type = {2}, cache entry key = {3}."; // Metadata: 0x0041D698
	public const string net_log_cache_exception_ignored = "{0}: an exception (ignored) on {1} = {2}."; // Metadata: 0x0041D6E7
	public const string net_log_cache_no_cache_entry = "{0} has requested a cache response but the entry does not exist (Stream.Null)."; // Metadata: 0x0041D714
	public const string net_log_cache_null_cached_stream = "{0} has requested a cache response but the cached stream is null."; // Metadata: 0x0041D766
	public const string net_log_cache_requested_combined_but_null_cached_stream = "{0} has requested a combined response but the cached stream is null."; // Metadata: 0x0041D7AB
	public const string net_log_cache_returned_range_cache = "{0} has returned a range cache stream, Offset = {1}, Length = {2}."; // Metadata: 0x0041D7F3
	public const string net_log_cache_entry_not_found_freshness_undefined = "{0}, Cache Entry not found, freshness result = Undefined."; // Metadata: 0x0041D839
	public const string net_log_cache_dumping_cache_context = "...Dumping Cache Context..."; // Metadata: 0x0041D876
	public const string net_log_cache_result = "{0}, result = {1}."; // Metadata: 0x0041D895
	public const string net_log_cache_uri_with_query_has_no_expiration = "Request Uri has a Query, and no explicit expiration time is provided."; // Metadata: 0x0041D8AB
	public const string net_log_cache_uri_with_query_and_cached_resp_from_http_10 = "Request Uri has a Query, and cached response is from HTTP 1.0 server."; // Metadata: 0x0041D8F4
	public const string net_log_cache_valid_as_fresh_or_because_policy = "Valid as fresh or because of Cache Policy = {0}."; // Metadata: 0x0041D93D
	public const string net_log_cache_accept_based_on_retry_count = "Accept this response base on the retry count = {0}."; // Metadata: 0x0041D971
	public const string net_log_cache_date_header_older_than_cache_entry = "Response Date header value is older than that of the cache entry."; // Metadata: 0x0041D9A8
	public const string net_log_cache_server_didnt_satisfy_range = "Server did not satisfy the range: {0}."; // Metadata: 0x0041D9ED
	public const string net_log_cache_304_received_on_unconditional_request = "304 response was received on an unconditional request."; // Metadata: 0x0041DA17
	public const string net_log_cache_304_received_on_unconditional_request_expected_200_206 = "304 response was received on an unconditional request, but expected response code is 200 or 206."; // Metadata: 0x0041DA51
	public const string net_log_cache_last_modified_header_older_than_cache_entry = "HTTP 1.0 Response Last-Modified header value is older than that of the cache entry."; // Metadata: 0x0041DAB5
	public const string net_log_cache_freshness_outside_policy_limits = "Response freshness is not within the specified policy limits."; // Metadata: 0x0041DB0C
	public const string net_log_cache_need_to_remove_invalid_cache_entry_304 = "Need to remove an invalid cache entry with status code == 304(NotModified)."; // Metadata: 0x0041DB4D
	public const string net_log_cache_resp_status = "Response Status = {0}."; // Metadata: 0x0041DB9C
	public const string net_log_cache_resp_304_or_request_head = "Response==304 or Request was HEAD, updating cache entry."; // Metadata: 0x0041DBB6
	public const string net_log_cache_dont_update_cached_headers = "Do not update Cached Headers."; // Metadata: 0x0041DBF2
	public const string net_log_cache_update_cached_headers = "Update Cached Headers."; // Metadata: 0x0041DC13
	public const string net_log_cache_partial_resp_not_combined_with_existing_entry = "A partial response is not combined with existing cache entry, Cache Stream Size = {0}, response Range Start = {1}."; // Metadata: 0x0041DC2D
	public const string net_log_cache_request_contains_conditional_header = "User Request contains a conditional header."; // Metadata: 0x0041DCA3
	public const string net_log_cache_not_a_get_head_post = "This was Not a GET, HEAD or POST request."; // Metadata: 0x0041DCD2
	public const string net_log_cache_cannot_update_cache_if_304 = "Cannot update cache if Response status == 304 and a cache entry was not found."; // Metadata: 0x0041DCFF
	public const string net_log_cache_cannot_update_cache_with_head_resp = "Cannot update cache with HEAD response if the cache entry does not exist."; // Metadata: 0x0041DD51
	public const string net_log_cache_http_resp_is_null = "HttpWebResponse is null."; // Metadata: 0x0041DD9E
	public const string net_log_cache_resp_cache_control_is_no_store = "Response Cache-Control = no-store."; // Metadata: 0x0041DDBA
	public const string net_log_cache_resp_cache_control_is_public = "Response Cache-Control = public."; // Metadata: 0x0041DDE0
	public const string net_log_cache_resp_cache_control_is_private = "Response Cache-Control = private, and Cache is public."; // Metadata: 0x0041DE04
	public const string net_log_cache_resp_cache_control_is_private_plus_headers = "Response Cache-Control = private+Headers, removing those headers."; // Metadata: 0x0041DE3E
	public const string net_log_cache_resp_older_than_cache = "HttpWebResponse date is older than of the cached one."; // Metadata: 0x0041DE83
	public const string net_log_cache_revalidation_required = "Response revalidation is always required but neither Last-Modified nor ETag header is set on the response."; // Metadata: 0x0041DEBC
	public const string net_log_cache_needs_revalidation = "Response can be cached although it will always require revalidation."; // Metadata: 0x0041DF2A
	public const string net_log_cache_resp_allows_caching = "Response explicitly allows caching = Cache-Control: {0}."; // Metadata: 0x0041DF72
	public const string net_log_cache_auth_header_and_no_s_max_age = "Request carries Authorization Header and no s-maxage, proxy-revalidate or public directive found."; // Metadata: 0x0041DFAE
	public const string net_log_cache_post_resp_without_cache_control_or_expires = "POST Response without Cache-Control or Expires headers."; // Metadata: 0x0041E013
	public const string net_log_cache_valid_based_on_status_code = "Valid based on Status Code: {0}."; // Metadata: 0x0041E04E
	public const string net_log_cache_resp_no_cache_control = "Response with no CacheControl and Status Code = {0}."; // Metadata: 0x0041E072
	public const string net_log_cache_age = "Cache Age = {0}, Cache MaxAge = {1}."; // Metadata: 0x0041E0AA
	public const string net_log_cache_policy_min_fresh = "Client Policy MinFresh = {0}."; // Metadata: 0x0041E0D2
	public const string net_log_cache_policy_max_age = "Client Policy MaxAge = {0}."; // Metadata: 0x0041E0F3
	public const string net_log_cache_policy_cache_sync_date = "Client Policy CacheSyncDate (UTC) = {0}, Cache LastSynchronizedUtc = {1}."; // Metadata: 0x0041E112
	public const string net_log_cache_policy_max_stale = "Client Policy MaxStale = {0}."; // Metadata: 0x0041E15F
	public const string net_log_cache_control_no_cache = "Cached CacheControl = no-cache."; // Metadata: 0x0041E180
	public const string net_log_cache_control_no_cache_removing_some_headers = "Cached CacheControl = no-cache, Removing some headers."; // Metadata: 0x0041E1A3
	public const string net_log_cache_control_must_revalidate = "Cached CacheControl = must-revalidate and Cache is not fresh."; // Metadata: 0x0041E1DD
	public const string net_log_cache_cached_auth_header = "The cached entry has Authorization Header and cache is not fresh."; // Metadata: 0x0041E21E
	public const string net_log_cache_cached_auth_header_no_control_directive = "The cached entry has Authorization Header and no Cache-Control directive present that would allow to use that entry."; // Metadata: 0x0041E263
	public const string net_log_cache_after_validation = "After Response Cache Validation."; // Metadata: 0x0041E2DB
	public const string net_log_cache_resp_status_304 = "Response status == 304 but the cache entry does not exist."; // Metadata: 0x0041E2FF
	public const string net_log_cache_head_resp_has_different_content_length = "A response resulted from a HEAD request has different Content-Length header."; // Metadata: 0x0041E33D
	public const string net_log_cache_head_resp_has_different_content_md5 = "A response resulted from a HEAD request has different Content-MD5 header."; // Metadata: 0x0041E38D
	public const string net_log_cache_head_resp_has_different_etag = "A response resulted from a HEAD request has different ETag header."; // Metadata: 0x0041E3DA
	public const string net_log_cache_304_head_resp_has_different_last_modified = "A 304 response resulted from a HEAD request has different Last-Modified header."; // Metadata: 0x0041E420
	public const string net_log_cache_existing_entry_has_to_be_discarded = "An existing cache entry has to be discarded."; // Metadata: 0x0041E473
	public const string net_log_cache_existing_entry_should_be_discarded = "An existing cache entry should be discarded."; // Metadata: 0x0041E4A3
	public const string net_log_cache_206_resp_non_matching_entry = "A 206 Response has been received and either ETag or Last-Modified header value does not match cache entry."; // Metadata: 0x0041E4D3
	public const string net_log_cache_206_resp_starting_position_not_adjusted = "The starting position for 206 Response is not adjusted to the end of cache entry."; // Metadata: 0x0041E541
	public const string net_log_cache_combined_resp_requested = "Creation of a combined response has been requested from the cache protocol."; // Metadata: 0x0041E596
	public const string net_log_cache_updating_headers_on_304 = "Updating headers on 304 response."; // Metadata: 0x0041E5E5
	public const string net_log_cache_suppressing_headers_update_on_304 = "Suppressing cache headers update on 304, new headers don\'t add anything."; // Metadata: 0x0041E60A
	public const string net_log_cache_status_code_not_304_206 = "A Response Status Code is not 304 or 206."; // Metadata: 0x0041E656
	public const string net_log_cache_sxx_resp_cache_only = "A 5XX Response and Cache-Only like policy, serving from cache."; // Metadata: 0x0041E683
	public const string net_log_cache_sxx_resp_can_be_replaced = "A 5XX Response that can be replaced by existing cache entry."; // Metadata: 0x0041E6C5
	public const string net_log_cache_vary_header_empty = "Cache entry Vary header is empty."; // Metadata: 0x0041E705
	public const string net_log_cache_vary_header_contains_asterisks = "Cache entry Vary header contains \'*\'."; // Metadata: 0x0041E72A
	public const string net_log_cache_no_headers_in_metadata = "No request headers are found in cached metadata to test based on the cached response Vary header."; // Metadata: 0x0041E753
	public const string net_log_cache_vary_header_mismatched_count = "Vary header: Request and cache header fields count does not match, header name = {0}."; // Metadata: 0x0041E7B8
	public const string net_log_cache_vary_header_mismatched_field = "Vary header: A Cache header field mismatch the request one, header name = {0}, cache field = {1}, request field = {2}."; // Metadata: 0x0041E811
	public const string net_log_cache_vary_header_match = "All required Request headers match based on cached Vary response header."; // Metadata: 0x0041E88B
	public const string net_log_cache_range = "Request Range (not in Cache yet) = Range:{0}."; // Metadata: 0x0041E8D7
	public const string net_log_cache_range_invalid_format = "Invalid format of Request Range:{0}."; // Metadata: 0x0041E908
	public const string net_log_cache_range_not_in_cache = "Cannot serve from Cache, Range:{0}."; // Metadata: 0x0041E930
	public const string net_log_cache_range_in_cache = "Serving Request Range from cache, Range:{0}."; // Metadata: 0x0041E957
	public const string net_log_cache_partial_resp = "Serving Partial Response (206) from cache, Content-Range:{0}."; // Metadata: 0x0041E987
	public const string net_log_cache_range_request_range = "Range Request (user specified), Range: {0}."; // Metadata: 0x0041E9C8
	public const string net_log_cache_could_be_partial = "Could be a Partial Cached Response, Size = {0}, Response Content Length = {1}."; // Metadata: 0x0041E9F7
	public const string net_log_cache_condition_if_none_match = "Request Condition = If-None-Match:{0}."; // Metadata: 0x0041EA49
	public const string net_log_cache_condition_if_modified_since = "Request Condition = If-Modified-Since:{0}."; // Metadata: 0x0041EA73
	public const string net_log_cache_cannot_construct_conditional_request = "A Conditional Request cannot be constructed."; // Metadata: 0x0041EAA1
	public const string net_log_cache_cannot_construct_conditional_range_request = "A Conditional Range request cannot be constructed."; // Metadata: 0x0041EAD1
	public const string net_log_cache_entry_size_too_big = "Cached Entry Size = {0} is too big, cannot do a range request."; // Metadata: 0x0041EB07
	public const string net_log_cache_condition_if_range = "Request Condition = If-Range:{0}."; // Metadata: 0x0041EB49
	public const string net_log_cache_conditional_range_not_implemented_on_http_10 = "A Conditional Range request on Http <= 1.0 is not implemented."; // Metadata: 0x0041EB6E
	public const string net_log_cache_saving_request_headers = "Saving Request Headers, Vary: {0}."; // Metadata: 0x0041EBB0
	public const string net_log_cache_only_byte_range_implemented = "Ranges other than bytes are not implemented."; // Metadata: 0x0041EBD6
	public const string net_log_cache_multiple_complex_range_not_implemented = "Multiple/complexe ranges are not implemented."; // Metadata: 0x0041EC06
	public const string net_log_digest_hash_algorithm_not_supported = "The hash algorithm is not supported by Digest authentication: {0}."; // Metadata: 0x0041EC37
	public const string net_log_digest_qop_not_supported = "The Quality of Protection value is not supported by Digest authentication: {0}."; // Metadata: 0x0041EC7D
	public const string net_log_digest_requires_nonce = "A nonce parameter required for Digest authentication was not found or was preceded by an invalid parameter."; // Metadata: 0x0041ECD0
	public const string net_log_auth_invalid_challenge = "The challenge string is not valid for this authentication module: {0}"; // Metadata: 0x0041ED3F
	public const string net_log_unknown = "unknown"; // Metadata: 0x0041ED88
	public const string net_log_operation_returned_something = "{0} returned {1}."; // Metadata: 0x0041ED93
	public const string net_log_buffered_n_bytes = "Buffered {0} bytes."; // Metadata: 0x0041EDA8
	public const string net_log_method_equal = "Method={0}."; // Metadata: 0x0041EDBF
	public const string net_log_releasing_connection = "Releasing FTP connection#{0}."; // Metadata: 0x0041EDCE
	public const string net_log_unexpected_exception = "Unexpected exception in {0}."; // Metadata: 0x0041EDEF
	public const string net_log_server_response_error_code = "Error code {0} was received from server response."; // Metadata: 0x0041EE0F
	public const string net_log_resubmitting_request = "Resubmitting request."; // Metadata: 0x0041EE44
	public const string net_log_retrieving_localhost_exception = "An unexpected exception while retrieving the local address list: {0}."; // Metadata: 0x0041EE5D
	public const string net_log_resolved_servicepoint_may_not_be_remote_server = "A resolved ServicePoint host could be wrongly considered as a remote server."; // Metadata: 0x0041EEA6
	public const string net_log_closed_idle = "{0}#{1} - Closed as idle."; // Metadata: 0x0041EEF6
	public const string net_log_received_status_line = "Received status line: Version={0}, StatusCode={1}, StatusDescription={2}."; // Metadata: 0x0041EF13
	public const string net_log_sending_headers = "Sending headers\r\n{{\r\n{0}}}."; // Metadata: 0x0041EF60
	public const string net_log_received_headers = "Received headers\r\n{{\r\n{0}}}."; // Metadata: 0x0041EF7F
	public const string net_log_shell_expression_pattern_format_warning = "ShellServices.ShellExpression.Parse() was called with a badly formatted \'pattern\':{0}."; // Metadata: 0x0041EF9F
	public const string net_log_exception_in_callback = "Exception in callback: {0}."; // Metadata: 0x0041EFF9
	public const string net_log_sending_command = "Sending command [{0}]"; // Metadata: 0x0041F018
	public const string net_log_received_response = "Received response [{0}]"; // Metadata: 0x0041F031
	public const string net_log_socket_connected = "Created connection from {0} to {1}."; // Metadata: 0x0041F04C
	public const string net_log_socket_accepted = "Accepted connection from {0} to {1}."; // Metadata: 0x0041F073
	public const string net_log_socket_not_logged_file = "Not logging data from file: {0}."; // Metadata: 0x0041F09B
	public const string net_log_socket_connect_dnsendpoint = "Connecting to a DnsEndPoint."; // Metadata: 0x0041F0BF
	public const string MailAddressInvalidFormat = "The specified string is not in the form required for an e-mail address."; // Metadata: 0x0041F0DF
	public const string MailSubjectInvalidFormat = "The specified string is not in the form required for a subject."; // Metadata: 0x0041F12A
	public const string MailBase64InvalidCharacter = "An invalid character was found in the Base-64 stream."; // Metadata: 0x0041F16D
	public const string MailCollectionIsReadOnly = "The collection is read-only."; // Metadata: 0x0041F1A6
	public const string MailDateInvalidFormat = "The date is in an invalid format."; // Metadata: 0x0041F1C6
	public const string MailHeaderFieldAlreadyExists = "The specified singleton field already exists in the collection and cannot be added."; // Metadata: 0x0041F1EB
	public const string MailHeaderFieldInvalidCharacter = "An invalid character was found in the mail header: \'{0}\'."; // Metadata: 0x0041F242
	public const string MailHeaderFieldMalformedHeader = "The mail header is malformed."; // Metadata: 0x0041F27F
	public const string MailHeaderFieldMismatchedName = "The header name does not match this property."; // Metadata: 0x0041F2A0
	public const string MailHeaderIndexOutOfBounds = "The index value is outside the bounds of the array."; // Metadata: 0x0041F2D1
	public const string MailHeaderItemAccessorOnlySingleton = "The Item property can only be used with singleton fields."; // Metadata: 0x0041F308
	public const string MailHeaderListHasChanged = "The underlying list has been changed and the enumeration is out of date."; // Metadata: 0x0041F345
	public const string MailHeaderResetCalledBeforeEOF = "The stream should have been consumed before resetting."; // Metadata: 0x0041F391
	public const string MailHeaderTargetArrayTooSmall = "The target array is too small to contain all the headers."; // Metadata: 0x0041F3CB
	public const string MailHeaderInvalidCID = "The ContentID cannot contain a \'<\' or \'>\' character."; // Metadata: 0x0041F408
	public const string MailHostNotFound = "The SMTP host was not found."; // Metadata: 0x0041F440
	public const string MailReaderGetContentStreamAlreadyCalled = "GetContentStream() can only be called once."; // Metadata: 0x0041F460
	public const string MailReaderTruncated = "Premature end of stream."; // Metadata: 0x0041F48F
	public const string MailWriterIsInContent = "This operation cannot be performed while in content."; // Metadata: 0x0041F4AB
	public const string MailServerDoesNotSupportStartTls = "Server does not support secure connections."; // Metadata: 0x0041F4E3
	public const string MailServerResponse = "The server response was: {0}"; // Metadata: 0x0041F512
	public const string SSPIAuthenticationOrSPNNull = "AuthenticationType and ServicePrincipalName cannot be specified as null for server\'s SSPI Negotiation module."; // Metadata: 0x0041F532
	public const string SSPIPInvokeError = "{0} failed with error {1}."; // Metadata: 0x0041F5A3
	public const string SmtpAlreadyConnected = "Already connected."; // Metadata: 0x0041F5C1
	public const string SmtpAuthenticationFailed = "Authentication failed."; // Metadata: 0x0041F5D7
	public const string SmtpAuthenticationFailedNoCreds = "Authentication failed due to lack of credentials."; // Metadata: 0x0041F5F1
	public const string SmtpDataStreamOpen = "Data stream is still open."; // Metadata: 0x0041F626
	public const string SmtpDefaultMimePreamble = "This is a multi-part MIME message."; // Metadata: 0x0041F644
	public const string SmtpDefaultSubject = "@@SOAP Application Message"; // Metadata: 0x0041F66A
	public const string SmtpInvalidResponse = "Smtp server returned an invalid response."; // Metadata: 0x0041F688
	public const string SmtpNotConnected = "Not connected."; // Metadata: 0x0041F6B5
	public const string SmtpSystemStatus = "System status, or system help reply."; // Metadata: 0x0041F6C7
	public const string SmtpHelpMessage = "Help message."; // Metadata: 0x0041F6EF
	public const string SmtpServiceReady = "Service ready."; // Metadata: 0x0041F700
	public const string SmtpServiceClosingTransmissionChannel = "Service closing transmission channel."; // Metadata: 0x0041F712
	public const string SmtpOK = "Completed."; // Metadata: 0x0041F73B
	public const string SmtpUserNotLocalWillForward = "User not local; will forward to specified path."; // Metadata: 0x0041F749
	public const string SmtpStartMailInput = "Start mail input; end with <CRLF>.<CRLF>."; // Metadata: 0x0041F77C
	public const string SmtpServiceNotAvailable = "Service not available, closing transmission channel."; // Metadata: 0x0041F7A9
	public const string SmtpMailboxBusy = "Mailbox unavailable."; // Metadata: 0x0041F7E1
	public const string SmtpLocalErrorInProcessing = "Error in processing."; // Metadata: 0x0041F7F9
	public const string SmtpInsufficientStorage = "Insufficient system storage."; // Metadata: 0x0041F811
	public const string SmtpPermissionDenied = "Client does not have permission to Send As this sender."; // Metadata: 0x0041F831
	public const string SmtpCommandUnrecognized = "Syntax error, command unrecognized."; // Metadata: 0x0041F86C
	public const string SmtpSyntaxError = "Syntax error in parameters or arguments."; // Metadata: 0x0041F893
	public const string SmtpCommandNotImplemented = "Command not implemented."; // Metadata: 0x0041F8BF
	public const string SmtpBadCommandSequence = "Bad sequence of commands."; // Metadata: 0x0041F8DB
	public const string SmtpCommandParameterNotImplemented = "Command parameter not implemented."; // Metadata: 0x0041F8F8
	public const string SmtpMailboxUnavailable = "Mailbox unavailable."; // Metadata: 0x0041F91E
	public const string SmtpUserNotLocalTryAlternatePath = "User not local; please try a different path."; // Metadata: 0x0041F936
	public const string SmtpExceededStorageAllocation = "Exceeded storage allocation."; // Metadata: 0x0041F966
	public const string SmtpMailboxNameNotAllowed = "Mailbox name not allowed."; // Metadata: 0x0041F986
	public const string SmtpTransactionFailed = "Transaction failed."; // Metadata: 0x0041F9A3
	public const string SmtpSendMailFailure = "Failure sending mail."; // Metadata: 0x0041F9BA
	public const string SmtpRecipientFailed = "Unable to send to a recipient."; // Metadata: 0x0041F9D3
	public const string SmtpRecipientRequired = "A recipient must be specified."; // Metadata: 0x0041F9F5
	public const string SmtpFromRequired = "A from address must be specified."; // Metadata: 0x0041FA17
	public const string SmtpAllRecipientsFailed = "Unable to send to all recipients."; // Metadata: 0x0041FA3C
	public const string SmtpClientNotPermitted = "Client does not have permission to submit mail to this server."; // Metadata: 0x0041FA61
	public const string SmtpMustIssueStartTlsFirst = "The SMTP server requires a secure connection or the client was not authenticated."; // Metadata: 0x0041FAA3
	public const string SmtpNeedAbsolutePickupDirectory = "Only absolute directories are allowed for pickup directory."; // Metadata: 0x0041FAF8
	public const string SmtpGetIisPickupDirectoryFailed = "Cannot get IIS pickup directory."; // Metadata: 0x0041FB37
	public const string SmtpPickupDirectoryDoesnotSupportSsl = "SSL must not be enabled for pickup-directory delivery methods."; // Metadata: 0x0041FB5B
	public const string SmtpOperationInProgress = "Previous operation is still in progress."; // Metadata: 0x0041FB9D
	public const string SmtpAuthResponseInvalid = "The server returned an invalid response in the authentication handshake."; // Metadata: 0x0041FBC9
	public const string SmtpEhloResponseInvalid = "The server returned an invalid response to the EHLO command."; // Metadata: 0x0041FC15
	public const string SmtpNonAsciiUserNotSupported = "The client or server is only configured for E-mail addresses with ASCII local-parts: {0}."; // Metadata: 0x0041FC55
	public const string SmtpInvalidHostName = "The address has an invalid host name: {0}."; // Metadata: 0x0041FCB2
	public const string MimeTransferEncodingNotSupported = "The MIME transfer encoding \'{0}\' is not supported."; // Metadata: 0x0041FCE0
	public const string SeekNotSupported = "Seeking is not supported on this stream."; // Metadata: 0x0041FD16
	public const string WriteNotSupported = "Writing is not supported on this stream."; // Metadata: 0x0041FD42
	public const string InvalidHexDigit = "Invalid hex digit \'{0}\'."; // Metadata: 0x0041FD6E
	public const string InvalidSSPIContext = "The SSPI context is not valid."; // Metadata: 0x0041FD8A
	public const string InvalidSSPIContextKey = "A null session key was obtained from SSPI."; // Metadata: 0x0041FDAC
	public const string InvalidSSPINegotiationElement = "Invalid SSPI BinaryNegotiationElement."; // Metadata: 0x0041FDDA
	public const string InvalidHeaderName = "An invalid character was found in header name."; // Metadata: 0x0041FE04
	public const string InvalidHeaderValue = "An invalid character was found in header value."; // Metadata: 0x0041FE36
	public const string CannotGetEffectiveTimeOfSSPIContext = "Cannot get the effective time of the SSPI context."; // Metadata: 0x0041FE69
	public const string CannotGetExpiryTimeOfSSPIContext = "Cannot get the expiry time of the SSPI context."; // Metadata: 0x0041FE9F
	public const string ReadNotSupported = "Reading is not supported on this stream."; // Metadata: 0x0041FED2
	public const string InvalidAsyncResult = "The AsyncResult is not valid."; // Metadata: 0x0041FEFE
	public const string UnspecifiedHost = "The SMTP host was not specified."; // Metadata: 0x0041FF1F
	public const string InvalidPort = "The specified port is invalid. The port must be greater than 0."; // Metadata: 0x0041FF43
	public const string SmtpInvalidOperationDuringSend = "This operation cannot be performed while a message is being sent."; // Metadata: 0x0041FF86
	public const string MimePartCantResetStream = "One of the streams has already been used and can\'t be reset to the origin."; // Metadata: 0x0041FFCB
	public const string MediaTypeInvalid = "The specified media type is invalid."; // Metadata: 0x00420019
	public const string ContentTypeInvalid = "The specified content type is invalid."; // Metadata: 0x00420041
	public const string ContentDispositionInvalid = "The specified content disposition is invalid."; // Metadata: 0x0042006B
	public const string AttributeNotSupported = "\'{0}\' is not a valid configuration attribute for type \'{1}\'."; // Metadata: 0x0042009C
	public const string Cannot_remove_with_null = "Cannot remove with null name."; // Metadata: 0x004200DC
	public const string Config_base_elements_only = "Only elements allowed."; // Metadata: 0x004200FD
	public const string Config_base_no_child_nodes = "Child nodes not allowed."; // Metadata: 0x00420117
	public const string Config_base_required_attribute_empty = "Required attribute \'{0}\' cannot be empty."; // Metadata: 0x00420133
	public const string Config_base_required_attribute_missing = "Required attribute \'{0}\' not found."; // Metadata: 0x00420160
	public const string Config_base_time_overflow = "The time span for the property \'{0}\' exceeds the maximum that can be stored in the configuration."; // Metadata: 0x00420187
	public const string Config_base_type_must_be_configurationvalidation = "The ConfigurationValidation attribute must be derived from ConfigurationValidation."; // Metadata: 0x004201EC
	public const string Config_base_type_must_be_typeconverter = "The ConfigurationPropertyConverter attribute must be derived from TypeConverter."; // Metadata: 0x00420243
	public const string Config_base_unknown_format = "Unknown"; // Metadata: 0x00420297
	public const string Config_base_unrecognized_attribute = "Unrecognized attribute \'{0}\'. Note that attribute names are case-sensitive."; // Metadata: 0x004202A2
	public const string Config_base_unrecognized_element = "Unrecognized element."; // Metadata: 0x004202F1
	public const string Config_invalid_boolean_attribute = "The property \'{0}\' must have value \'true\' or \'false\'."; // Metadata: 0x0042030A
	public const string Config_invalid_integer_attribute = "The \'{0}\' attribute must be set to an integer value."; // Metadata: 0x00420343
	public const string Config_invalid_positive_integer_attribute = "The \'{0}\' attribute must be set to a positive integer value."; // Metadata: 0x0042037B
	public const string Config_invalid_type_attribute = "The \'{0}\' attribute must be set to a valid Type name."; // Metadata: 0x004203BB
	public const string Config_missing_required_attribute = "The \'{0}\' attribute must be specified on the \'{1}\' tag."; // Metadata: 0x004203F4
	public const string Config_name_value_file_section_file_invalid_root = "The root element must match the name of the section referencing the file, \'{0}\'"; // Metadata: 0x0042042F
	public const string Config_provider_must_implement_type = "Provider must implement the class \'{0}\'."; // Metadata: 0x00420482
	public const string Config_provider_name_null_or_empty = "Provider name cannot be null or empty."; // Metadata: 0x004204AE
	public const string Config_provider_not_found = "The provider was not found in the collection."; // Metadata: 0x004204D8
	public const string Config_property_name_cannot_be_empty = "Property \'{0}\' cannot be empty or null."; // Metadata: 0x00420509
	public const string Config_section_cannot_clear_locked_section = "Cannot clear section handlers.  Section \'{0}\' is locked."; // Metadata: 0x00420534
	public const string Config_section_record_not_found = "SectionRecord not found."; // Metadata: 0x00420570
	public const string Config_source_cannot_contain_file = "The \'File\' property cannot be used with the ConfigSource property."; // Metadata: 0x0042058C
	public const string Config_system_already_set = "The configuration system can only be set once.  Configuration system is already set"; // Metadata: 0x004205D2
	public const string Config_unable_to_read_security_policy = "Unable to read security policy."; // Metadata: 0x00420629
	public const string Config_write_xml_returned_null = "WriteXml returned null."; // Metadata: 0x0042064C
	public const string Cannot_clear_sections_within_group = "Server cannot clear configuration sections from within section groups.  <clear/> must be a child of <configSections>."; // Metadata: 0x00420667
	public const string Cannot_exit_up_top_directory = "Cannot use a leading .. to exit above the top directory."; // Metadata: 0x004206E0
	public const string Could_not_create_listener = "Couldn\'t create listener \'{0}\'."; // Metadata: 0x0042071C
	public const string TL_InitializeData_NotSpecified = "initializeData needs to be valid for this TraceListener."; // Metadata: 0x0042073F
	public const string Could_not_create_type_instance = "Could not create {0}."; // Metadata: 0x0042077B
	public const string Could_not_find_type = "Couldn\'t find type for class {0}."; // Metadata: 0x00420794
	public const string Could_not_get_constructor = "Couldn\'t find constructor for class {0}."; // Metadata: 0x004207B9
	public const string EmptyTypeName_NotAllowed = "switchType needs to be a valid class name. It can\'t be empty."; // Metadata: 0x004207E5
	public const string Incorrect_base_type = "The specified type, \'{0}\' is not derived from the appropriate base type, \'{1}\'."; // Metadata: 0x00420826
	public const string Only_specify_one = "\'switchValue\' and \'switchName\' cannot both be specified on source \'{0}\'."; // Metadata: 0x00420879
	public const string Provider_Already_Initialized = "This provider instance has already been initialized."; // Metadata: 0x004208C5
	public const string Reference_listener_cant_have_properties = "A listener with no type name specified references the sharedListeners section and cannot have any attributes other than \'Name\'.  Listener: \'{0}\'."; // Metadata: 0x004208FD
	public const string Reference_to_nonexistent_listener = "Listener \'{0}\' does not exist in the sharedListeners section."; // Metadata: 0x00420992
	public const string SettingsPropertyNotFound = "The settings property \'{0}\' was not found."; // Metadata: 0x004209D3
	public const string SettingsPropertyReadOnly = "The settings property \'{0}\' is read-only."; // Metadata: 0x00420A01
	public const string SettingsPropertyWrongType = "The settings property \'{0}\' is of a non-compatible type."; // Metadata: 0x00420A2E
	public const string Type_isnt_tracelistener = "Could not add trace listener {0} because it is not a subclass of TraceListener."; // Metadata: 0x00420A6A
	public const string Unable_to_convert_type_from_string = "Could not find a type-converter to convert object if type \'{0}\' from string."; // Metadata: 0x00420ABD
	public const string Unable_to_convert_type_to_string = "Could not find a type-converter to convert object if type \'{0}\' to string."; // Metadata: 0x00420B0D
	public const string Value_must_be_numeric = "Error in trace switch \'{0}\': The value of a switch must be integral."; // Metadata: 0x00420B5B
	public const string Could_not_create_from_default_value = "The property \'{0}\' could not be created from it\'s default value. Error message: {1}"; // Metadata: 0x00420BA3
	public const string Could_not_create_from_default_value_2 = "The property \'{0}\' could not be created from it\'s default value because the default value is of a different type."; // Metadata: 0x00420BFA
	public const string InvalidDirName = "The directory name {0} is invalid."; // Metadata: 0x00420C6F
	public const string FSW_IOError = "Error reading the {0} directory."; // Metadata: 0x00420C95
	public const string PatternInvalidChar = "The character \'{0}\' in the pattern provided is not valid."; // Metadata: 0x00420CB9
	public const string BufferSizeTooLarge = "The specified buffer size is too large. FileSystemWatcher cannot allocate {0} bytes for the internal buffer."; // Metadata: 0x00420CF6
	public const string FSW_ChangedFilter = "Flag to indicate which change event to monitor."; // Metadata: 0x00420D66
	public const string FSW_Enabled = "Flag to indicate whether this component is active or not."; // Metadata: 0x00420D99
	public const string FSW_Filter = "The file pattern filter."; // Metadata: 0x00420DD6
	public const string FSW_IncludeSubdirectories = "Flag to watch subdirectories."; // Metadata: 0x00420DF2
	public const string FSW_Path = "The path to the directory to monitor."; // Metadata: 0x00420E13
	public const string FSW_SynchronizingObject = "The object used to marshal the event handler calls issued as a result of a Directory change."; // Metadata: 0x00420E3C
	public const string FSW_Changed = "Occurs when a file and/or directory change matches the filter."; // Metadata: 0x00420E9C
	public const string FSW_Created = "Occurs when a file and/or directory creation matches the filter."; // Metadata: 0x00420EDE
	public const string FSW_Deleted = "Occurs when a file and/or directory deletion matches the filter."; // Metadata: 0x00420F22
	public const string FSW_Renamed = "Occurs when a file and/or directory rename matches the filter."; // Metadata: 0x00420F66
	public const string FSW_BufferOverflow = "Too many changes at once in directory:{0}."; // Metadata: 0x00420FA8
	public const string FileSystemWatcherDesc = "Monitors file system change notifications and raises events when a directory or file changes."; // Metadata: 0x00420FD6
	public const string NotSet = "[Not Set]"; // Metadata: 0x00421037
	public const string TimerAutoReset = "Indicates whether the timer will be restarted when it is enabled."; // Metadata: 0x00421044
	public const string TimerEnabled = "Indicates whether the timer is enabled to fire events at a defined interval."; // Metadata: 0x00421089
	public const string TimerInterval = "The number of milliseconds between timer events."; // Metadata: 0x004210D9
	public const string TimerIntervalElapsed = "Occurs when the Interval has elapsed."; // Metadata: 0x0042110D
	public const string TimerSynchronizingObject = "The object used to marshal the event handler calls issued when an interval has elapsed."; // Metadata: 0x00421136
	public const string MismatchedCounterTypes = "Mismatched counter types."; // Metadata: 0x00421191
	public const string NoPropertyForAttribute = "Could not find a property for the attribute \'{0}\'."; // Metadata: 0x004211AE
	public const string InvalidAttributeType = "The value of attribute \'{0}\' could not be converted to the proper type."; // Metadata: 0x004211E4
	public const string Generic_ArgCantBeEmptyString = "\'{0}\' can not be empty string."; // Metadata: 0x0042122F
	public const string BadLogName = "Event log names must consist of printable characters and cannot contain \\, *, ?, or spaces"; // Metadata: 0x00421251
	public const string InvalidProperty = "Invalid value {1} for property {0}."; // Metadata: 0x004212AF
	public const string CantMonitorEventLog = "Cannot monitor EntryWritten events for this EventLog. This might be because the EventLog is on a remote machine which is not a supported scenario."; // Metadata: 0x004212D6
	public const string InitTwice = "Cannot initialize the same object twice."; // Metadata: 0x0042136C
	public const string InvalidParameter = "Invalid value \'{1}\' for parameter \'{0}\'."; // Metadata: 0x00421398
	public const string MissingParameter = "Must specify value for {0}."; // Metadata: 0x004213C4
	public const string ParameterTooLong = "The size of {0} is too big. It cannot be longer than {1} characters."; // Metadata: 0x004213E3
	public const string LocalSourceAlreadyExists = "Source {0} already exists on the local computer."; // Metadata: 0x0042142B
	public const string SourceAlreadyExists = "Source {0} already exists on the computer \'{1}\'."; // Metadata: 0x0042145F
	public const string LocalLogAlreadyExistsAsSource = "Log {0} has already been registered as a source on the local computer."; // Metadata: 0x00421493
	public const string LogAlreadyExistsAsSource = "Log {0} has already been registered as a source on the computer \'{1}\'."; // Metadata: 0x004214DD
	public const string DuplicateLogName = "Only the first eight characters of a custom log name are significant, and there is already another log on the system using the first eight characters of the name given. Name given: \'{0}\', name of existing log: \'{1}\'."; // Metadata: 0x00421527
	public const string RegKeyMissing = "Cannot open registry key {0}\\{1}\\{2} on computer \'{3}\'."; // Metadata: 0x00421603
	public const string LocalRegKeyMissing = "Cannot open registry key {0}\\{1}\\{2}."; // Metadata: 0x0042163E
	public const string RegKeyMissingShort = "Cannot open registry key {0} on computer {1}."; // Metadata: 0x00421667
	public const string InvalidParameterFormat = "Invalid format for argument {0}."; // Metadata: 0x00421698
	public const string NoLogName = "Log to delete was not specified."; // Metadata: 0x004216BC
	public const string RegKeyNoAccess = "Cannot open registry key {0} on computer {1}. You might not have access."; // Metadata: 0x004216E0
	public const string MissingLog = "Cannot find Log {0} on computer \'{1}\'."; // Metadata: 0x0042172C
	public const string SourceNotRegistered = "The source \'{0}\' is not registered on machine \'{1}\', or you do not have write access to the {2} registry key."; // Metadata: 0x00421756
	public const string LocalSourceNotRegistered = "Source {0} is not registered on the local computer."; // Metadata: 0x004217C7
	public const string CantRetrieveEntries = "Cannot retrieve all entries."; // Metadata: 0x004217FE
	public const string IndexOutOfBounds = "Index {0} is out of bounds."; // Metadata: 0x0042181E
	public const string CantReadLogEntryAt = "Cannot read log entry number {0}.  The event log may be corrupt."; // Metadata: 0x0042183D
	public const string MissingLogProperty = "Log property value has not been specified."; // Metadata: 0x00421881
	public const string CantOpenLog = "Cannot open log {0} on machine {1}. Windows has not provided an error code."; // Metadata: 0x004218AF
	public const string NeedSourceToOpen = "Source property was not set before opening the event log in write mode."; // Metadata: 0x004218FE
	public const string NeedSourceToWrite = "Source property was not set before writing to the event log."; // Metadata: 0x00421949
	public const string CantOpenLogAccess = "Cannot open log for source \'{0}\'. You may not have write access."; // Metadata: 0x00421989
	public const string LogEntryTooLong = "Log entry string is too long. A string written to the event log cannot exceed 32766 characters."; // Metadata: 0x004219CD
	public const string TooManyReplacementStrings = "The maximum allowed number of replacement strings is 255."; // Metadata: 0x00421A30
	public const string LogSourceMismatch = "The source \'{0}\' is not registered in log \'{1}\'. (It is registered in log \'{2}\'.) \" The Source and Log properties must be matched, or you may set Log to the empty string, and it will automatically be matched to the Source property."; // Metadata: 0x00421A6D
	public const string NoAccountInfo = "Cannot obtain account information."; // Metadata: 0x00421B58
	public const string NoCurrentEntry = "No current EventLog entry available, cursor is located before the first or after the last element of the enumeration."; // Metadata: 0x00421B7E
	public const string MessageNotFormatted = "The description for Event ID \'{0}\' in Source \'{1}\' cannot be found.  The local computer may not have the necessary registry information or message DLL files to display the message, or you may not have permission to access them.  The following information is part of the event:"; // Metadata: 0x00421BF7
	public const string EventID = "Invalid eventID value \'{0}\'. It must be in the range between \'{1}\' and \'{2}\'."; // Metadata: 0x00421D0F
	public const string LogDoesNotExists = "The event log \'{0}\' on computer \'{1}\' does not exist."; // Metadata: 0x00421D60
	public const string InvalidCustomerLogName = "The log name: \'{0}\' is invalid for customer log creation."; // Metadata: 0x00421D99
	public const string CannotDeleteEqualSource = "The event log source \'{0}\' cannot be deleted, because it\'s equal to the log name."; // Metadata: 0x00421DD6
	public const string RentionDaysOutOfRange = "\'retentionDays\' must be between 1 and 365 days."; // Metadata: 0x00421E2B
	public const string MaximumKilobytesOutOfRange = "MaximumKilobytes must be between 64 KB and 4 GB, and must be in 64K increments."; // Metadata: 0x00421E5E
	public const string SomeLogsInaccessible = "The source was not found, but some or all event logs could not be searched.  Inaccessible logs: {0}."; // Metadata: 0x00421EB1
	public const string SomeLogsInaccessibleToCreate = "The source was not found, but some or all event logs could not be searched.  To create the source, you need permission to read all event logs to make sure that the new source name is unique.  Inaccessible logs: {0}."; // Metadata: 0x00421F19
	public const string BadConfigSwitchValue = "The config value for Switch \'{0}\' was invalid."; // Metadata: 0x00421FF4
	public const string ConfigSectionsUnique = "The \'{0}\' section can only appear once per config file."; // Metadata: 0x00422026
	public const string ConfigSectionsUniquePerSection = "The \'{0}\' tag can only appear once per section."; // Metadata: 0x00422061
	public const string SourceListenerDoesntExist = "The listener \'{0}\' added to source \'{1}\' must have a listener with the same name defined in the main Trace listeners section."; // Metadata: 0x00422094
	public const string SourceSwitchDoesntExist = "The source \'{0}\' must have a switch with the same name defined in the Switches section."; // Metadata: 0x00422115
	public const string CategoryHelpCorrupt = "Cannot load Category Help data because an invalid index \'{0}\' was read from the registry."; // Metadata: 0x00422170
	public const string CounterNameCorrupt = "Cannot load Counter Name data because an invalid index \'{0}\' was read from the registry."; // Metadata: 0x004221CD
	public const string CounterDataCorrupt = "Cannot load Performance Counter data because an unexpected registry key value type was read from \'{0}\'."; // Metadata: 0x00422229
	public const string ReadOnlyCounter = "Cannot update Performance Counter, this object has been initialized as ReadOnly."; // Metadata: 0x00422294
	public const string ReadOnlyRemoveInstance = "Cannot remove Performance Counter Instance, this object as been initialized as ReadOnly."; // Metadata: 0x004222E8
	public const string NotCustomCounter = "The requested Performance Counter is not a custom counter, it has to be initialized as ReadOnly."; // Metadata: 0x00422344
	public const string CategoryNameMissing = "Failed to initialize because CategoryName is missing."; // Metadata: 0x004223A8
	public const string CounterNameMissing = "Failed to initialize because CounterName is missing."; // Metadata: 0x004223E1
	public const string InstanceNameProhibited = "Counter is single instance, instance name \'{0}\' is not valid for this counter category."; // Metadata: 0x00422419
	public const string InstanceNameRequired = "Counter is not single instance, an instance name needs to be specified."; // Metadata: 0x00422474
	public const string MissingInstance = "Instance {0} does not exist in category {1}."; // Metadata: 0x004224BF
	public const string PerformanceCategoryExists = "Cannot create Performance Category \'{0}\' because it already exists."; // Metadata: 0x004224EF
	public const string InvalidCounterName = "Invalid empty or null string for counter name."; // Metadata: 0x00422536
	public const string DuplicateCounterName = "Cannot create Performance Category with counter name {0} because the name is a duplicate."; // Metadata: 0x00422568
	public const string CantChangeCategoryRegistration = "Cannot create or delete the Performance Category \'{0}\' because access is denied."; // Metadata: 0x004225C5
	public const string CantDeleteCategory = "Cannot delete Performance Category because this category is not registered or is a system category."; // Metadata: 0x00422619
	public const string MissingCategory = "Category does not exist."; // Metadata: 0x00422680
	public const string MissingCategoryDetail = "Category {0} does not exist."; // Metadata: 0x0042269C
	public const string CantReadCategory = "Cannot read Category {0}."; // Metadata: 0x004226BC
	public const string MissingCounter = "Counter {0} does not exist."; // Metadata: 0x004226D9
	public const string CategoryNameNotSet = "Category name property has not been set."; // Metadata: 0x004226F8
	public const string CounterExists = "Could not locate Performance Counter with specified category name \'{0}\', counter name \'{1}\'."; // Metadata: 0x00422724
	public const string CantReadCategoryIndex = "Could not Read Category Index: {0}."; // Metadata: 0x00422784
	public const string CantReadCounter = "Counter \'{0}\' does not exist in the specified Category."; // Metadata: 0x004227AB
	public const string CantReadInstance = "Instance \'{0}\' does not exist in the specified Category."; // Metadata: 0x004227E6
	public const string RemoteWriting = "Cannot write to a Performance Counter in a remote machine."; // Metadata: 0x00422822
	public const string CounterLayout = "The Counter layout for the Category specified is invalid, a counter of the type:  AverageCount64, AverageTimer32, CounterMultiTimer, CounterMultiTimerInverse, CounterMultiTimer100Ns, CounterMultiTimer100NsInverse, RawFraction, or SampleFraction has to be immediately followed by any of the base counter types: AverageBase, CounterMultiBase, RawBase or SampleBase."; // Metadata: 0x00422860
	public const string PossibleDeadlock = "The operation couldn\'t be completed, potential internal deadlock."; // Metadata: 0x004229CF
	public const string SharedMemoryGhosted = "Cannot access shared memory, AppDomain has been unloaded."; // Metadata: 0x00422A14
	public const string HelpNotAvailable = "Help not available."; // Metadata: 0x00422A51
	public const string PerfInvalidHelp = "Invalid help string. Its length must be in the range between \'{0}\' and \'{1}\'."; // Metadata: 0x00422A68
	public const string PerfInvalidCounterName = "Invalid counter name. Its length must be in the range between \'{0}\' and \'{1}\'. Double quotes, control characters and leading or trailing spaces are not allowed."; // Metadata: 0x00422AB9
	public const string PerfInvalidCategoryName = "Invalid category name. Its length must be in the range between \'{0}\' and \'{1}\'. Double quotes, control characters and leading or trailing spaces are not allowed."; // Metadata: 0x00422B5D
	public const string MustAddCounterCreationData = "Only objects of type CounterCreationData can be added to a CounterCreationDataCollection."; // Metadata: 0x00422C02
	public const string RemoteCounterAdmin = "Creating or Deleting Performance Counter Categories on remote machines is not supported."; // Metadata: 0x00422C5F
	public const string NoInstanceInformation = "The {0} category doesn\'t provide any instance information, no accurate data can be returned."; // Metadata: 0x00422CBB
	public const string PerfCounterPdhError = "There was an error calculating the PerformanceCounter value (0x{0})."; // Metadata: 0x00422D1B
	public const string MultiInstanceOnly = "Category \'{0}\' is marked as multi-instance.  Performance counters in this category can only be created with instance names."; // Metadata: 0x00422D63
	public const string SingleInstanceOnly = "Category \'{0}\' is marked as single-instance.  Performance counters in this category can only be created without instance names."; // Metadata: 0x00422DE2
	public const string InstanceNameTooLong = "Instance names used for writing to custom counters must be 127 characters or less."; // Metadata: 0x00422E65
	public const string CategoryNameTooLong = "Category names must be 1024 characters or less."; // Metadata: 0x00422EBB
	public const string InstanceLifetimeProcessonReadOnly = "InstanceLifetime is unused by ReadOnly counters."; // Metadata: 0x00422EEE
	public const string InstanceLifetimeProcessforSingleInstance = "Single instance categories are only valid with the Global lifetime."; // Metadata: 0x00422F22
	public const string InstanceAlreadyExists = "Instance \'{0}\' already exists with a lifetime of Process.  It cannot be recreated or reused until it has been removed or until the process using it has exited."; // Metadata: 0x00422F69
	public const string CantSetLifetimeAfterInitialized = "The InstanceLifetime cannot be set after the instance has been initialized.  You must use the default constructor and set the CategoryName, InstanceName, CounterName, InstanceLifetime and ReadOnly properties manually before setting the RawValue."; // Metadata: 0x0042300C
	public const string ProcessLifetimeNotValidInGlobal = "PerformanceCounterInstanceLifetime.Process is not valid in the global shared memory.  If your performance counter category was created with an older version of the Framework, it uses the global shared memory.  Either use PerformanceCounterInstanceLifetime.Global, or if applications running on older versions of the Framework do not need to write to your category, delete and recreate it."; // Metadata: 0x00423105
	public const string CantConvertProcessToGlobal = "An instance with a lifetime of Process can only be accessed from a PerformanceCounter with the InstanceLifetime set to PerformanceCounterInstanceLifetime.Process."; // Metadata: 0x0042328D
	public const string CantConvertGlobalToProcess = "An instance with a lifetime of Global can only be accessed from a PerformanceCounter with the InstanceLifetime set to PerformanceCounterInstanceLifetime.Global."; // Metadata: 0x00423333
	public const string PCNotSupportedUnderAppContainer = "Writeable performance counters are not allowed when running in AppContainer."; // Metadata: 0x004233D7
	public const string PriorityClassNotSupported = "The AboveNormal and BelowNormal priority classes are not available on this platform."; // Metadata: 0x00423427
	public const string WinNTRequired = "Feature requires Windows NT."; // Metadata: 0x0042347F
	public const string Win2kRequired = "Feature requires Windows 2000."; // Metadata: 0x0042349F
	public const string NoAssociatedProcess = "No process is associated with this object."; // Metadata: 0x004234C1
	public const string ProcessIdRequired = "Feature requires a process identifier."; // Metadata: 0x004234EF
	public const string NotSupportedRemote = "Feature is not supported for remote machines."; // Metadata: 0x00423519
	public const string NoProcessInfo = "Process has exited, so the requested information is not available."; // Metadata: 0x0042354A
	public const string WaitTillExit = "Process must exit before requested information can be determined."; // Metadata: 0x00423590
	public const string NoProcessHandle = "Process was not started by this object, so requested information cannot be determined."; // Metadata: 0x004235D5
	public const string MissingProccess = "Process with an Id of {0} is not running."; // Metadata: 0x0042362F
	public const string BadMinWorkset = "Minimum working set size is invalid. It must be less than or equal to the maximum working set size."; // Metadata: 0x0042365C
	public const string BadMaxWorkset = "Maximum working set size is invalid. It must be greater than or equal to the minimum working set size."; // Metadata: 0x004236C3
	public const string WinNTRequiredForRemote = "Operating system does not support accessing processes on remote computers. This feature requires Windows NT or later."; // Metadata: 0x0042372D
	public const string ProcessHasExited = "Cannot process request because the process ({0}) has exited."; // Metadata: 0x004237A6
	public const string ProcessHasExitedNoId = "Cannot process request because the process has exited."; // Metadata: 0x004237E6
	public const string ThreadExited = "The request cannot be processed because the thread ({0}) has exited."; // Metadata: 0x00423820
	public const string Win2000Required = "Feature requires Windows 2000 or later."; // Metadata: 0x00423868
	public const string ProcessNotFound = "Thread {0} found, but no process {1} found."; // Metadata: 0x00423893
	public const string CantGetProcessId = "Cannot retrieve process identifier from the process handle."; // Metadata: 0x004238C2
	public const string ProcessDisabled = "Process performance counter is disabled, so the requested operation cannot be performed."; // Metadata: 0x00423901
	public const string WaitReasonUnavailable = "WaitReason is only available if the ThreadState is Wait."; // Metadata: 0x0042395D
	public const string NotSupportedRemoteThread = "Feature is not supported for threads on remote computers."; // Metadata: 0x00423999
	public const string UseShellExecuteRequiresSTA = "Current thread is not in Single Thread Apartment (STA) mode. Starting a process with UseShellExecute set to True requires the current thread be in STA mode.  Ensure that your Main function has STAThreadAttribute marked."; // Metadata: 0x004239D6
	public const string CantRedirectStreams = "The Process object must have the UseShellExecute property set to false in order to redirect IO streams."; // Metadata: 0x00423AB5
	public const string CantUseEnvVars = "The Process object must have the UseShellExecute property set to false in order to use environment variables."; // Metadata: 0x00423B20
	public const string CantStartAsUser = "The Process object must have the UseShellExecute property set to false in order to start a process as a user."; // Metadata: 0x00423B91
	public const string CouldntConnectToRemoteMachine = "Couldn\'t connect to remote machine."; // Metadata: 0x00423C02
	public const string CouldntGetProcessInfos = "Couldn\'t get process information from performance counter."; // Metadata: 0x00423C29
	public const string InputIdleUnkownError = "WaitForInputIdle failed.  This could be because the process does not have a graphical interface."; // Metadata: 0x00423C67
	public const string FileNameMissing = "Cannot start process because a file name has not been provided."; // Metadata: 0x00423CCB
	public const string EnvironmentBlock = "The environment block provided doesn\'t have the correct format."; // Metadata: 0x00423D0E
	public const string EnumProcessModuleFailed = "Unable to enumerate the process modules."; // Metadata: 0x00423D51
	public const string EnumProcessModuleFailedDueToWow = "A 32 bit processes cannot access modules of a 64 bit process."; // Metadata: 0x00423D7D
	public const string PendingAsyncOperation = "An async read operation has already been started on the stream."; // Metadata: 0x00423DBE
	public const string NoAsyncOperation = "No async read operation is in progress on the stream."; // Metadata: 0x00423E01
	public const string InvalidApplication = "The specified executable is not a valid application for this OS platform."; // Metadata: 0x00423E3A
	public const string StandardOutputEncodingNotAllowed = "StandardOutputEncoding is only supported when standard output is redirected."; // Metadata: 0x00423E87
	public const string StandardErrorEncodingNotAllowed = "StandardErrorEncoding is only supported when standard error is redirected."; // Metadata: 0x00423ED7
	public const string CountersOOM = "Custom counters file view is out of memory."; // Metadata: 0x00423F25
	public const string MappingCorrupted = "Cannot continue the current operation, the performance counters memory mapping has been corrupted."; // Metadata: 0x00423F54
	public const string SetSecurityDescriptorFailed = "Cannot initialize security descriptor initialized."; // Metadata: 0x00423FBA
	public const string CantCreateFileMapping = "Cannot create file mapping."; // Metadata: 0x00423FF0
	public const string CantMapFileView = "Cannot map view of file."; // Metadata: 0x0042400F
	public const string CantGetMappingSize = "Cannot calculate the size of the file view."; // Metadata: 0x0042402B
	public const string CantGetStandardOut = "StandardOut has not been redirected or the process hasn\'t started yet."; // Metadata: 0x0042405A
	public const string CantGetStandardIn = "StandardIn has not been redirected."; // Metadata: 0x004240A4
	public const string CantGetStandardError = "StandardError has not been redirected."; // Metadata: 0x004240CB
	public const string CantMixSyncAsyncOperation = "Cannot mix synchronous and asynchronous operation on process stream."; // Metadata: 0x004240F5
	public const string NoFileMappingSize = "Cannot retrieve file mapping size while initializing configuration settings."; // Metadata: 0x0042413D
	public const string EnvironmentBlockTooLong = "The environment block used to start a process cannot be longer than 65535 bytes.  Your environment block is {0} bytes long.  Remove some environment variables and try again."; // Metadata: 0x0042418D
	public const string Arg_SecurityException = "The port name cannot start with \'\\\'."; // Metadata: 0x0042423E
	public const string ArgumentNull_Array = "Array cannot be null."; // Metadata: 0x00424266
	public const string ArgumentNull_Buffer = "Buffer cannot be null."; // Metadata: 0x0042427F
	public const string IO_UnknownError = "Unknown Error \'{0}\'."; // Metadata: 0x00424299
	public const string NotSupported_UnwritableStream = "Stream does not support writing."; // Metadata: 0x004242B1
	public const string ObjectDisposed_WriterClosed = "Can not write to a closed TextWriter."; // Metadata: 0x004242D5
	public const string NotSupportedOS = "GetPortNames is not supported on Win9x platforms."; // Metadata: 0x004242FE
	public const string BaudRate = "The baud rate to use on this serial port."; // Metadata: 0x00424333
	public const string DataBits = "The number of data bits per transmitted/received byte."; // Metadata: 0x00424360
	public const string DiscardNull = "Whether to discard null bytes received on the port before adding to serial buffer."; // Metadata: 0x0042439A
	public const string DtrEnable = "Whether to enable the Data Terminal Ready (DTR) line during communications."; // Metadata: 0x004243F0
	public const string EncodingMonitoringDescription = "The encoding to use when reading and writing strings."; // Metadata: 0x0042443F
	public const string Handshake = "The handshaking protocol for flow control in data exchange, which can be None."; // Metadata: 0x00424478
	public const string NewLine = "The string used by ReadLine and WriteLine to denote a new line."; // Metadata: 0x004244CA
	public const string Parity = "The scheme for parity checking each received byte and marking each transmitted byte."; // Metadata: 0x0042450D
	public const string ParityReplace = "Byte with which to replace bytes received with parity errors."; // Metadata: 0x00424565
	public const string PortName = "The name of the communications port to open."; // Metadata: 0x004245A6
	public const string ReadBufferSize = "The size of the read buffer in bytes.  This is the maximum number of read bytes which can be buffered."; // Metadata: 0x004245D6
	public const string ReadTimeout = "The read timeout in Milliseconds."; // Metadata: 0x00424640
	public const string ReceivedBytesThreshold = "Number of bytes required to be available before the Read event is fired."; // Metadata: 0x00424665
	public const string RtsEnable = "Whether to enable the Request To Send (RTS) line during communications."; // Metadata: 0x004246B1
	public const string SerialPortDesc = "Represents a serial port resource."; // Metadata: 0x004246FC
	public const string StopBits = "The number of stop bits per transmitted/received byte."; // Metadata: 0x00424722
	public const string WriteBufferSize = "The size of the write buffer in bytes.  This is the maximum number of bytes which can be queued for write."; // Metadata: 0x0042475C
	public const string WriteTimeout = "The write timeout in milliseconds."; // Metadata: 0x004247CA
	public const string SerialErrorReceived = "Raised each time when an error is received from the SerialPort."; // Metadata: 0x004247F0
	public const string SerialPinChanged = "Raised each time when pin is changed on the SerialPort."; // Metadata: 0x00424833
	public const string SerialDataReceived = "Raised each time when data is received from the SerialPort."; // Metadata: 0x0042486E
	public const string CounterType = "The type of this counter."; // Metadata: 0x004248AD
	public const string CounterName = "The name of this counter."; // Metadata: 0x004248CA
	public const string CounterHelp = "Help information for this counter."; // Metadata: 0x004248E7
	public const string EventLogDesc = "Provides interaction with Windows event logs."; // Metadata: 0x0042490D
	public const string ErrorDataReceived = "User event handler to call for async IO with StandardError stream."; // Metadata: 0x0042493E
	public const string LogEntries = "The contents of the log."; // Metadata: 0x00424984
	public const string LogLog = "Gets or sets the name of the log to read from and write to."; // Metadata: 0x004249A0
	public const string LogMachineName = "The name of the machine on which to read or write events."; // Metadata: 0x004249DF
	public const string LogMonitoring = "Indicates if the component monitors the event log for changes."; // Metadata: 0x00424A1C
	public const string LogSynchronizingObject = "The object used to marshal the event handler calls issued as a result of an EventLog change."; // Metadata: 0x00424A5E
	public const string LogSource = "The application name (source name) to use when writing to the event log."; // Metadata: 0x00424ABE
	public const string LogEntryWritten = "Raised each time any application writes an entry to the event log."; // Metadata: 0x00424B0A
	public const string LogEntryMachineName = "The machine on which this event log resides."; // Metadata: 0x00424B50
	public const string LogEntryData = "The binary data associated with this entry in the event log."; // Metadata: 0x00424B80
	public const string LogEntryIndex = "The sequence of this entry in the event log."; // Metadata: 0x00424BC0
	public const string LogEntryCategory = "The category for this message."; // Metadata: 0x00424BF0
	public const string LogEntryCategoryNumber = "An application-specific category number assigned to this entry."; // Metadata: 0x00424C12
	public const string LogEntryEventID = "The number identifying the message for this source."; // Metadata: 0x00424C55
	public const string LogEntryEntryType = "The type of entry - Information, Warning, etc."; // Metadata: 0x00424C8C
	public const string LogEntryMessage = "The text of the message for this entry"; // Metadata: 0x00424CBE
	public const string LogEntrySource = "The name of the application that wrote this entry."; // Metadata: 0x00424CE8
	public const string LogEntryReplacementStrings = "The application-supplied strings used in the message."; // Metadata: 0x00424D1E
	public const string LogEntryResourceId = "The full number identifying the message in the event message dll."; // Metadata: 0x00424D57
	public const string LogEntryTimeGenerated = "The time at which the application logged this entry."; // Metadata: 0x00424D9C
	public const string LogEntryTimeWritten = "The time at which the system logged this entry to the event log."; // Metadata: 0x00424DD4
	public const string LogEntryUserName = "The username of the account associated with this entry by the writing application."; // Metadata: 0x00424E18
	public const string OutputDataReceived = "User event handler to call for async IO with StandardOutput stream."; // Metadata: 0x00424E6E
	public const string PC_CounterHelp = "The description message for this counter."; // Metadata: 0x00424EB5
	public const string PC_CounterType = "The counter type indicates how to interpret the value of the counter, for example an actual count or a rate of change."; // Metadata: 0x00424EE2
	public const string PC_ReadOnly = "Indicates if the counter is read only.  Remote counters and counters not created using this component are read-only."; // Metadata: 0x00424F5C
	public const string PC_RawValue = "Directly accesses the raw value of this counter.  The counter must have been created using this component."; // Metadata: 0x00424FD4
	public const string ProcessAssociated = "Indicates if the process component is associated with a real process."; // Metadata: 0x00425042
	public const string ProcessDesc = "Provides access to local and remote processes, enabling starting and stopping of local processes."; // Metadata: 0x0042508B
	public const string ProcessExitCode = "The value returned from the associated process when it terminated."; // Metadata: 0x004250F0
	public const string ProcessTerminated = "Indicates if the associated process has been terminated."; // Metadata: 0x00425136
	public const string ProcessExitTime = "The time that the associated process exited."; // Metadata: 0x00425172
	public const string ProcessHandle = "Returns the native handle for this process.   The handle is only available if the process was started using this component."; // Metadata: 0x004251A2
	public const string ProcessHandleCount = "The number of native handles associated with this process."; // Metadata: 0x00425221
	public const string ProcessId = "The unique identifier for the process."; // Metadata: 0x0042525F
	public const string ProcessMachineName = "The name of the machine the running the process."; // Metadata: 0x00425289
	public const string ProcessMainModule = "The main module for the associated process."; // Metadata: 0x004252BD
	public const string ProcessModules = "The modules that have been loaded by the associated process."; // Metadata: 0x004252EC
	public const string ProcessSynchronizingObject = "The object used to marshal the event handler calls issued as a result of a Process exit."; // Metadata: 0x0042532C
	public const string ProcessSessionId = "The identifier for the session of the process."; // Metadata: 0x00425388
	public const string ProcessThreads = "The threads running in the associated process."; // Metadata: 0x004253BA
	public const string ProcessEnableRaisingEvents = "Whether the process component should watch for the associated process to exit, and raise the Exited event."; // Metadata: 0x004253EC
	public const string ProcessExited = "If the WatchForExit property is set to true, then this event is raised when the associated process exits."; // Metadata: 0x0042545A
	public const string ProcessFileName = "The name of the application, document or URL to start."; // Metadata: 0x004254C7
	public const string ProcessWorkingDirectory = "The initial working directory for the process."; // Metadata: 0x00425501
	public const string ProcessBasePriority = "The base priority computed based on the priority class that all threads run relative to."; // Metadata: 0x00425533
	public const string ProcessMainWindowHandle = "The handle of the main window for the process."; // Metadata: 0x0042558F
	public const string ProcessMainWindowTitle = "The caption of the main window for the process."; // Metadata: 0x004255C1
	public const string ProcessMaxWorkingSet = "The maximum amount of physical memory the process has required since it was started."; // Metadata: 0x004255F4
	public const string ProcessMinWorkingSet = "The minimum amount of physical memory the process has required since it was started."; // Metadata: 0x0042564C
	public const string ProcessNonpagedSystemMemorySize = "The number of bytes of non pageable system  memory the process is using."; // Metadata: 0x004256A4
	public const string ProcessPagedMemorySize = "The current amount of memory that can be paged to disk that the process is using."; // Metadata: 0x004256F0
	public const string ProcessPagedSystemMemorySize = "The number of bytes of pageable system memory the process is using."; // Metadata: 0x00425745
	public const string ProcessPeakPagedMemorySize = "The maximum amount of memory that can be paged to disk that the process has used since it was started."; // Metadata: 0x0042578C
	public const string ProcessPeakWorkingSet = "The maximum amount of physical memory the process has used since it was started."; // Metadata: 0x004257F6
	public const string ProcessPeakVirtualMemorySize = "The maximum amount of virtual memory the process has allocated since it was started."; // Metadata: 0x0042584A
	public const string ProcessPriorityBoostEnabled = "Whether this process would like a priority boost when the user interacts with it."; // Metadata: 0x004258A2
	public const string ProcessPriorityClass = "The priority that the threads in the process run relative to."; // Metadata: 0x004258F7
	public const string ProcessPrivateMemorySize = "The current amount of memory that the process has allocated that cannot be shared with other processes."; // Metadata: 0x00425938
	public const string ProcessPrivilegedProcessorTime = "The amount of CPU time the process spent inside the operating system core."; // Metadata: 0x004259A3
	public const string ProcessProcessName = "The name of the process."; // Metadata: 0x004259F1
	public const string ProcessProcessorAffinity = "A bit mask which represents the processors that the threads within the process are allowed to run on."; // Metadata: 0x00425A0D
	public const string ProcessResponding = "Whether this process is currently responding."; // Metadata: 0x00425A76
	public const string ProcessStandardError = "Standard error stream of the process."; // Metadata: 0x00425AA7
	public const string ProcessStandardInput = "Standard input stream of the process."; // Metadata: 0x00425AD0
	public const string ProcessStandardOutput = "Standard output stream of the process."; // Metadata: 0x00425AF9
	public const string ProcessStartInfo = "Specifies information used to start a process."; // Metadata: 0x00425B23
	public const string ProcessStartTime = "The time at which the process was started."; // Metadata: 0x00425B55
	public const string ProcessTotalProcessorTime = "The amount of CPU time the process has used."; // Metadata: 0x00425B83
	public const string ProcessUserProcessorTime = "The amount of CPU time the process spent outside the operating system core."; // Metadata: 0x00425BB3
	public const string ProcessVirtualMemorySize = "The amount of virtual memory the process has currently allocated."; // Metadata: 0x00425C02
	public const string ProcessWorkingSet = "The current amount of physical memory the process is using."; // Metadata: 0x00425C47
	public const string ProcModModuleName = "The name of the module."; // Metadata: 0x00425C86
	public const string ProcModFileName = "The file name of the module."; // Metadata: 0x00425CA1
	public const string ProcModBaseAddress = "The memory address that the module loaded at."; // Metadata: 0x00425CC1
	public const string ProcModModuleMemorySize = "The amount of virtual memory required by the code and data in the module file."; // Metadata: 0x00425CF2
	public const string ProcModEntryPointAddress = "The memory address of the function that runs when the module is loaded."; // Metadata: 0x00425D44
	public const string ProcessVerb = "The verb to apply to the document specified by the FileName property."; // Metadata: 0x00425D8F
	public const string ProcessArguments = "Command line arguments that will be passed to the application specified by the FileName property."; // Metadata: 0x00425DD8
	public const string ProcessErrorDialog = "Whether to show an error dialog to the user if there is an error."; // Metadata: 0x00425E3D
	public const string ProcessWindowStyle = "How the main window should be created when the process starts."; // Metadata: 0x00425E82
	public const string ProcessCreateNoWindow = "Whether to start the process without creating a new window to contain it."; // Metadata: 0x00425EC4
	public const string ProcessEnvironmentVariables = "Set of environment variables that apply to this process and child processes."; // Metadata: 0x00425F11
	public const string ProcessRedirectStandardInput = "Whether the process command input is read from the Process instance\'s StandardInput member."; // Metadata: 0x00425F61
	public const string ProcessRedirectStandardOutput = "Whether the process output is written to the Process instance\'s StandardOutput member."; // Metadata: 0x00425FC0
	public const string ProcessRedirectStandardError = "Whether the process\'s error output is written to the Process instance\'s StandardError member."; // Metadata: 0x0042601A
	public const string ProcessUseShellExecute = "Whether to use the operating system shell to start the process."; // Metadata: 0x0042607B
	public const string ThreadBasePriority = "The current base priority of the thread."; // Metadata: 0x004260BE
	public const string ThreadCurrentPriority = "The current priority level of the thread."; // Metadata: 0x004260EA
	public const string ThreadId = "The unique identifier for the thread."; // Metadata: 0x00426117
	public const string ThreadPriorityBoostEnabled = "Whether the thread would like a priority boost when the user interacts with UI associated with the thread."; // Metadata: 0x00426140
	public const string ThreadPriorityLevel = "The priority level of the thread."; // Metadata: 0x004261AE
	public const string ThreadPrivilegedProcessorTime = "The amount of CPU time the thread spent inside the operating system core."; // Metadata: 0x004261D3
	public const string ThreadStartAddress = "The memory address of the function that was run when the thread started."; // Metadata: 0x00426220
	public const string ThreadStartTime = "The time the thread was started."; // Metadata: 0x0042626C
	public const string ThreadThreadState = "The execution state of the thread."; // Metadata: 0x00426290
	public const string ThreadTotalProcessorTime = "The amount of CPU time the thread has consumed since it was started."; // Metadata: 0x004262B6
	public const string ThreadUserProcessorTime = "The amount of CPU time the thread spent outside the operating system core."; // Metadata: 0x004262FE
	public const string ThreadWaitReason = "The reason the thread is waiting, if it is waiting."; // Metadata: 0x0042634C
	public const string VerbEditorDefault = "(Default)"; // Metadata: 0x00426383
	public const string AppSettingsReaderNoKey = "The key \'{0}\' does not exist in the appSettings configuration section."; // Metadata: 0x00426390
	public const string AppSettingsReaderNoParser = "Type \'{0}\' does not have a Parse method."; // Metadata: 0x004263DA
	public const string AppSettingsReaderCantParse = "The value \'{0}\' was found in the appSettings configuration section for key \'{1}\', and this value is not a valid {2}."; // Metadata: 0x00426406
	public const string AppSettingsReaderEmptyString = "(empty string)"; // Metadata: 0x0042647E
	public const string InvalidPermissionState = "Invalid permission state."; // Metadata: 0x00426490
	public const string PermissionNumberOfElements = "The number of elements on the access path must be the same as the number of tag names."; // Metadata: 0x004264AD
	public const string PermissionItemExists = "The item provided already exists."; // Metadata: 0x00426507
	public const string PermissionItemDoesntExist = "The requested item doesn\'t exist."; // Metadata: 0x0042652C
	public const string PermissionBadParameterEnum = "Parameter must be of type enum."; // Metadata: 0x00426551
	public const string PermissionInvalidLength = "Length must be greater than {0}."; // Metadata: 0x00426574
	public const string PermissionTypeMismatch = "Type mismatch."; // Metadata: 0x00426598
	public const string Argument_NotAPermissionElement = "\'securityElement\' was not a permission element."; // Metadata: 0x004265AA
	public const string Argument_InvalidXMLBadVersion = "Invalid Xml - can only parse elements of version one."; // Metadata: 0x004265DD
	public const string InvalidPermissionLevel = "Invalid permission level."; // Metadata: 0x00426616
	public const string TargetNotWebBrowserPermissionLevel = "Target not WebBrowserPermissionLevel."; // Metadata: 0x00426633
	public const string WebBrowserBadXml = "Bad Xml {0}"; // Metadata: 0x0042665C
	public const string KeyedCollNeedNonNegativeNum = "Need a non negative number for capacity."; // Metadata: 0x0042666B
	public const string KeyedCollDuplicateKey = "Cannot add item since the item with the key already exists in the collection."; // Metadata: 0x00426697
	public const string KeyedCollReferenceKeyNotFound = "The key reference with respect to which the insertion operation was to be performed was not found."; // Metadata: 0x004266E8
	public const string KeyedCollKeyNotFound = "Cannot find the key {0} in the collection."; // Metadata: 0x0042674E
	public const string KeyedCollInvalidKey = "Keys must be non-null non-empty Strings."; // Metadata: 0x0042677C
	public const string KeyedCollCapacityOverflow = "Capacity overflowed and went negative.  Check capacity of the collection."; // Metadata: 0x004267A8
	public const string OrderedDictionary_ReadOnly = "The OrderedDictionary is readonly and cannot be modified."; // Metadata: 0x004267F5
	public const string OrderedDictionary_SerializationMismatch = "There was an error deserializing the OrderedDictionary.  The ArrayList does not contain DictionaryEntries."; // Metadata: 0x00426832
	public const string Async_ExceptionOccurred = "An exception occurred during the operation, making the result invalid.  Check InnerException for exception details."; // Metadata: 0x004268A0
	public const string Async_QueueingFailed = "Queuing WaitCallback failed."; // Metadata: 0x00426917
	public const string Async_OperationCancelled = "Operation has been cancelled."; // Metadata: 0x00426937
	public const string Async_OperationAlreadyCompleted = "This operation has already had OperationCompleted called on it and further calls are illegal."; // Metadata: 0x00426958
	public const string Async_NullDelegate = "A non-null SendOrPostCallback must be supplied."; // Metadata: 0x004269B9
	public const string BackgroundWorker_AlreadyRunning = "BackgroundWorker is already running."; // Metadata: 0x004269EC
	public const string BackgroundWorker_CancellationNotSupported = "BackgroundWorker does not support cancellation."; // Metadata: 0x00426A14
	public const string BackgroundWorker_OperationCompleted = "Operation has already been completed."; // Metadata: 0x00426A47
	public const string BackgroundWorker_ProgressNotSupported = "BackgroundWorker does not support progress."; // Metadata: 0x00426A70
	public const string BackgroundWorker_WorkerAlreadyRunning = "This BackgroundWorker is currently busy and cannot run multiple tasks concurrently."; // Metadata: 0x00426A9F
	public const string BackgroundWorker_WorkerDoesntReportProgress = "This BackgroundWorker states that it doesn\'t report progress. Modify WorkerReportsProgress to state that it does report progress."; // Metadata: 0x00426AF6
	public const string BackgroundWorker_WorkerDoesntSupportCancellation = "This BackgroundWorker states that it doesn\'t support cancellation. Modify WorkerSupportsCancellation to state that it does support cancellation."; // Metadata: 0x00426B7B
	public const string Async_ProgressChangedEventArgs_ProgressPercentage = "Percentage progress made in operation."; // Metadata: 0x00426C0F
	public const string Async_ProgressChangedEventArgs_UserState = "User-supplied state to identify operation."; // Metadata: 0x00426C39
	public const string Async_AsyncEventArgs_Cancelled = "True if operation was cancelled."; // Metadata: 0x00426C67
	public const string Async_AsyncEventArgs_Error = "Exception that occurred during operation.  Null if no error."; // Metadata: 0x00426C8B
	public const string Async_AsyncEventArgs_UserState = "User-supplied state to identify operation."; // Metadata: 0x00426CCB
	public const string BackgroundWorker_CancellationPending = "Has the user attempted to cancel the operation? To be accessed from DoWork event handler."; // Metadata: 0x00426CF9
	public const string BackgroundWorker_DoWork = "Event handler to be run on a different thread when the operation begins."; // Metadata: 0x00426D56
	public const string BackgroundWorker_IsBusy = "Is the worker still currently working on a background operation?"; // Metadata: 0x00426DA2
	public const string BackgroundWorker_ProgressChanged = "Raised when the worker thread indicates that some progress has been made."; // Metadata: 0x00426DE6
	public const string BackgroundWorker_RunWorkerCompleted = "Raised when the worker has completed (either through success, failure, or cancellation)."; // Metadata: 0x00426E33
	public const string BackgroundWorker_WorkerReportsProgress = "Whether the worker will report progress."; // Metadata: 0x00426E8F
	public const string BackgroundWorker_WorkerSupportsCancellation = "Whether the worker supports cancellation."; // Metadata: 0x00426EBB
	public const string BackgroundWorker_DoWorkEventArgs_Argument = "Argument passed into the worker handler from BackgroundWorker.RunWorkerAsync."; // Metadata: 0x00426EE8
	public const string BackgroundWorker_DoWorkEventArgs_Result = "Result from the worker function."; // Metadata: 0x00426F39
	public const string BackgroundWorker_Desc = "Executes an operation on a separate thread."; // Metadata: 0x00426F5D
	public const string InstanceCreationEditorDefaultText = "(New...)"; // Metadata: 0x00426F8C
	public const string PropertyTabAttributeBadPropertyTabScope = "Scope must be PropertyTabScope.Document or PropertyTabScope.Component"; // Metadata: 0x00426F98
	public const string PropertyTabAttributeTypeLoadException = "Couldn\'t find type {0}"; // Metadata: 0x00426FE1
	public const string PropertyTabAttributeArrayLengthMismatch = "tabClasses must have the same number of items as tabScopes"; // Metadata: 0x00426FFB
	public const string PropertyTabAttributeParamsBothNull = "An array of tab type names or tab types must be specified"; // Metadata: 0x00427039
	public const string InstanceDescriptorCannotBeStatic = "Parameter cannot be static."; // Metadata: 0x00427076
	public const string InstanceDescriptorMustBeStatic = "Parameter must be static."; // Metadata: 0x00427095
	public const string InstanceDescriptorMustBeReadable = "Parameter must be readable."; // Metadata: 0x004270B2
	public const string InstanceDescriptorLengthMismatch = "Length mismatch."; // Metadata: 0x004270D1
	public const string ToolboxItemAttributeFailedGetType = "Failed to create ToolboxItem of type: {0}"; // Metadata: 0x004270E5
	public const string PropertyDescriptorCollectionBadValue = "Parameter must be of type PropertyDescriptor."; // Metadata: 0x00427112
	public const string PropertyDescriptorCollectionBadKey = "Parameter must be of type int or string."; // Metadata: 0x00427143
	public const string AspNetHostingPermissionBadXml = "Bad Xml {0}"; // Metadata: 0x0042716F
	public const string CorruptedGZipHeader = "The magic number in GZip header is not correct. Make sure you are passing in a GZip stream."; // Metadata: 0x0042717E
	public const string UnknownCompressionMode = "The compression mode specified in GZip header is unknown."; // Metadata: 0x004271DD
	public const string UnknownState = "Decoder is in some unknown state. This might be caused by corrupted data."; // Metadata: 0x0042721A
	public const string InvalidHuffmanData = "Failed to construct a huffman tree using the length array. The stream might be corrupted."; // Metadata: 0x00427267
	public const string InvalidCRC = "The CRC in GZip footer does not match the CRC calculated from the decompressed data."; // Metadata: 0x004272C4
	public const string InvalidStreamSize = "The stream size in GZip footer does not match the real stream size."; // Metadata: 0x0042731C
	public const string UnknownBlockType = "Unknown block type. Stream might be corrupted."; // Metadata: 0x00427363
	public const string InvalidBlockLength = "Block length does not match with its complement."; // Metadata: 0x00427395
	public const string GenericInvalidData = "Found invalid data while decoding."; // Metadata: 0x004273C9
	public const string CannotReadFromDeflateStream = "Reading from the compression stream is not supported."; // Metadata: 0x004273EF
	public const string CannotWriteToDeflateStream = "Writing to the compression stream is not supported."; // Metadata: 0x00427428
	public const string NotReadableStream = "The base stream is not readable."; // Metadata: 0x0042745F
	public const string NotWriteableStream = "The base stream is not writeable."; // Metadata: 0x00427483
	public const string InvalidArgumentOffsetCount = "Offset plus count is larger than the length of target array."; // Metadata: 0x004274A8
	public const string InvalidBeginCall = "Only one asynchronous reader is allowed time at one time."; // Metadata: 0x004274E8
	public const string InvalidEndCall = "EndRead is only callable when there is one pending asynchronous reader."; // Metadata: 0x00427525
	public const string StreamSizeOverflow = "The gzip stream can\'t contain more than 4GB data."; // Metadata: 0x00427570
	public const string ZLibErrorDLLLoadError = "The underlying compression routine could not be loaded correctly."; // Metadata: 0x004275A5
	public const string ZLibErrorUnexpected = "The underlying compression routine returned an unexpected error code."; // Metadata: 0x004275EA
	public const string ZLibErrorInconsistentStream = "The stream state of the underlying compression routine is inconsistent."; // Metadata: 0x00427633
	public const string ZLibErrorSteamFreedPrematurely = "The stream state of the underlying compression routine was freed prematurely."; // Metadata: 0x0042767E
	public const string ZLibErrorNotEnoughMemory = "The underlying compression routine could not reserve sufficient memory."; // Metadata: 0x004276CF
	public const string ZLibErrorIncorrectInitParameters = "The underlying compression routine received incorrect initialization parameters."; // Metadata: 0x0042771A
	public const string ZLibErrorVersionMismatch = "The version of the underlying compression routine does not match expected version."; // Metadata: 0x0042776E
	public const string InvalidOperation_HCCountOverflow = "Handle collector count overflows or underflows."; // Metadata: 0x004277C4
	public const string Argument_InvalidThreshold = "maximumThreshold cannot be less than initialThreshold."; // Metadata: 0x004277F7
	public const string Argument_SemaphoreInitialMaximum = "The initial count for the semaphore must be greater than or equal to zero and less than the maximum count."; // Metadata: 0x00427831
	public const string Argument_WaitHandleNameTooLong = "The name can be no more than 260 characters in length."; // Metadata: 0x0042789F
	public const string WaitHandleCannotBeOpenedException_InvalidHandle = "A WaitHandle with system-wide name \'{0}\' cannot be created. A WaitHandle of a different type might have the same name."; // Metadata: 0x004278D9
	public const string ArgumentNotAPermissionElement = "Argument was not a permission Element."; // Metadata: 0x00427953
	public const string ArgumentWrongType = "Argument should be of type {0}."; // Metadata: 0x0042797D
	public const string BadXmlVersion = "Xml version was wrong."; // Metadata: 0x004279A0
	public const string BinarySerializationNotSupported = "Binary serialization is current not supported by the LocalFileSettingsProvider."; // Metadata: 0x004279BA
	public const string BothScopeAttributes = "The setting {0} has both an ApplicationScopedSettingAttribute and a UserScopedSettingAttribute."; // Metadata: 0x00427A0D
	public const string NoScopeAttributes = "The setting {0} does not have either an ApplicationScopedSettingAttribute or UserScopedSettingAttribute."; // Metadata: 0x00427A70
	public const string PositionOutOfRange = "Position cannot be less than zero."; // Metadata: 0x00427ADC
	public const string ProviderInstantiationFailed = "Failed to instantiate provider: {0}."; // Metadata: 0x00427B02
	public const string ProviderTypeLoadFailed = "Failed to load provider type: {0}."; // Metadata: 0x00427B2A
	public const string SaveAppScopedNotSupported = "Error saving {0} - The LocalFileSettingsProvider does not support saving changes to application-scoped settings."; // Metadata: 0x00427B50
	public const string SettingsResetFailed = "Failed to reset settings: unable to access the configuration section."; // Metadata: 0x00427BC4
	public const string SettingsSaveFailed = "Failed to save settings: {0}"; // Metadata: 0x00427C0D
	public const string SettingsSaveFailedNoSection = "Failed to save settings: unable to access the configuration section."; // Metadata: 0x00427C2D
	public const string StringDeserializationFailed = "Could not use String deserialization for setting: {0}."; // Metadata: 0x00427C75
	public const string StringSerializationFailed = "Could not use String serialization for setting: {0}."; // Metadata: 0x00427CAF
	public const string UnknownSerializationFormat = "Unknown serialization format specified."; // Metadata: 0x00427CE7
	public const string UnknownSeekOrigin = "Unknown SeekOrigin specified."; // Metadata: 0x00427D12
	public const string UnknownUserLevel = "Unknown ConfigurationUserLevel specified."; // Metadata: 0x00427D33
	public const string UserSettingsNotSupported = "The current configuration system does not support user-scoped settings."; // Metadata: 0x00427D60
	public const string XmlDeserializationFailed = "Could not use Xml deserialization for setting: {0}."; // Metadata: 0x00427DAB
	public const string XmlSerializationFailed = "Could not use Xml serialization for setting: {0}."; // Metadata: 0x00427DE2
	public const string MemberRelationshipService_RelationshipNotSupported = "Relationships between {0}.{1} and {2}.{3} are not supported."; // Metadata: 0x00427E17
	public const string MaskedTextProviderPasswordAndPromptCharError = "The PasswordChar and PromptChar values cannot be the same."; // Metadata: 0x00427E57
	public const string MaskedTextProviderInvalidCharError = "The specified character value is not allowed for this property."; // Metadata: 0x00427E95
	public const string MaskedTextProviderMaskNullOrEmpty = "The Mask value cannot be null or empty."; // Metadata: 0x00427ED8
	public const string MaskedTextProviderMaskInvalidChar = "The specified mask contains invalid characters."; // Metadata: 0x00427F03
	public const string StandardOleMarshalObjectGetMarshalerFailed = "Failed to get marshaler for IID {0}."; // Metadata: 0x00427F36
	public const string SoundAPIBadSoundLocation = "Could not determine a universal resource identifier for the sound location."; // Metadata: 0x00427F5E
	public const string SoundAPIFileDoesNotExist = "Please be sure a sound file exists at the specified location."; // Metadata: 0x00427FAD
	public const string SoundAPIFormatNotSupported = "Sound API only supports playing PCM wave files."; // Metadata: 0x00427FEE
	public const string SoundAPIInvalidWaveFile = "The file located at {0} is not a valid wave file."; // Metadata: 0x00428021
	public const string SoundAPIInvalidWaveHeader = "The wave header is corrupt."; // Metadata: 0x00428056
	public const string SoundAPILoadTimedOut = "The request to load the wave file in memory timed out."; // Metadata: 0x00428075
	public const string SoundAPILoadTimeout = "The LoadTimeout property of a SoundPlayer cannot be negative."; // Metadata: 0x004280AF
	public const string SoundAPIReadError = "There was an error reading the file located at {0}. Please make sure that a valid wave file exists at the specified location."; // Metadata: 0x004280F0
	public const string WrongActionForCtor = "Constructor supports only the \'{0}\' action."; // Metadata: 0x00428171
	public const string MustBeResetAddOrRemoveActionForCtor = "Constructor only supports either a Reset, Add, or Remove action."; // Metadata: 0x004281A0
	public const string ResetActionRequiresNullItem = "Reset action must be initialized with no changed items."; // Metadata: 0x004281E4
	public const string ResetActionRequiresIndexMinus1 = "Reset action must be initialized with index -1."; // Metadata: 0x0042821F
	public const string IndexCannotBeNegative = "Index cannot be negative."; // Metadata: 0x00428252
	public const string ObservableCollectionReentrancyNotAllowed = "Cannot change ObservableCollection during a CollectionChanged event."; // Metadata: 0x0042826F
	public const string mono_net_io_shutdown = "mono_net_io_shutdown"; // Metadata: 0x004282B7
	public const string mono_net_io_renegotiate = "mono_net_io_renegotiate"; // Metadata: 0x004282CF
	public const string net_ssl_io_already_shutdown = "Write operations are not allowed after the channel was shutdown."; // Metadata: 0x004282EA
	public const string net_log_set_socketoption_reuseport_default_on = "net_log_set_socketoption_reuseport_default_on"; // Metadata: 0x0042832E
	public const string net_log_set_socketoption_reuseport_not_supported = "net_log_set_socketoption_reuseport_not_supported"; // Metadata: 0x0042835F
	public const string net_log_set_socketoption_reuseport = "net_log_set_socketoption_reuseport"; // Metadata: 0x00428393
	public const string BlockingCollection_Add_ConcurrentCompleteAdd = "CompleteAdding may not be used concurrently with additions to the collection."; // Metadata: 0x004283B9
	public const string BlockingCollection_Add_Failed = "The underlying collection didn\'t accept the item."; // Metadata: 0x0042840A
	public const string BlockingCollection_CantAddAnyWhenCompleted = "At least one of the specified collections is marked as complete with regards to additions."; // Metadata: 0x0042843F
	public const string BlockingCollection_CantTakeAnyWhenAllDone = "All collections are marked as complete with regards to additions."; // Metadata: 0x0042849D
	public const string BlockingCollection_CantTakeWhenDone = "The collection argument is empty and has been marked as complete with regards to additions."; // Metadata: 0x004284E2
	public const string BlockingCollection_Completed = "The collection has been marked as complete with regards to additions."; // Metadata: 0x00428541
	public const string BlockingCollection_CopyTo_IncorrectType = "The array argument is of the incorrect type."; // Metadata: 0x0042858A
	public const string BlockingCollection_CopyTo_MultiDim = "The array argument is multidimensional."; // Metadata: 0x004285BA
	public const string BlockingCollection_CopyTo_NonNegative = "The index argument must be greater than or equal zero."; // Metadata: 0x004285E5
	public const string Collection_CopyTo_TooManyElems = "The number of elements in the collection is greater than the available space from index to the end of the destination array."; // Metadata: 0x0042861F
	public const string BlockingCollection_ctor_BoundedCapacityRange = "The boundedCapacity argument must be positive."; // Metadata: 0x0042869F
	public const string BlockingCollection_ctor_CountMoreThanCapacity = "The collection argument contains more items than are allowed by the boundedCapacity."; // Metadata: 0x004286D1
	public const string BlockingCollection_Disposed = "The collection has been disposed."; // Metadata: 0x00428729
	public const string BlockingCollection_Take_CollectionModified = "The underlying collection was modified from outside of the BlockingCollection<T>."; // Metadata: 0x0042874E
	public const string BlockingCollection_TimeoutInvalid = "The specified timeout must represent a value between -1 and {0}, inclusive."; // Metadata: 0x004287A3
	public const string BlockingCollection_ValidateCollectionsArray_DispElems = "The collections argument contains at least one disposed element."; // Metadata: 0x004287F2
	public const string BlockingCollection_ValidateCollectionsArray_LargeSize = "The collections length is greater than the supported range for 32 bit machine."; // Metadata: 0x00428836
	public const string BlockingCollection_ValidateCollectionsArray_NullElems = "The collections argument contains at least one null element."; // Metadata: 0x00428888
	public const string BlockingCollection_ValidateCollectionsArray_ZeroSize = "The collections argument is a zero-length array."; // Metadata: 0x004288C8
	public const string Common_OperationCanceled = "The operation was canceled."; // Metadata: 0x004288FC
	public const string ConcurrentBag_Ctor_ArgumentNullException = "The collection argument is null."; // Metadata: 0x0042891B
	public const string ConcurrentBag_CopyTo_ArgumentNullException = "The array argument is null."; // Metadata: 0x0042893F
	public const string Collection_CopyTo_ArgumentOutOfRangeException = "The index argument must be greater than or equal zero."; // Metadata: 0x0042895E
	public const string ConcurrentCollection_SyncRoot_NotSupported = "The SyncRoot property may not be used for the synchronization of concurrent collections."; // Metadata: 0x00428998
	public const string ConcurrentDictionary_ArrayIncorrectType = "The array is multidimensional, or the type parameter for the set cannot be cast automatically to the type of the destination array."; // Metadata: 0x004289F4
	public const string ConcurrentDictionary_SourceContainsDuplicateKeys = "The source argument contains duplicate keys."; // Metadata: 0x00428A7B
	public const string ConcurrentDictionary_ConcurrencyLevelMustBePositive = "The concurrencyLevel argument must be positive."; // Metadata: 0x00428AAB
	public const string ConcurrentDictionary_CapacityMustNotBeNegative = "The capacity argument must be greater than or equal to zero."; // Metadata: 0x00428ADE
	public const string ConcurrentDictionary_IndexIsNegative = "The index argument is less than zero."; // Metadata: 0x00428B1E
	public const string ConcurrentDictionary_ArrayNotLargeEnough = "The index is equal to or greater than the length of the array, or the number of elements in the dictionary is greater than the available space from index to the end of the destination array."; // Metadata: 0x00428B47
	public const string ConcurrentDictionary_KeyAlreadyExisted = "The key already existed in the dictionary."; // Metadata: 0x00428C09
	public const string ConcurrentDictionary_ItemKeyIsNull = "TKey is a reference type and item.Key is null."; // Metadata: 0x00428C37
	public const string ConcurrentDictionary_TypeOfKeyIncorrect = "The key was of an incorrect type for this dictionary."; // Metadata: 0x00428C69
	public const string ConcurrentDictionary_TypeOfValueIncorrect = "The value was of an incorrect type for this dictionary."; // Metadata: 0x00428CA2
	public const string ConcurrentStack_PushPopRange_CountOutOfRange = "The count argument must be greater than or equal to zero."; // Metadata: 0x00428CDD
	public const string ConcurrentStack_PushPopRange_InvalidCount = "The sum of the startIndex and count arguments must be less than or equal to the collection\'s Count."; // Metadata: 0x00428D1A
	public const string ConcurrentStack_PushPopRange_StartOutOfRange = "The startIndex argument must be greater than or equal to zero."; // Metadata: 0x00428D81
	public const string Partitioner_DynamicPartitionsNotSupported = "Dynamic partitions are not supported by this partitioner."; // Metadata: 0x00428DC3
	public const string PartitionerStatic_CanNotCallGetEnumeratorAfterSourceHasBeenDisposed = "Can not call GetEnumerator on partitions after the source enumerable is disposed"; // Metadata: 0x00428E00
	public const string PartitionerStatic_CurrentCalledBeforeMoveNext = "MoveNext must be called at least once before calling Current."; // Metadata: 0x00428E54
	public const string ConcurrentBag_Enumerator_EnumerationNotStartedOrAlreadyFinished = "Enumeration has either not started or has already finished."; // Metadata: 0x00428E95
	public const string Arg_NonZeroLowerBound = "The lower bound of target array must be zero."; // Metadata: 0x00428ED4
	public const string Arg_WrongType = "The value \'{0}\' is not of type \'{1}\' and cannot be used in this generic collection."; // Metadata: 0x00428F05
	public const string Arg_ArrayPlusOffTooSmall = "Destination array is not long enough to copy all the items in the collection. Check array index and length."; // Metadata: 0x00428F5C
	public const string ArgumentOutOfRange_NeedNonNegNum = "Non-negative number required."; // Metadata: 0x00428FCB
	public const string ArgumentOutOfRange_SmallCapacity = "capacity was less than the current size."; // Metadata: 0x00428FEC
	public const string Argument_InvalidOffLen = "Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection."; // Metadata: 0x00429018
	public const string Argument_AddingDuplicate = "An item with the same key has already been added. Key: {0}"; // Metadata: 0x004290AE
	public const string InvalidOperation_EmptyQueue = "Queue empty."; // Metadata: 0x004290EC
	public const string InvalidOperation_EnumOpCantHappen = "Enumeration has either not started or has already finished."; // Metadata: 0x004290FC
	public const string InvalidOperation_EnumFailedVersion = "Collection was modified; enumeration operation may not execute."; // Metadata: 0x0042913B
	public const string InvalidOperation_EmptyStack = "Stack empty."; // Metadata: 0x0042917E
	public const string InvalidOperation_EnumNotStarted = "Enumeration has not started. Call MoveNext."; // Metadata: 0x0042918E
	public const string InvalidOperation_EnumEnded = "Enumeration already finished."; // Metadata: 0x004291BD
	public const string NotSupported_KeyCollectionSet = "Mutating a key collection derived from a dictionary is not allowed."; // Metadata: 0x004291DE
	public const string NotSupported_ValueCollectionSet = "Mutating a value collection derived from a dictionary is not allowed."; // Metadata: 0x00429225
	public const string Arg_ArrayLengthsDiffer = "Array lengths must be the same."; // Metadata: 0x0042926E
	public const string Arg_BitArrayTypeUnsupported = "Only supported array types for CopyTo on BitArrays are Boolean[], Int32[] and Byte[]."; // Metadata: 0x00429291
	public const string Arg_HSCapacityOverflow = "HashSet capacity is too big."; // Metadata: 0x004292EA
	public const string Arg_HTCapacityOverflow = "Hashtable\'s capacity overflowed and went negative. Check load factor, capacity and the current size of the table."; // Metadata: 0x0042930A
	public const string Arg_InsufficientSpace = "Insufficient space in the target location to copy the information."; // Metadata: 0x0042937F
	public const string Arg_RankMultiDimNotSupported = "Only single dimensional arrays are supported for the requested action."; // Metadata: 0x004293C5
	public const string Argument_ArrayTooLarge = "The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue."; // Metadata: 0x0042940F
	public const string Argument_InvalidArrayType = "Target array type is not compatible with the type of items in the collection."; // Metadata: 0x00429486
	public const string ArgumentOutOfRange_BiggerThanCollection = "Must be less than or equal to the size of the collection."; // Metadata: 0x004294D7
	public const string ArgumentOutOfRange_Index = "Index was out of range. Must be non-negative and less than the size of the collection."; // Metadata: 0x00429514
	public const string ExternalLinkedListNode = "The LinkedList node does not belong to current LinkedList."; // Metadata: 0x0042956E
	public const string LinkedListEmpty = "The LinkedList is empty."; // Metadata: 0x004295AC
	public const string LinkedListNodeIsAttached = "The LinkedList node already belongs to a LinkedList."; // Metadata: 0x004295C8
	public const string NotSupported_SortedListNestedWrite = "This operation is not supported on SortedList nested types because they require modifying the original SortedList."; // Metadata: 0x00429600
	public const string SortedSet_LowerValueGreaterThanUpperValue = "Must be less than or equal to upperValue."; // Metadata: 0x00429676
	public const string Serialization_InvalidOnDeser = "OnDeserialization method was called while the object was not being deserialized."; // Metadata: 0x004296A3
	public const string Serialization_MismatchedCount = "The serialized Count information doesn\'t match the number of items."; // Metadata: 0x004296F7
	public const string Serialization_MissingKeys = "The keys for this dictionary are missing."; // Metadata: 0x0042973E
	public const string Serialization_MissingValues = "The values for this dictionary are missing."; // Metadata: 0x0042976B
	public const string ArgumentException_BufferNotFromPool = "The buffer is not associated with this pool and may not be returned to it."; // Metadata: 0x0042979A
	public const string ArgumentOutOfRange_IndexCountBuffer = "Index and count must refer to a location within the buffer."; // Metadata: 0x004297E8
	public const string Argument_InvalidCharSequenceNoIndex = "String contains invalid Unicode code points."; // Metadata: 0x00429827
	public const string net_uri_BadAuthority = "Invalid URI: The Authority/Host could not be parsed."; // Metadata: 0x00429857
	public const string net_uri_BadAuthorityTerminator = "Invalid URI: The Authority/Host cannot end with a backslash character (\'\\\\\')."; // Metadata: 0x0042988F
	public const string net_uri_BadFormat = "Invalid URI: The format of the URI could not be determined."; // Metadata: 0x004298E0
	public const string net_uri_NeedFreshParser = "The URI parser instance passed into \'uriParser\' parameter is already registered with the scheme name \'{0}\'."; // Metadata: 0x0042991F
	public const string net_uri_AlreadyRegistered = "A URI scheme name \'{0}\' already has a registered custom parser."; // Metadata: 0x0042998E
	public const string net_uri_BadHostName = "Invalid URI: The hostname could not be parsed."; // Metadata: 0x004299D1
	public const string net_uri_BadPort = "Invalid URI: Invalid port specified."; // Metadata: 0x00429A03
	public const string net_uri_BadScheme = "Invalid URI: The URI scheme is not valid."; // Metadata: 0x00429A2B
	public const string net_uri_BadString = "Invalid URI: There is an invalid sequence in the string."; // Metadata: 0x00429A58
	public const string net_uri_BadUserPassword = "Invalid URI: The username:password construct is badly formed."; // Metadata: 0x00429A94
	public const string net_uri_CannotCreateRelative = "A relative URI cannot be created because the \'uriString\' parameter represents an absolute URI."; // Metadata: 0x00429AD5
	public const string net_uri_SchemeLimit = "Invalid URI: The Uri scheme is too long."; // Metadata: 0x00429B37
	public const string net_uri_EmptyUri = "Invalid URI: The URI is empty."; // Metadata: 0x00429B63
	public const string net_uri_InvalidUriKind = "The value \'{0}\' passed for the UriKind parameter is invalid."; // Metadata: 0x00429B85
	public const string net_uri_MustRootedPath = "Invalid URI: A Dos path must be rooted, for example, \'c:\\\\\'."; // Metadata: 0x00429BC5
	public const string net_uri_NotAbsolute = "This operation is not supported for a relative URI."; // Metadata: 0x00429C05
	public const string net_uri_PortOutOfRange = "A derived type \'{0}\' has reported an invalid value for the Uri port \'{1}\'."; // Metadata: 0x00429C3C
	public const string net_uri_SizeLimit = "Invalid URI: The Uri string is too long."; // Metadata: 0x00429C8A
	public const string net_uri_UserDrivenParsing = "A derived type \'{0}\' is responsible for parsing this Uri instance. The base implementation must not be used."; // Metadata: 0x00429CB6
	public const string net_uri_NotJustSerialization = "UriComponents.SerializationInfoString must not be combined with other UriComponents."; // Metadata: 0x00429D26
	public const string net_uri_BadUnicodeHostForIdn = "An invalid Unicode character by IDN standards was specified in the host."; // Metadata: 0x00429D7E
	public const string Argument_ExtraNotValid = "Extra portion of URI not valid."; // Metadata: 0x00429DCA
	public const string Argument_InvalidUriSubcomponent = "The subcomponent, {0}, of this uri is not valid."; // Metadata: 0x00429DED
	public const string IO_EOF_ReadBeyondEOF = "Unable to read beyond the end of the stream."; // Metadata: 0x00429E21
	public const string BaseStream_Invalid_Not_Open = "The BaseStream is only available when the port is open."; // Metadata: 0x00429E51
	public const string PortNameEmpty_String = "The PortName cannot be empty."; // Metadata: 0x00429E8C
	public const string Port_not_open = "The port is closed."; // Metadata: 0x00429EAD
	public const string Port_already_open = "The port is already open."; // Metadata: 0x00429EC4
	public const string Cant_be_set_when_open = "\'{0}\' cannot be set while the port is open."; // Metadata: 0x00429EE1
	public const string Max_Baud = "The maximum baud rate for the device is {0}."; // Metadata: 0x00429F10
	public const string In_Break_State = "The port is in the break state and cannot be written to."; // Metadata: 0x00429F40
	public const string Write_timed_out = "The write timed out."; // Metadata: 0x00429F7C
	public const string CantSetRtsWithHandshaking = "RtsEnable cannot be accessed if Handshake is set to RequestToSend or RequestToSendXOnXOff."; // Metadata: 0x00429F94
	public const string NotSupportedEncoding = "SerialPort does not support encoding \'{0}\'.  The supported encodings include ASCIIEncoding, UTF8Encoding, UnicodeEncoding, UTF32Encoding, and most single or double byte code pages.  For a complete list please see the documentation."; // Metadata: 0x00429FF2
	public const string Arg_InvalidSerialPort = "The given port name does not start with COM/com or does not resolve to a valid serial port."; // Metadata: 0x0042A0DD
	public const string Arg_InvalidSerialPortExtended = "The given port name is invalid.  It may be a valid port, but not a serial port."; // Metadata: 0x0042A13C
	public const string ArgumentOutOfRange_Bounds_Lower_Upper = "Argument must be between {0} and {1}."; // Metadata: 0x0042A18F
	public const string ArgumentOutOfRange_Enum = "Enum value was out of legal range."; // Metadata: 0x0042A1B8
	public const string ArgumentOutOfRange_NeedNonNegNumRequired = "Non-negative number required."; // Metadata: 0x0042A1DE
	public const string ArgumentOutOfRange_NeedPosNum = "Positive number required."; // Metadata: 0x0042A1FF
	public const string ArgumentOutOfRange_Timeout = "The timeout must be greater than or equal to -1."; // Metadata: 0x0042A21C
	public const string ArgumentOutOfRange_WriteTimeout = "The timeout must be either a positive number or -1."; // Metadata: 0x0042A250
	public const string IndexOutOfRange_IORaceCondition = "Probable I/O race condition detected while copying memory.  The I/O package is not thread safe by default.  In multithreaded applications, a stream must be accessed in a thread-safe way, such as a thread-safe wrapper returned by TextReader\'s or TextWriter\'s Synchronized methods.  This also applies to classes like StreamWriter and StreamReader."; // Metadata: 0x0042A287
	public const string IO_BindHandleFailed = "BindHandle for ThreadPool failed on this handle."; // Metadata: 0x0042A3E4
	public const string IO_OperationAborted = "The I/O operation has been aborted because of either a thread exit or an application request."; // Metadata: 0x0042A418
	public const string NotSupported_UnseekableStream = "Stream does not support seeking."; // Metadata: 0x0042A479
	public const string ObjectDisposed_StreamClosed = "Can not access a closed Stream."; // Metadata: 0x0042A49D
	public const string InvalidNullEmptyArgument = "Argument {0} cannot be null or zero-length."; // Metadata: 0x0042A4C0
	public const string Arg_WrongAsyncResult = "IAsyncResult object did not come from the corresponding async method on this type."; // Metadata: 0x0042A4EF
	public const string InvalidOperation_EndReadCalledMultiple = "EndRead can only be called once for each asynchronous operation."; // Metadata: 0x0042A545
	public const string InvalidOperation_EndWriteCalledMultiple = "EndWrite can only be called once for each asynchronous operation."; // Metadata: 0x0042A589
	public const string IO_PortNotFound = "The specified port does not exist."; // Metadata: 0x0042A5CE
	public const string IO_PortNotFoundFileName = "The port \'{0}\' does not exist."; // Metadata: 0x0042A5F4
	public const string UnauthorizedAccess_IODenied_NoPathName = "Access to the port is denied."; // Metadata: 0x0042A616
	public const string IO_PathTooLong = "The specified port name is too long.  The port name must be less than 260 characters."; // Metadata: 0x0042A637
	public const string IO_SharingViolation_NoFileName = "The process cannot access the port because it is being used by another process."; // Metadata: 0x0042A690
	public const string IO_SharingViolation_File = "The process cannot access the port \'{0}\' because it is being used by another process."; // Metadata: 0x0042A6E3
	public const string UnauthorizedAccess_IODenied_Path = "Access to the port \'{0}\' is denied."; // Metadata: 0x0042A73C
	public const string net_log_listener_delegate_exception = "Sending 500 response, AuthenticationSchemeSelectorDelegate threw an exception: {0}."; // Metadata: 0x0042A763
	public const string net_log_listener_unsupported_authentication_scheme = "Received a request with an unsupported authentication scheme, Authorization:{0} SupportedSchemes:{1}."; // Metadata: 0x0042A7BA
	public const string net_log_listener_unmatched_authentication_scheme = "Received a request with an unmatched or no authentication scheme. AuthenticationSchemes:{0}, Authorization:{1}."; // Metadata: 0x0042A823
	public const string net_io_invalidasyncresult = "The IAsyncResult object was not returned from the corresponding asynchronous method on this class."; // Metadata: 0x0042A896
	public const string net_io_invalidendcall = "{0} can only be called once for each asynchronous operation."; // Metadata: 0x0042A8FC
	public const string net_listener_cannot_set_custom_cbt = "Custom channel bindings are not supported."; // Metadata: 0x0042A93C
	public const string net_listener_detach_error = "Can\'t detach Url group from request queue. Status code: {0}."; // Metadata: 0x0042A96A
	public const string net_listener_scheme = "Only Uri prefixes starting with \'http://\' or \'https://\' are supported."; // Metadata: 0x0042A9AA
	public const string net_listener_host = "Only Uri prefixes with a valid hostname are supported."; // Metadata: 0x0042A9F4
	public const string net_listener_mustcall = "Please call the {0} method before calling this method."; // Metadata: 0x0042AA2E
	public const string net_listener_slash = "Only Uri prefixes ending in \'/\' are allowed."; // Metadata: 0x0042AA68
	public const string net_listener_already = "Failed to listen on prefix \'{0}\' because it conflicts with an existing registration on the machine."; // Metadata: 0x0042AA98
	public const string net_log_listener_no_cbt_disabled = "No channel binding check because extended protection is disabled."; // Metadata: 0x0042AAFF
	public const string net_log_listener_no_cbt_http = "No channel binding check for requests without a secure channel."; // Metadata: 0x0042AB44
	public const string net_log_listener_no_cbt_trustedproxy = "No channel binding check for the trusted proxy scenario."; // Metadata: 0x0042AB87
	public const string net_log_listener_cbt = "Channel binding check enabled."; // Metadata: 0x0042ABC3
	public const string net_log_listener_no_spn_kerberos = "No explicit service name check because Kerberos authentication already validates the service name."; // Metadata: 0x0042ABE5
	public const string net_log_listener_no_spn_disabled = "No service name check because extended protection is disabled."; // Metadata: 0x0042AC4B
	public const string net_log_listener_no_spn_cbt = "No service name check because the channel binding was already checked."; // Metadata: 0x0042AC8D
	public const string net_log_listener_no_spn_whensupported = "No service name check because the client did not provide a service name and the server was configured for PolicyEnforcement.WhenSupported."; // Metadata: 0x0042ACD7
	public const string net_log_listener_no_spn_loopback = "No service name check because the authentication was from a client on the local machine."; // Metadata: 0x0042AD65
	public const string net_log_listener_spn = "Client provided service name \'{0}\'."; // Metadata: 0x0042ADC1
	public const string net_log_listener_spn_passed = "Service name check succeeded."; // Metadata: 0x0042ADE8
	public const string net_log_listener_spn_failed = "Service name check failed."; // Metadata: 0x0042AE09
	public const string net_log_listener_spn_failed_always = "Service name check failed because the client did not provide a service name and the server was configured for PolicyEnforcement.Always."; // Metadata: 0x0042AE27
	public const string net_log_listener_spn_failed_empty = "No acceptable service names were configured!"; // Metadata: 0x0042AEB2
	public const string net_log_listener_spn_failed_dump = "Dumping acceptable service names:"; // Metadata: 0x0042AEE2
	public const string net_log_listener_spn_add = "Adding default service name \'{0}\' from prefix \'{1}\'."; // Metadata: 0x0042AF07
	public const string net_log_listener_spn_not_add = "No default service name added for prefix \'{0}\'."; // Metadata: 0x0042AF3F
	public const string net_log_listener_spn_remove = "Removing default service name \'{0}\' from prefix \'{1}\'."; // Metadata: 0x0042AF72
	public const string net_log_listener_spn_not_remove = "No default service name removed for prefix \'{0}\'."; // Metadata: 0x0042AFAC
	public const string net_listener_no_spns = "No service names could be determined from the registered prefixes. Either add prefixes from which default service names can be derived or specify an ExtendedProtectionPolicy object which contains an explicit list of service names."; // Metadata: 0x0042AFE1
	public const string net_ssp_dont_support_cbt = "The Security Service Providers don\'t support extended protection. Please install the latest Security Service Providers update."; // Metadata: 0x0042B0CB
	public const string net_PropertyNotImplementedException = "This property is not implemented by this class."; // Metadata: 0x0042B14D
	public const string net_array_too_small = "The target array is too small."; // Metadata: 0x0042B180
	public const string net_listener_mustcompletecall = "The in-progress method {0} must be completed first."; // Metadata: 0x0042B1A2
	public const string net_listener_invalid_cbt_type = "Querying the {0} Channel Binding is not supported."; // Metadata: 0x0042B1D9
	public const string net_listener_callinprogress = "Cannot re-call {0} while a previous call is still in progress."; // Metadata: 0x0042B20F
	public const string net_log_listener_cant_create_uri = "Can\'t create Uri from string \'{0}://{1}{2}{3}\'."; // Metadata: 0x0042B251
	public const string net_log_listener_cant_convert_raw_path = "Can\'t convert Uri path \'{0}\' using encoding \'{1}\'."; // Metadata: 0x0042B284
	public const string net_log_listener_cant_convert_percent_value = "Can\'t convert percent encoded value \'{0}\'."; // Metadata: 0x0042B2BA
	public const string net_log_listener_cant_convert_to_utf8 = "Can\'t convert string \'{0}\' into UTF-8 bytes: {1}"; // Metadata: 0x0042B2E8
	public const string net_log_listener_cant_convert_bytes = "Can\'t convert bytes \'{0}\' into UTF-16 characters: {1}"; // Metadata: 0x0042B31C
	public const string net_invalidstatus = "The status code must be exactly three digits."; // Metadata: 0x0042B355
	public const string net_WebHeaderInvalidControlChars = "Specified value has invalid Control characters."; // Metadata: 0x0042B386
	public const string net_rspsubmitted = "This operation cannot be performed after the response has been submitted."; // Metadata: 0x0042B3B9
	public const string net_nochunkuploadonhttp10 = "Chunked encoding upload is not supported on the HTTP/1.0 protocol."; // Metadata: 0x0042B406
	public const string net_cookie_exists = "Cookie already exists."; // Metadata: 0x0042B44C
	public const string net_clsmall = "The Content-Length value must be greater than or equal to zero."; // Metadata: 0x0042B466
	public const string net_wrongversion = "Only HTTP/1.0 and HTTP/1.1 version requests are currently supported."; // Metadata: 0x0042B4A9
	public const string net_noseek = "This stream does not support seek operations."; // Metadata: 0x0042B4F1
	public const string net_writeonlystream = "The stream does not support reading."; // Metadata: 0x0042B522
	public const string net_entitytoobig = "Bytes to be written to the stream exceed the Content-Length bytes size specified."; // Metadata: 0x0042B54A
	public const string net_io_notenoughbyteswritten = "Cannot close stream until all bytes are written."; // Metadata: 0x0042B59F
	public const string net_listener_close_urlgroup_error = "Can\'t close Url group. Status code: {0}."; // Metadata: 0x0042B5D3
	public const string net_WebSockets_NativeSendResponseHeaders = "An error occurred when sending the WebSocket HTTP upgrade response during the {0} operation. The HRESULT returned is \'{1}\'"; // Metadata: 0x0042B5FF
	public const string net_WebSockets_ClientAcceptingNoProtocols = "The WebSocket client did not request any protocols, but server attempted to accept \'{0}\' protocol(s). "; // Metadata: 0x0042B67D
	public const string net_WebSockets_AcceptUnsupportedProtocol = "The WebSocket client request requested \'{0}\' protocol(s), but server is only accepting \'{1}\' protocol(s)."; // Metadata: 0x0042B6E7
	public const string net_WebSockets_AcceptNotAWebSocket = "The {0} operation was called on an incoming request that did not specify a \'{1}: {2}\' header or the {2} header not contain \'{3}\'. {2} specified by the client was \'{4}\'."; // Metadata: 0x0042B754
	public const string net_WebSockets_AcceptHeaderNotFound = "The {0} operation was called on an incoming WebSocket request without required \'{1}\' header. "; // Metadata: 0x0042B800
	public const string net_WebSockets_AcceptUnsupportedWebSocketVersion = "The {0} operation was called on an incoming request with WebSocket version \'{1}\', expected \'{2}\'. "; // Metadata: 0x0042B861
	public const string net_WebSockets_InvalidEmptySubProtocol = "Empty string is not a valid subprotocol value. Please use \\\"null\\\" to specify no value."; // Metadata: 0x0042B8C7
	public const string net_WebSockets_InvalidCharInProtocolString = "The WebSocket protocol \'{0}\' is invalid because it contains the invalid character \'{1}\'."; // Metadata: 0x0042B922
	public const string net_WebSockets_ReasonNotNull = "The close status description \'{0}\' is invalid. When using close status code \'{1}\' the description must be null."; // Metadata: 0x0042B97E
	public const string net_WebSockets_InvalidCloseStatusCode = "The close status code \'{0}\' is reserved for system use only and cannot be specified when calling this method."; // Metadata: 0x0042B9F1
	public const string net_WebSockets_InvalidCloseStatusDescription = "The close status description \'{0}\' is too long. The UTF8-representation of the status description must not be longer than {1} bytes."; // Metadata: 0x0042BA62
	public const string net_WebSockets_ArgumentOutOfRange_TooSmall = "The argument must be a value greater than {0}."; // Metadata: 0x0042BAEA
	public const string net_WebSockets_ArgumentOutOfRange_TooBig = "The value of the \'{0}\' parameter ({1}) must be less than or equal to {2}."; // Metadata: 0x0042BB1C
	public const string net_WebSockets_UnsupportedPlatform = "The WebSocket protocol is not supported on this platform."; // Metadata: 0x0042BB69
	public const string net_readonlystream = "The stream does not support writing."; // Metadata: 0x0042BBA6
	public const string net_WebSockets_InvalidState_ClosedOrAborted = "The \'{0}\' instance cannot be used for communication because it has been transitioned into the \'{1}\' state."; // Metadata: 0x0042BBCE
	public const string net_WebSockets_ReceiveAsyncDisallowedAfterCloseAsync = "The WebSocket is in an invalid state for this operation. The \'{0}\' method has already been called before on this instance. Use \'{1}\' instead to keep being able to receive data but close the output channel."; // Metadata: 0x0042BC3C
	public const string net_Websockets_AlreadyOneOutstandingOperation = "There is already one outstanding \'{0}\' call for this WebSocket instance. ReceiveAsync and SendAsync can be called simultaneously, but at most one outstanding operation for each of them is allowed at the same time."; // Metadata: 0x0042BD0D
	public const string net_WebSockets_InvalidMessageType = "The received message type \'{2}\' is invalid after calling {0}. {0} should only be used if no more data is expected from the remote endpoint. Use \'{1}\' instead to keep being able to receive data but close the output channel."; // Metadata: 0x0042BDE6
	public const string net_WebSockets_InvalidBufferType = "The buffer type \'{0}\' is invalid. Valid buffer types are: \'{1}\', \'{2}\', \'{3}\', \'{4}\', \'{5}\'."; // Metadata: 0x0042BEC8
	public const string net_WebSockets_ArgumentOutOfRange_InternalBuffer = "The byte array must have a length of at least \'{0}\' bytes.  "; // Metadata: 0x0042BF28
	public const string net_WebSockets_Argument_InvalidMessageType = "The message type \'{0}\' is not allowed for the \'{1}\' operation. Valid message types are: \'{2}, {3}\'. To close the WebSocket, use the \'{4}\' operation instead. "; // Metadata: 0x0042BF68
	public const string net_securitypackagesupport = "The requested security package is not supported."; // Metadata: 0x0042C009
	public const string net_log_operation_failed_with_error = "{0} failed with error {1}."; // Metadata: 0x0042C03D
	public const string net_MethodNotImplementedException = "This method is not implemented by this class."; // Metadata: 0x0042C05B
	public const string event_OperationReturnedSomething = "{0} returned {1}."; // Metadata: 0x0042C08C
	public const string net_invalid_enum = "The specified value is not valid in the \'{0}\' enumeration."; // Metadata: 0x0042C0A1
	public const string net_auth_message_not_encrypted = "Protocol error: A received message contains a valid signature but it was not encrypted as required by the effective Protection Level."; // Metadata: 0x0042C0DF
	public const string SSPIInvalidHandleType = "\'{0}\' is not a supported handle type."; // Metadata: 0x0042C168
	public const string net_cannot_change_after_headers = "Cannot be changed after headers are sent."; // Metadata: 0x0042C191
	public const string offset_out_of_range = "Offset exceeds the length of buffer."; // Metadata: 0x0042C1BE
	public const string net_io_operation_aborted = "I/O operation aborted: \'{0}\'."; // Metadata: 0x0042C1E6
	public const string net_invalid_path = "Invalid path."; // Metadata: 0x0042C207
	public const string net_no_client_certificate = "Client certificate not found."; // Metadata: 0x0042C218
	public const string net_listener_auth_errors = "Authentication errors."; // Metadata: 0x0042C239
	public const string net_listener_close = "Listener closed."; // Metadata: 0x0042C253
	public const string net_invalid_port = "Invalid port in prefix."; // Metadata: 0x0042C267
	public const string net_WebSockets_InvalidState = "The WebSocket is in an invalid state (\'{0}\') for this operation. Valid states are: \'{1}\'"; // Metadata: 0x0042C282

	// Methods
	internal static string GetString(string name, params /* 0x00A42BF4-0x00A42C04 */ object[] args) => default; // 0x01975E64-0x01975EE4
	internal static string GetString(CultureInfo culture, string name, params /* 0x00A42C04-0x00A42C14 */ object[] args) => default; // 0x01975EE4-0x01975EEC
	internal static string GetString(string name) => default; // 0x01975EEC-0x01975EF0
	internal static string GetString(CultureInfo culture, string name) => default; // 0x01975EF0-0x01975EF8
	internal static string Format(string resourceFormat, params /* 0x00A42C14-0x00A42C24 */ object[] args) => default; // 0x01975EF8-0x01975F90
	internal static string Format(string resourceFormat, object p1) => default; // 0x01975F90-0x01976010
	internal static string Format(string resourceFormat, object p1, object p2) => default; // 0x01976010-0x01976098
	internal static string Format(string resourceFormat, object p1, object p2, object p3) => default; // 0x01976098-0x01976130
	public static object GetObject(string name) => default; // 0x01976130-0x01976134
}

namespace ObjCRuntimeInternal
{
	internal interface INativeObject // TypeDefIndex: 4651
	{
		// Properties
		IntPtr Handle { get; }
	}

	internal static class NativeObjectHelper // TypeDefIndex: 4652
	{
		// Extension methods
		public static IntPtr GetHandle(this INativeObject self) => default; // 0x01975DAC-0x01975E64
	}
}

namespace Microsoft.VisualBasic
{
	public class VBCodeProvider : System.CodeDom.Compiler.CodeDomProvider // TypeDefIndex: 6313
	{
		// Properties
		public override string FileExtension { get => default; } // 0x01038500-0x01038540 
		public override LanguageOptions LanguageOptions { get => default; } // 0x01038540-0x01038580 
	
		// Constructors
		public VBCodeProvider() {} // 0x01038480-0x010384C0
		public VBCodeProvider(IDictionary<string, string> providerOptions) {} // 0x010384C0-0x01038500
	
		// Methods
		[Obsolete] // 0x00A42B14-0x00A42B4C
		public override ICodeCompiler CreateCompiler() => default; // 0x01038580-0x010385C0
		[Obsolete] // 0x00A42B4C-0x00A42B84
		public override ICodeGenerator CreateGenerator() => default; // 0x010385C0-0x01038600
		public override void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options) {} // 0x01038600-0x01038640
		public override TypeConverter GetConverter(Type type) => default; // 0x01038640-0x01038680
	}
}

namespace Microsoft.CSharp
{
	public class CSharpCodeProvider : System.CodeDom.Compiler.CodeDomProvider // TypeDefIndex: 6314
	{
		// Properties
		public override string FileExtension { get => default; } // 0x01038340-0x01038380 
	
		// Constructors
		public CSharpCodeProvider() {} // 0x010382C0-0x01038300
		public CSharpCodeProvider(IDictionary<string, string> providerOptions) {} // 0x01038300-0x01038340
	
		// Methods
		[Obsolete] // 0x00A42B84-0x00A42BBC
		public override ICodeCompiler CreateCompiler() => default; // 0x01038380-0x010383C0
		[Obsolete] // 0x00A42BBC-0x00A42BF4
		public override ICodeGenerator CreateGenerator() => default; // 0x010383C0-0x01038400
		public override void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options) {} // 0x01038400-0x01038440
		public override TypeConverter GetConverter(Type type) => default; // 0x01038440-0x01038480
	}
}

internal static class SR // TypeDefIndex: 6429
{
	// Fields
	public const string ArgumentOutOfRange_NeedNonNegNum = "Non negative number is required."; // Metadata: 0x004319A8
	public const string Argument_WrongAsyncResult = "IAsyncResult object did not come from the corresponding async method on this type."; // Metadata: 0x004319CC
	public const string Argument_InvalidOffLen = "Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection."; // Metadata: 0x00431A22
	public const string Argument_NeedNonemptyPipeName = "pipeName cannot be an empty string."; // Metadata: 0x00431AB8
	public const string Argument_EmptyServerName = "serverName cannot be an empty string.  Use \".\" for current machine."; // Metadata: 0x00431ADF
	public const string Argument_NonContainerInvalidAnyFlag = "This flag may not be set on a pipe."; // Metadata: 0x00431B26
	public const string Argument_InvalidHandle = "Invalid handle."; // Metadata: 0x00431B4D
	public const string ArgumentNull_Buffer = "Buffer cannot be null."; // Metadata: 0x00431B60
	public const string ArgumentNull_ServerName = "serverName cannot be null. Use \".\" for current machine."; // Metadata: 0x00431B7A
	public const string ArgumentOutOfRange_AdditionalAccessLimited = "additionalAccessRights is limited to the PipeAccessRights.ChangePermissions, PipeAccessRights.TakeOwnership, and PipeAccessRights.AccessSystemSecurity flags when creating NamedPipeServerStreams."; // Metadata: 0x00431BB5
	public const string ArgumentOutOfRange_AnonymousReserved = "The pipeName \"anonymous\" is reserved."; // Metadata: 0x00431C7B
	public const string ArgumentOutOfRange_TransmissionModeByteOrMsg = "For named pipes, transmission mode can be TransmissionMode.Byte or PipeTransmissionMode.Message. For anonymous pipes, transmission mode can be TransmissionMode.Byte."; // Metadata: 0x00431CA4
	public const string ArgumentOutOfRange_DirectionModeInOrOut = "PipeDirection.In or PipeDirection.Out required."; // Metadata: 0x00431D4D
	public const string ArgumentOutOfRange_DirectionModeInOutOrInOut = "For named pipes, the pipe direction can be PipeDirection.In, PipeDirection.Out or PipeDirection.InOut. For anonymous pipes, the pipe direction can be PipeDirection.In or PipeDirection.Out."; // Metadata: 0x00431D80
	public const string ArgumentOutOfRange_ImpersonationInvalid = "TokenImpersonationLevel.None, TokenImpersonationLevel.Anonymous, TokenImpersonationLevel.Identification, TokenImpersonationLevel.Impersonation or TokenImpersonationLevel.Delegation required."; // Metadata: 0x00431E40
	public const string ArgumentOutOfRange_ImpersonationOptionsInvalid = "impersonationOptions contains an invalid flag."; // Metadata: 0x00431F02
	public const string ArgumentOutOfRange_OptionsInvalid = "options contains an invalid flag."; // Metadata: 0x00431F34
	public const string ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable = "HandleInheritability.None or HandleInheritability.Inheritable required."; // Metadata: 0x00431F59
	public const string ArgumentOutOfRange_InvalidPipeAccessRights = "Invalid PipeAccessRights flag."; // Metadata: 0x00431FA4
	public const string ArgumentOutOfRange_InvalidTimeout = "Timeout must be non-negative or equal to -1 (Timeout.Infinite)"; // Metadata: 0x00431FC6
	public const string ArgumentOutOfRange_MaxNumServerInstances = "maxNumberOfServerInstances must either be a value between 1 and 254, or NamedPipeServerStream.MaxAllowedServerInstances (to obtain the maximum number allowed by system resources)."; // Metadata: 0x00432008
	public const string ArgumentOutOfRange_NeedValidPipeAccessRights = "Need valid PipeAccessRights value."; // Metadata: 0x004320BF
	public const string IndexOutOfRange_IORaceCondition = "Probable I/O race condition detected while copying memory. The I/O package is not thread safe by default unless stated otherwise. In multithreaded applications, access streams in a thread-safe way, such as a thread-safe wrapper returned by TextReader\'s or TextWriter\'s Synchronized methods. This also applies to classes like StreamWriter and StreamReader."; // Metadata: 0x004320E5
	public const string InvalidOperation_EndReadCalledMultiple = "EndRead can only be called once for each asynchronous operation."; // Metadata: 0x0043224C
	public const string InvalidOperation_EndWriteCalledMultiple = "EndWrite can only be called once for each asynchronous operation."; // Metadata: 0x00432290
	public const string InvalidOperation_EndWaitForConnectionCalledMultiple = "EndWaitForConnection can only be called once for each asynchronous operation."; // Metadata: 0x004322D5
	public const string InvalidOperation_PipeNotYetConnected = "Pipe hasn\'t been connected yet."; // Metadata: 0x00432326
	public const string InvalidOperation_PipeDisconnected = "Pipe is in a disconnected state."; // Metadata: 0x00432349
	public const string InvalidOperation_PipeHandleNotSet = "Pipe handle has not been set.  Did your PipeStream implementation call InitializeHandle?"; // Metadata: 0x0043236D
	public const string InvalidOperation_PipeNotAsync = "Pipe is not opened in asynchronous mode."; // Metadata: 0x004323C9
	public const string InvalidOperation_PipeReadModeNotMessage = "ReadMode is not of PipeTransmissionMode.Message."; // Metadata: 0x004323F5
	public const string InvalidOperation_PipeMessageTypeNotSupported = "This pipe does not support message type transmission."; // Metadata: 0x00432429
	public const string InvalidOperation_PipeAlreadyConnected = "Already in a connected state."; // Metadata: 0x00432462
	public const string InvalidOperation_PipeAlreadyDisconnected = "Already in a disconnected state."; // Metadata: 0x00432483
	public const string InvalidOperation_PipeClosed = "Pipe is closed."; // Metadata: 0x004324A7
	public const string IO_FileTooLongOrHandleNotSync = "IO operation will not work. Most likely the file will become too long or the handle was not opened to support synchronous IO operations."; // Metadata: 0x004324BA
	public const string IO_EOF_ReadBeyondEOF = "Unable to read beyond the end of the stream."; // Metadata: 0x00432546
	public const string IO_FileNotFound = "Unable to find the specified file."; // Metadata: 0x00432576
	public const string IO_FileNotFound_FileName = "Could not find file \'{0}\'."; // Metadata: 0x0043259C
	public const string IO_IO_AlreadyExists_Name = "Cannot create \"{0}\" because a file or directory with the same name already exists."; // Metadata: 0x004325BA
	public const string IO_IO_BindHandleFailed = "BindHandle for ThreadPool failed on this handle."; // Metadata: 0x00432610
	public const string IO_IO_FileExists_Name = "The file \'{0}\' already exists."; // Metadata: 0x00432644
	public const string IO_IO_NoPermissionToDirectoryName = "<Path discovery permission to the specified directory was denied.>"; // Metadata: 0x00432666
	public const string IO_IO_SharingViolation_File = "The process cannot access the file \'{0}\' because it is being used by another process."; // Metadata: 0x004326AC
	public const string IO_IO_SharingViolation_NoFileName = "The process cannot access the file because it is being used by another process."; // Metadata: 0x00432705
	public const string IO_IO_PipeBroken = "Pipe is broken."; // Metadata: 0x00432758
	public const string IO_IO_InvalidPipeHandle = "Invalid pipe handle."; // Metadata: 0x0043276B
	public const string IO_OperationAborted = "IO operation was aborted unexpectedly."; // Metadata: 0x00432783
	public const string IO_DriveNotFound_Drive = "Could not find the drive \'{0}\'. The drive might not be ready or might not be mapped."; // Metadata: 0x004327AD
	public const string IO_PathNotFound_Path = "Could not find a part of the path \'{0}\'."; // Metadata: 0x00432805
	public const string IO_PathNotFound_NoPathName = "Could not find a part of the path."; // Metadata: 0x00432831
	public const string IO_PathTooLong = "The specified path, file name, or both are too long. The fully qualified file name must be less than 260 characters, and the directory name must be less than 248 characters."; // Metadata: 0x00432857
	public const string NotSupported_MemStreamNotExpandable = "Memory stream is not expandable."; // Metadata: 0x00432908
	public const string NotSupported_UnreadableStream = "Stream does not support reading."; // Metadata: 0x0043292C
	public const string NotSupported_UnseekableStream = "Stream does not support seeking."; // Metadata: 0x00432950
	public const string NotSupported_UnwritableStream = "Stream does not support writing."; // Metadata: 0x00432974
	public const string NotSupported_AnonymousPipeUnidirectional = "Anonymous pipes can only be in one direction."; // Metadata: 0x00432998
	public const string NotSupported_AnonymousPipeMessagesNotSupported = "Anonymous pipes do not support PipeTransmissionMode.Message ReadMode."; // Metadata: 0x004329C9
	public const string ObjectDisposed_FileClosed = "Cannot access a closed file."; // Metadata: 0x00432A12
	public const string ObjectDisposed_PipeClosed = "Cannot access a closed pipe."; // Metadata: 0x00432A32
	public const string ObjectDisposed_ReaderClosed = "Cannot read from a closed TextReader."; // Metadata: 0x00432A52
	public const string ObjectDisposed_StreamClosed = "Cannot access a closed Stream."; // Metadata: 0x00432A7B
	public const string ObjectDisposed_WriterClosed = "Cannot write to a closed TextWriter."; // Metadata: 0x00432A9D
	public const string PlatformNotSupported_NamedPipeServers = "Named Pipe Servers are not supported on Windows 95/98/ME."; // Metadata: 0x00432AC5
	public const string UnauthorizedAccess_IODenied_Path = "Access to the path \'{0}\' is denied."; // Metadata: 0x00432B02
	public const string UnauthorizedAccess_IODenied_NoPathName = "Access to the path is denied."; // Metadata: 0x00432B29
	public const string TraceAsTraceSource = "Trace"; // Metadata: 0x00432B4A
	public const string ArgumentOutOfRange_NeedValidLogRetention = "Need valid log retention option."; // Metadata: 0x00432B53
	public const string ArgumentOutOfRange_NeedMaxFileSizeGEBufferSize = "Maximum file size value should be greater than or equal to bufferSize."; // Metadata: 0x00432B77
	public const string ArgumentOutOfRange_NeedValidMaxNumFiles = "Maximum number of files value should be greater than or equal to \'{0}\' for this retention"; // Metadata: 0x00432BC1
	public const string ArgumentOutOfRange_NeedValidId = "The ID parameter must be in the range {0} through {1}."; // Metadata: 0x00432C1E
	public const string ArgumentOutOfRange_MaxArgExceeded = "The total number of parameters must not exceed {0}."; // Metadata: 0x00432C58
	public const string ArgumentOutOfRange_MaxStringsExceeded = "The number of String parameters must not exceed {0}."; // Metadata: 0x00432C8F
	public const string NotSupported_DownLevelVista = "This functionality is only supported in Windows Vista and above."; // Metadata: 0x00432CC7
	public const string Argument_NeedNonemptyDelimiter = "Delimiter cannot be an empty string."; // Metadata: 0x00432D0B
	public const string NotSupported_SetTextWriter = "Setting TextWriter is unsupported on this listener."; // Metadata: 0x00432D33
	public const string Perflib_PlatformNotSupported = "Classes in System.Diagnostics.PerformanceData is only supported in Windows Vista and above."; // Metadata: 0x00432D6A
	public const string Perflib_Argument_CounterSetAlreadyRegister = "CounterSet \'{0}\' already registered."; // Metadata: 0x00432DC9
	public const string Perflib_Argument_InvalidCounterType = "CounterType \'{0}\' is not a valid CounterType."; // Metadata: 0x00432DF1
	public const string Perflib_Argument_InvalidCounterSetInstanceType = "CounterSetInstanceType \'{0}\' is not a valid CounterSetInstanceType."; // Metadata: 0x00432E22
	public const string Perflib_Argument_InstanceAlreadyExists = "Instance \'{0}\' already exists in CounterSet \'{1}\'."; // Metadata: 0x00432E69
	public const string Perflib_Argument_CounterAlreadyExists = "CounterId \'{0}\' already added to CounterSet \'{1}\'."; // Metadata: 0x00432E9F
	public const string Perflib_Argument_CounterNameAlreadyExists = "CounterName \'{0}\' already added to CounterSet \'{1}\'."; // Metadata: 0x00432ED5
	public const string Perflib_Argument_ProviderNotFound = "CounterSet provider \'{0}\' not found."; // Metadata: 0x00432F0D
	public const string Perflib_Argument_InvalidInstance = "Single instance type CounterSet \'{0}\' can only have 1 CounterSetInstance."; // Metadata: 0x00432F35
	public const string Perflib_Argument_EmptyInstanceName = "Non-empty instanceName required."; // Metadata: 0x00432F82
	public const string Perflib_Argument_EmptyCounterName = "Non-empty counterName required."; // Metadata: 0x00432FA6
	public const string Perflib_InsufficientMemory_InstanceCounterBlock = "Cannot allocate raw counter data for CounterSet \'{0}\' Instance \'{1}\'."; // Metadata: 0x00432FC9
	public const string Perflib_InsufficientMemory_CounterSetTemplate = "Cannot allocate memory for CounterSet \'{0}\' template with size \'{1}\'."; // Metadata: 0x00433012
	public const string Perflib_InvalidOperation_CounterRefValue = "Cannot locate raw counter data location for CounterSet \'{0}\', Counter \'{1}, in Instance \'{2}\'."; // Metadata: 0x0043305B
	public const string Perflib_InvalidOperation_CounterSetNotInstalled = "CounterSet \'{0}\' not installed yet."; // Metadata: 0x004330BD
	public const string Perflib_InvalidOperation_InstanceNotFound = "Cannot find Instance \'{0}\' in CounterSet \'{1}\'."; // Metadata: 0x004330E4
	public const string Perflib_InvalidOperation_AddCounterAfterInstance = "Cannot AddCounter to CounterSet \'{0}\' after CreateCounterSetInstance."; // Metadata: 0x00433117
	public const string Perflib_InvalidOperation_NoActiveProvider = "CounterSet provider \'{0}\' not active."; // Metadata: 0x00433160
	public const string Perflib_InvalidOperation_CounterSetContainsNoCounter = "CounterSet \'{0}\' does not include any counters."; // Metadata: 0x00433189
	public const string Arg_ArrayPlusOffTooSmall = "Destination array is not long enough to copy all the items in the collection. Check array index and length."; // Metadata: 0x004331BC
	public const string Arg_HSCapacityOverflow = "HashSet capacity is too big."; // Metadata: 0x0043322B
	public const string InvalidOperation_EnumFailedVersion = "Collection was modified; enumeration operation may not execute."; // Metadata: 0x0043324B
	public const string InvalidOperation_EnumOpCantHappen = "Enumeration has either not started or has already finished."; // Metadata: 0x0043328E
	public const string Serialization_MissingKeys = "The Keys for this dictionary are missing."; // Metadata: 0x004332CD
	public const string LockRecursionException_RecursiveReadNotAllowed = "Recursive read lock acquisitions not allowed in this mode."; // Metadata: 0x004332FA
	public const string LockRecursionException_RecursiveWriteNotAllowed = "Recursive write lock acquisitions not allowed in this mode."; // Metadata: 0x00433338
	public const string LockRecursionException_RecursiveUpgradeNotAllowed = "Recursive upgradeable lock acquisitions not allowed in this mode."; // Metadata: 0x00433377
	public const string LockRecursionException_ReadAfterWriteNotAllowed = "A read lock may not be acquired with the write lock held in this mode."; // Metadata: 0x004333BC
	public const string LockRecursionException_WriteAfterReadNotAllowed = "Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock."; // Metadata: 0x00433406
	public const string LockRecursionException_UpgradeAfterReadNotAllowed = "Upgradeable lock may not be acquired with read lock held."; // Metadata: 0x004334F3
	public const string LockRecursionException_UpgradeAfterWriteNotAllowed = "Upgradeable lock may not be acquired with write lock held in this mode. Acquiring Upgradeable lock gives the ability to read along with an option to upgrade to a writer."; // Metadata: 0x00433530
	public const string SynchronizationLockException_MisMatchedRead = "The read lock is being released without being held."; // Metadata: 0x004335DD
	public const string SynchronizationLockException_MisMatchedWrite = "The write lock is being released without being held."; // Metadata: 0x00433614
	public const string SynchronizationLockException_MisMatchedUpgrade = "The upgradeable lock is being released without being held."; // Metadata: 0x0043364C
	public const string SynchronizationLockException_IncorrectDispose = "The lock is being disposed while still being used. It either is being held by a thread and/or has active waiters waiting to acquire the lock."; // Metadata: 0x0043368A
	public const string Cryptography_ArgECDHKeySizeMismatch = "The keys from both parties must be the same size to generate a secret agreement."; // Metadata: 0x0043371B
	public const string Cryptography_ArgECDHRequiresECDHKey = "Keys used with the ECDiffieHellmanCng algorithm must have an algorithm group of ECDiffieHellman."; // Metadata: 0x0043376F
	public const string Cryptography_ArgECDsaRequiresECDsaKey = "Keys used with the ECDsaCng algorithm must have an algorithm group of ECDsa."; // Metadata: 0x004337D3
	public const string Cryptography_ArgExpectedECDiffieHellmanCngPublicKey = "DeriveKeyMaterial requires an ECDiffieHellmanCngPublicKey."; // Metadata: 0x00433823
	public const string Cryptography_ArgMustBeCngAlgorithm = "Object must be of type CngAlgorithm."; // Metadata: 0x00433861
	public const string Cryptography_ArgMustBeCngAlgorithmGroup = "Object must be of type CngAlgorithmGroup."; // Metadata: 0x00433889
	public const string Cryptography_ArgMustBeCngKeyBlobFormat = "Object must be of type CngKeyBlobFormat."; // Metadata: 0x004338B6
	public const string Cryptography_ArgMustBeCngProvider = "Object must be of type CngProvider."; // Metadata: 0x004338E2
	public const string Cryptography_DecryptWithNoKey = "Decrypting a value requires that a key be set on the algorithm object."; // Metadata: 0x00433909
	public const string Cryptography_ECXmlSerializationFormatRequired = "XML serialization of an elliptic curve key requires using an overload which specifies the XML format to be used."; // Metadata: 0x00433953
	public const string Cryptography_InvalidAlgorithmGroup = "The algorithm group \'{0}\' is invalid."; // Metadata: 0x004339C7
	public const string Cryptography_InvalidAlgorithmName = "The algorithm name \'{0}\' is invalid."; // Metadata: 0x004339F0
	public const string Cryptography_InvalidCipherMode = "The specified cipher mode is not valid for this algorithm."; // Metadata: 0x00433A18
	public const string Cryptography_InvalidIVSize = "The specified initialization vector (IV) does not match the block size for this algorithm."; // Metadata: 0x00433A56
	public const string Cryptography_InvalidKeyBlobFormat = "The key blob format \'{0}\' is invalid."; // Metadata: 0x00433AB4
	public const string Cryptography_InvalidKeySize = "The specified key is not a valid size for this algorithm."; // Metadata: 0x00433ADD
	public const string Cryptography_InvalidPadding = "Padding is invalid and cannot be removed."; // Metadata: 0x00433B1A
	public const string Cryptography_InvalidProviderName = "The provider name \'{0}\' is invalid."; // Metadata: 0x00433B47
	public const string Cryptography_MissingDomainParameters = "Could not read the domain parameters from the XML string."; // Metadata: 0x00433B6E
	public const string Cryptography_MissingPublicKey = "Could not read the public key from the XML string."; // Metadata: 0x00433BAB
	public const string Cryptography_MissingIV = "The cipher mode specified requires that an initialization vector (IV) be used."; // Metadata: 0x00433BE1
	public const string Cryptography_MustTransformWholeBlock = "TransformBlock may only process bytes in block sized increments."; // Metadata: 0x00433C33
	public const string Cryptography_NonCompliantFIPSAlgorithm = "This implementation is not part of the Windows Platform FIPS validated cryptographic algorithms."; // Metadata: 0x00433C77
	public const string Cryptography_OpenInvalidHandle = "Cannot open an invalid handle."; // Metadata: 0x00433CDB
	public const string Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag = "The CNG key handle being opened was detected to be ephemeral, but the EphemeralKey open option was not specified."; // Metadata: 0x00433CFD
	public const string Cryptography_PartialBlock = "The input data is not a complete block."; // Metadata: 0x00433D72
	public const string Cryptography_PlatformNotSupported = "The specified cryptographic algorithm is not supported on this platform."; // Metadata: 0x00433D9D
	public const string Cryptography_TlsRequiresLabelAndSeed = "The TLS key derivation function requires both the label and seed properties to be set."; // Metadata: 0x00433DE9
	public const string Cryptography_TransformBeyondEndOfBuffer = "Attempt to transform beyond end of buffer."; // Metadata: 0x00433E43
	public const string Cryptography_UnknownEllipticCurve = "Unknown elliptic curve."; // Metadata: 0x00433E71
	public const string Cryptography_UnknownEllipticCurveAlgorithm = "Unknown elliptic curve algorithm."; // Metadata: 0x00433E8C
	public const string Cryptography_UnknownPaddingMode = "Unknown padding mode used."; // Metadata: 0x00433EB1
	public const string Cryptography_UnexpectedXmlNamespace = "The XML namespace \'{0}\' was unexpected, expected \'{1}\'."; // Metadata: 0x00433ECF
	public const string ArgumentException_RangeMinRangeMaxRangeType = "Cannot accept MinRange {0} because it is not the same type as MaxRange {1}. Verify that the MaxRange and MinRange values are of the same type and try again."; // Metadata: 0x00433F0A
	public const string ArgumentException_RangeNotIComparable = "Cannot accept MaxRange and MinRange because they are not IComparable."; // Metadata: 0x00433FAA
	public const string ArgumentException_RangeMaxRangeSmallerThanMinRange = "Cannot accept MaxRange because it is less than MinRange. Specify a MaxRange value that is greater than or equal to the MinRange value and try again."; // Metadata: 0x00433FF3
	public const string ArgumentException_CountMaxLengthSmallerThanMinLength = "MaxLength should be greater than MinLength."; // Metadata: 0x0043408B
	public const string ArgumentException_LengthMaxLengthSmallerThanMinLength = "Cannot accept MaxLength value. Specify MaxLength value greater than the value of MinLength and try again."; // Metadata: 0x004340BA
	public const string ArgumentException_UnregisteredParameterName = "Parameter {0} has not been added to this parser."; // Metadata: 0x00434127
	public const string ArgumentException_InvalidParameterName = "{0} is an invalid parameter name."; // Metadata: 0x0043415B
	public const string ArgumentException_DuplicateName = "The name {0} is already in use."; // Metadata: 0x00434180
	public const string ArgumentException_DuplicatePosition = "The position {0} is already in use."; // Metadata: 0x004341A3
	public const string ArgumentException_NoParametersFound = "The object has no parameters associated with it."; // Metadata: 0x004341CA
	public const string ArgumentException_HelpMessageBaseNameNullOrEmpty = "Help message base name may not be null or empty."; // Metadata: 0x004341FE
	public const string ArgumentException_HelpMessageResourceIdNullOrEmpty = "Help message resource id may not be null or empty."; // Metadata: 0x00434232
	public const string ArgumentException_HelpMessageNullOrEmpty = "Help message may not be null or empty."; // Metadata: 0x00434268
	public const string ArgumentException_RegexPatternNullOrEmpty = "The regular expression pattern may not be null or empty."; // Metadata: 0x00434292
	public const string ArgumentException_RequiredPositionalAfterOptionalPositional = "Optional positional parameter {0} cannot precede required positional parameter {1}."; // Metadata: 0x004342CE
	public const string ArgumentException_DuplicateParameterAttribute = "Duplicate parameter attributes with the same parameter set on parameter {0}."; // Metadata: 0x00434325
	public const string ArgumentException_MissingBaseNameOrResourceId = "On parameter {0}, either both HelpMessageBaseName and HelpMessageResourceId must be set or neither can be set."; // Metadata: 0x00434375
	public const string ArgumentException_DuplicateRemainingArgumets = "Can not set {0} as the remaining arguments parameter for parameter set {1} because that parameter set already has a parameter set as the remaining arguments parameter."; // Metadata: 0x004343E7
	public const string ArgumentException_TypeMismatchForRemainingArguments = "Parameter {0} must be an array of strings if it can have its value from the remaining arguments."; // Metadata: 0x00434492
	public const string ArgumentException_ValidationParameterTypeMismatch = "Validator {0} may not be applied to a parameter of type {1}."; // Metadata: 0x004344F6
	public const string ArgumentException_ParserBuiltWithValueType = "The parameter toBind may not be an instance of a value type."; // Metadata: 0x00434536
	public const string InvalidOperationException_GetParameterTypeMismatch = "Parameter {0} may not retrieved with type {1} since it is of type {2}."; // Metadata: 0x00434576
	public const string InvalidOperationException_GetParameterValueBeforeParse = "Parse must be called before retrieving parameter values."; // Metadata: 0x004345C0
	public const string InvalidOperationException_SetRemainingArgumentsParameterAfterParse = "AllowRemainingArguments may not be set after Parse has been called."; // Metadata: 0x004345FC
	public const string InvalidOperationException_AddParameterAfterParse = "Parameters may not be added after Parse has been called."; // Metadata: 0x00434643
	public const string InvalidOperationException_BindAfterBind = "Parse may only be called once."; // Metadata: 0x0043467F
	public const string InvalidOperationException_GetRemainingArgumentsNotAllowed = "GetRemainingArguments may not be called unless AllowRemainingArguments is set to true."; // Metadata: 0x004346A1
	public const string InvalidOperationException_ParameterSetBeforeParse = "The SpecifiedParameterSet property may only be accessed after Parse has been called successfully."; // Metadata: 0x004346FB
	public const string CommandLineParser_Aliases = "Aliases"; // Metadata: 0x00434760
	public const string CommandLineParser_ErrorMessagePrefix = "Error"; // Metadata: 0x0043476B
	public const string CommandLineParser_HelpMessagePrefix = "Usage"; // Metadata: 0x00434774
	public const string ParameterBindingException_AmbiguousParameterName = "Prefix {0} resolves to multiple parameters: {1}.  Use a more specific prefix for this parameter."; // Metadata: 0x0043477D
	public const string ParameterBindingException_ParameterValueAlreadySpecified = "Parameter {0} already given value of {1}."; // Metadata: 0x004347E1
	public const string ParameterBindingException_UnknownParameteName = "Unknown parameter {0}."; // Metadata: 0x0043480E
	public const string ParameterBindingException_RequiredParameterMissingCommandLineValue = "Parameter {0} must be followed by a value."; // Metadata: 0x00434828
	public const string ParameterBindingException_UnboundCommandLineArguments = "Unbound parameters left on command line: {0}."; // Metadata: 0x00434856
	public const string ParameterBindingException_UnboundMandatoryParameter = "Values for required parameters missing: {0}."; // Metadata: 0x00434887
	public const string ParameterBindingException_ResponseFileException = "Could not open response file {0}: {1}"; // Metadata: 0x004348B7
	public const string ParameterBindingException_ValididationError = "Could not validate parameter {0}: {1}"; // Metadata: 0x004348E0
	public const string ParameterBindingException_TransformationError = "Could not convert {0} to type {1}."; // Metadata: 0x00434909
	public const string ParameterBindingException_AmbiguousParameterSet = "Named parameters specify an ambiguous parameter set.  Specify more parameters by name."; // Metadata: 0x0043492F
	public const string ParameterBindingException_UnknownParameterSet = "No valid parameter set for named parameters.  Make sure all named parameters belong to the same parameter set."; // Metadata: 0x00434989
	public const string ParameterBindingException_NestedResponseFiles = "A response file may not contain references to other response files."; // Metadata: 0x004349FB
	public const string ValidateMetadataException_RangeGreaterThanMaxRangeFailure = "The value {0} was greater than the maximum value {1}. Specify a value less than or equal to the maximum value and try again."; // Metadata: 0x00434A42
	public const string ValidateMetadataException_RangeSmallerThanMinRangeFailure = "The value {0} was smaller than the minimum value {1}. Specify a value greater than or equal to the minimum value and try again."; // Metadata: 0x00434AC2
	public const string ValidateMetadataException_PatternFailure = "The value {0} does not match the pattern {1}."; // Metadata: 0x00434B45
	public const string ValidateMetadataException_CountMinLengthFailure = "The number of values should be greater than or equal to {0} instead of {1}."; // Metadata: 0x00434B76
	public const string ValidateMetadataException_CountMaxLengthFailure = "The number of values should be less than or equal to {0} instead of {1}."; // Metadata: 0x00434BC5
	public const string ValidateMetadataException_LengthMinLengthFailure = "The length should be greater than or equal to {0} instead of {1}."; // Metadata: 0x00434C11
	public const string ValidateMetadataException_LengthMaxLengthFailure = "The length should be less than or equal to {0} instead of {1}."; // Metadata: 0x00434C56
	public const string Argument_MapNameEmptyString = "Map name cannot be an empty string."; // Metadata: 0x00434C98
	public const string Argument_EmptyFile = "A positive capacity must be specified for a Memory Mapped File backed by an empty file."; // Metadata: 0x00434CBF
	public const string Argument_NewMMFWriteAccessNotAllowed = "MemoryMappedFileAccess.Write is not permitted when creating new memory mapped files. Use MemoryMappedFileAccess.ReadWrite instead."; // Metadata: 0x00434D1A
	public const string Argument_ReadAccessWithLargeCapacity = "When specifying MemoryMappedFileAccess.Read access, the capacity must not be larger than the file size."; // Metadata: 0x00434DA0
	public const string Argument_NewMMFAppendModeNotAllowed = "FileMode.Append is not permitted when creating new memory mapped files. Instead, use MemoryMappedFileView to ensure write-only access within a specified region."; // Metadata: 0x00434E0B
	public const string ArgumentNull_MapName = "Map name cannot be null."; // Metadata: 0x00434EAF
	public const string ArgumentNull_FileStream = "fileStream cannot be null."; // Metadata: 0x00434ECB
	public const string ArgumentOutOfRange_CapacityLargerThanLogicalAddressSpaceNotAllowed = "The capacity cannot be greater than the size of the system\'s logical address space."; // Metadata: 0x00434EE9
	public const string ArgumentOutOfRange_NeedPositiveNumber = "A positive number is required."; // Metadata: 0x00434F40
	public const string ArgumentOutOfRange_PositiveOrDefaultCapacityRequired = "The capacity must be greater than or equal to 0. 0 represents the the size of the file being mapped."; // Metadata: 0x00434F62
	public const string ArgumentOutOfRange_PositiveOrDefaultSizeRequired = "The size must be greater than or equal to 0. If 0 is specified, the view extends from the specified offset to the end of the file mapping."; // Metadata: 0x00434FCA
	public const string ArgumentOutOfRange_PositionLessThanCapacityRequired = "The position may not be greater or equal to the capacity of the accessor."; // Metadata: 0x00435058
	public const string ArgumentOutOfRange_CapacityGEFileSizeRequired = "The capacity may not be smaller than the file size."; // Metadata: 0x004350A5
	public const string IO_NotEnoughMemory = "Not enough memory to map view."; // Metadata: 0x004350DC
	public const string InvalidOperation_CalledTwice = "Cannot call this operation twice."; // Metadata: 0x004350FE
	public const string InvalidOperation_CantCreateFileMapping = "Cannot create file mapping."; // Metadata: 0x00435123
	public const string InvalidOperation_ViewIsNull = "The underlying MemoryMappedView object is null."; // Metadata: 0x00435142
	public const string NotSupported_DelayAllocateFileBackedNotAllowed = "The MemoryMappedFileOptions.DelayAllocatePages option is not supported with memory mapped files mapping files on disk."; // Metadata: 0x00435175
	public const string NotSupported_MMViewStreamsFixedLength = "MemoryMappedViewStreams are fixed length."; // Metadata: 0x004351EF
	public const string ObjectDisposed_ViewAccessorClosed = "Cannot access a closed accessor."; // Metadata: 0x0043521C
	public const string ObjectDisposed_StreamIsClosed = "Cannot access a closed Stream."; // Metadata: 0x00435240
	public const string NotSupported_Method = "Method not supported."; // Metadata: 0x00435262
	public const string NotSupported_SubclassOverride = "Method not supported. Derived class must override."; // Metadata: 0x0043527B
	public const string Cryptography_ArgDSARequiresDSAKey = "Keys used with the DSACng algorithm must have an algorithm group of DSA."; // Metadata: 0x004352B1
	public const string Cryptography_ArgRSAaRequiresRSAKey = "Keys used with the RSACng algorithm must have an algorithm group of RSA."; // Metadata: 0x004352FD
	public const string Cryptography_CngKeyWrongAlgorithm = "This key is for algorithm \'{0}\'. Expected \'{1}\'."; // Metadata: 0x00435349
	public const string Cryptography_DSA_HashTooShort = "The supplied hash cannot be shorter in length than the DSA key\'s Q value."; // Metadata: 0x0043537D
	public const string Cryptography_HashAlgorithmNameNullOrEmpty = "The hash algorithm name cannot be null or empty."; // Metadata: 0x004353CA
	public const string Cryptography_InvalidDsaParameters_MissingFields = "The specified DSA parameters are not valid; P, Q, G and Y are all required."; // Metadata: 0x004353FE
	public const string Cryptography_InvalidDsaParameters_MismatchedPGY = "The specified DSA parameters are not valid; P, G and Y must be the same length (the key size)."; // Metadata: 0x0043544D
	public const string Cryptography_InvalidDsaParameters_MismatchedQX = "The specified DSA parameters are not valid; Q and X (if present) must be the same length."; // Metadata: 0x004354AF
	public const string Cryptography_InvalidDsaParameters_MismatchedPJ = "The specified DSA parameters are not valid; J (if present) must be shorter than P."; // Metadata: 0x0043550C
	public const string Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey = "The specified DSA parameters are not valid; Seed, if present, must be 20 bytes long for keys shorter than 1024 bits."; // Metadata: 0x00435562
	public const string Cryptography_InvalidDsaParameters_QRestriction_ShortKey = "The specified DSA parameters are not valid; Q must be 20 bytes long for keys shorter than 1024 bits."; // Metadata: 0x004355DA
	public const string Cryptography_InvalidDsaParameters_QRestriction_LargeKey = "The specified DSA parameters are not valid; Q\'s length must be one of 20, 32 or 64 bytes."; // Metadata: 0x00435642
	public const string Cryptography_InvalidRsaParameters = "The specified RSA parameters are not valid; both Exponent and Modulus are required fields."; // Metadata: 0x0043569F
	public const string Cryptography_InvalidSignatureAlgorithm = "The hash algorithm is not supported for signatures. Only MD5, SHA1, SHA256,SHA384, and SHA512 are supported at this time."; // Metadata: 0x004356FD
	public const string Cryptography_KeyBlobParsingError = "Key Blob not in expected format."; // Metadata: 0x0043577A
	public const string Cryptography_NotSupportedKeyAlgorithm = "Key Algorithm is not supported."; // Metadata: 0x0043579E
	public const string Cryptography_NotValidPublicOrPrivateKey = "Key is not a valid public or private key."; // Metadata: 0x004357C1
	public const string Cryptography_NotValidPrivateKey = "Key is not a valid private key."; // Metadata: 0x004357EE
	public const string Cryptography_UnexpectedTransformTruncation = "CNG provider unexpectedly terminated encryption or decryption prematurely."; // Metadata: 0x00435811
	public const string Cryptography_UnsupportedPaddingMode = "The specified PaddingMode is not supported."; // Metadata: 0x0043585F
	public const string Cryptography_WeakKey = "Specified key is a known weak key for this algorithm and cannot be used."; // Metadata: 0x0043588E
	public const string Cryptography_CurveNotSupported = "The specified curve \'{0}\' or its parameters are not valid for this platform."; // Metadata: 0x004358DA
	public const string Cryptography_InvalidCurve = "The specified curve \'{0}\' is not valid for this platform."; // Metadata: 0x0043592A
	public const string Cryptography_InvalidCurveOid = "The specified Oid is not valid. The Oid.FriendlyName or Oid.Value property must be set."; // Metadata: 0x00435967
	public const string Cryptography_InvalidCurveKeyParameters = "The specified key parameters are not valid. Q.X and Q.Y are required fields. Q.X, Q.Y must be the same length. If D is specified it must be the same length as Q.X and Q.Y for named curves or the same length as Order for explicit curves."; // Metadata: 0x004359C2
	public const string Cryptography_InvalidECCharacteristic2Curve = "The specified Characteristic2 curve parameters are not valid. Polynomial, A, B, G.X, G.Y, and Order are required. A, B, G.X, G.Y must be the same length, and the same length as Q.X, Q.Y and D if those are specified. Seed, Cofactor and Hash are optional. Other parameters are not allowed."; // Metadata: 0x00435AB2
	public const string Cryptography_InvalidECPrimeCurve = "The specified prime curve parameters are not valid. Prime, A, B, G.X, G.Y and Order are required and must be the same length, and the same length as Q.X, Q.Y and D if those are specified. Seed, Cofactor and Hash are optional. Other parameters are not allowed."; // Metadata: 0x00435BD5
	public const string Cryptography_InvalidECNamedCurve = "The specified named curve parameters are not valid. Only the Oid parameter must be set."; // Metadata: 0x00435CDC
	public const string Cryptography_UnknownHashAlgorithm = "\'{0}\' is not a known hash algorithm."; // Metadata: 0x00435D37
	public const string ReducibleMustOverrideReduce = "reducible nodes must override Expression.Reduce()"; // Metadata: 0x00435D5F
	public const string MustReduceToDifferent = "node cannot reduce to itself or null"; // Metadata: 0x00435D94
	public const string ReducedNotCompatible = "cannot assign from the reduced node type to the original node type"; // Metadata: 0x00435DBC
	public const string SetterHasNoParams = "Setter must have parameters."; // Metadata: 0x00435E02
	public const string PropertyCannotHaveRefType = "Property cannot have a managed pointer type."; // Metadata: 0x00435E22
	public const string IndexesOfSetGetMustMatch = "Indexing parameters of getter and setter must match."; // Metadata: 0x00435E52
	public const string AccessorsCannotHaveVarArgs = "Accessor method should not have VarArgs."; // Metadata: 0x00435E8A
	public const string AccessorsCannotHaveByRefArgs = "Accessor indexes cannot be passed ByRef."; // Metadata: 0x00435EB6
	public const string BoundsCannotBeLessThanOne = "Bounds count cannot be less than 1"; // Metadata: 0x00435EE2
	public const string TypeMustNotBeByRef = "Type must not be ByRef"; // Metadata: 0x00435F08
	public const string TypeMustNotBePointer = "Type must not be a pointer type"; // Metadata: 0x00435F22
	public const string TypeDoesNotHaveConstructorForTheSignature = "Type doesn\'t have constructor with a given signature"; // Metadata: 0x00435F45
	public const string SetterMustBeVoid = "Setter should have void type."; // Metadata: 0x00435F7D
	public const string PropertyTypeMustMatchGetter = "Property type must match the value type of getter"; // Metadata: 0x00435F9E
	public const string PropertyTypeMustMatchSetter = "Property type must match the value type of setter"; // Metadata: 0x00435FD3
	public const string BothAccessorsMustBeStatic = "Both accessors must be static."; // Metadata: 0x00436008
	public const string OnlyStaticFieldsHaveNullInstance = "Static field requires null instance, non-static field requires non-null instance."; // Metadata: 0x0043602A
	public const string OnlyStaticPropertiesHaveNullInstance = "Static property requires null instance, non-static property requires non-null instance."; // Metadata: 0x0043607F
	public const string OnlyStaticMethodsHaveNullInstance = "Static method requires null instance, non-static method requires non-null instance."; // Metadata: 0x004360DA
	public const string PropertyTypeCannotBeVoid = "Property cannot have a void type."; // Metadata: 0x00436131
	public const string InvalidUnboxType = "Can only unbox from an object or interface type to a value type."; // Metadata: 0x00436156
	public const string ExpressionMustBeWriteable = "Expression must be writeable"; // Metadata: 0x0043619A
	public const string ArgumentMustNotHaveValueType = "Argument must not have a value type."; // Metadata: 0x004361BA
	public const string MustBeReducible = "must be reducible node"; // Metadata: 0x004361E2
	public const string AllTestValuesMustHaveSameType = "All test values must have the same type."; // Metadata: 0x004361FC
	public const string AllCaseBodiesMustHaveSameType = "All case bodies and the default body must have the same type."; // Metadata: 0x00436228
	public const string DefaultBodyMustBeSupplied = "Default body must be supplied if case bodies are not System.Void."; // Metadata: 0x00436269
	public const string LabelMustBeVoidOrHaveExpression = "Label type must be System.Void if an expression is not supplied"; // Metadata: 0x004362AE
	public const string LabelTypeMustBeVoid = "Type must be System.Void for this label argument"; // Metadata: 0x004362F1
	public const string QuotedExpressionMustBeLambda = "Quoted expression must be a lambda"; // Metadata: 0x00436325
	public const string VariableMustNotBeByRef = "Variable \'{0}\' uses unsupported type \'{1}\'. Reference types are not supported for variables."; // Metadata: 0x0043634B
	public const string DuplicateVariable = "Found duplicate parameter \'{0}\'. Each ParameterExpression in the list must be a unique object."; // Metadata: 0x004363AB
	public const string StartEndMustBeOrdered = "Start and End must be well ordered"; // Metadata: 0x0043640D
	public const string FaultCannotHaveCatchOrFinally = "fault cannot be used with catch or finally clauses"; // Metadata: 0x00436433
	public const string TryMustHaveCatchFinallyOrFault = "try must have at least one catch, finally, or fault clause"; // Metadata: 0x00436469
	public const string BodyOfCatchMustHaveSameTypeAsBodyOfTry = "Body of catch must have the same type as body of try."; // Metadata: 0x004364A7
	public const string ExtensionNodeMustOverrideProperty = "Extension node must override the property {0}."; // Metadata: 0x004364E0
	public const string UserDefinedOperatorMustBeStatic = "User-defined operator method \'{0}\' must be static."; // Metadata: 0x00436512
	public const string UserDefinedOperatorMustNotBeVoid = "User-defined operator method \'{0}\' must not be void."; // Metadata: 0x00436548
	public const string CoercionOperatorNotDefined = "No coercion operator is defined between types \'{0}\' and \'{1}\'."; // Metadata: 0x00436580
	public const string UnaryOperatorNotDefined = "The unary operator {0} is not defined for the type \'{1}\'."; // Metadata: 0x004365C2
	public const string BinaryOperatorNotDefined = "The binary operator {0} is not defined for the types \'{1}\' and \'{2}\'."; // Metadata: 0x004365FF
	public const string ReferenceEqualityNotDefined = "Reference equality is not defined for the types \'{0}\' and \'{1}\'."; // Metadata: 0x00436648
	public const string OperandTypesDoNotMatchParameters = "The operands for operator \'{0}\' do not match the parameters of method \'{1}\'."; // Metadata: 0x0043668C
	public const string OverloadOperatorTypeDoesNotMatchConversionType = "The return type of overload method for operator \'{0}\' does not match the parameter type of conversion method \'{1}\'."; // Metadata: 0x004366DC
	public const string ConversionIsNotSupportedForArithmeticTypes = "Conversion is not supported for arithmetic types without operator overloading."; // Metadata: 0x00436753
	public const string ArgumentMustBeArray = "Argument must be array"; // Metadata: 0x004367A5
	public const string ArgumentMustBeBoolean = "Argument must be boolean"; // Metadata: 0x004367BF
	public const string EqualityMustReturnBoolean = "The user-defined equality method \'{0}\' must return a boolean value."; // Metadata: 0x004367DB
	public const string ArgumentMustBeFieldInfoOrPropertyInfo = "Argument must be either a FieldInfo or PropertyInfo"; // Metadata: 0x00436822
	public const string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod = "Argument must be either a FieldInfo, PropertyInfo or MethodInfo"; // Metadata: 0x00436859
	public const string ArgumentMustBeInstanceMember = "Argument must be an instance member"; // Metadata: 0x0043689C
	public const string ArgumentMustBeInteger = "Argument must be of an integer type"; // Metadata: 0x004368C3
	public const string ArgumentMustBeArrayIndexType = "Argument for array index must be of type Int32"; // Metadata: 0x004368EA
	public const string ArgumentMustBeSingleDimensionalArrayType = "Argument must be single-dimensional, zero-based array type"; // Metadata: 0x0043691C
	public const string ArgumentTypesMustMatch = "Argument types do not match"; // Metadata: 0x0043695A
	public const string CannotAutoInitializeValueTypeElementThroughProperty = "Cannot auto initialize elements of value type through property \'{0}\', use assignment instead"; // Metadata: 0x00436979
	public const string CannotAutoInitializeValueTypeMemberThroughProperty = "Cannot auto initialize members of value type through property \'{0}\', use assignment instead"; // Metadata: 0x004369D9
	public const string IncorrectTypeForTypeAs = "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither"; // Metadata: 0x00436A38
	public const string CoalesceUsedOnNonNullType = "Coalesce used with type that cannot be null"; // Metadata: 0x00436A94
	public const string ExpressionTypeCannotInitializeArrayType = "An expression of type \'{0}\' cannot be used to initialize an array of type \'{1}\'"; // Metadata: 0x00436AC3
	public const string ArgumentTypeDoesNotMatchMember = " Argument type \'{0}\' does not match the corresponding member type \'{1}\'"; // Metadata: 0x00436B16
	public const string ArgumentMemberNotDeclOnType = " The member \'{0}\' is not declared on type \'{1}\' being created"; // Metadata: 0x00436B61
	public const string ExpressionTypeDoesNotMatchReturn = "Expression of type \'{0}\' cannot be used for return type \'{1}\'"; // Metadata: 0x00436BA2
	public const string ExpressionTypeDoesNotMatchAssignment = "Expression of type \'{0}\' cannot be used for assignment to type \'{1}\'"; // Metadata: 0x00436BE3
	public const string ExpressionTypeDoesNotMatchLabel = "Expression of type \'{0}\' cannot be used for label of type \'{1}\'"; // Metadata: 0x00436C2B
	public const string ExpressionTypeNotInvocable = "Expression of type \'{0}\' cannot be invoked"; // Metadata: 0x00436C6E
	public const string FieldNotDefinedForType = "Field \'{0}\' is not defined for type \'{1}\'"; // Metadata: 0x00436C9C
	public const string InstanceFieldNotDefinedForType = "Instance field \'{0}\' is not defined for type \'{1}\'"; // Metadata: 0x00436CC9
	public const string FieldInfoNotDefinedForType = "Field \'{0}.{1}\' is not defined for type \'{2}\'"; // Metadata: 0x00436CFF
	public const string IncorrectNumberOfIndexes = "Incorrect number of indexes"; // Metadata: 0x00436D30
	public const string IncorrectNumberOfLambdaDeclarationParameters = "Incorrect number of parameters supplied for lambda declaration"; // Metadata: 0x00436D4F
	public const string IncorrectNumberOfMembersForGivenConstructor = " Incorrect number of members for constructor"; // Metadata: 0x00436D91
	public const string IncorrectNumberOfArgumentsForMembers = "Incorrect number of arguments for the given members "; // Metadata: 0x00436DC1
	public const string LambdaTypeMustBeDerivedFromSystemDelegate = "Lambda type parameter must be derived from System.MulticastDelegate"; // Metadata: 0x00436DF9
	public const string MemberNotFieldOrProperty = "Member \'{0}\' not field or property"; // Metadata: 0x00436E40
	public const string MethodContainsGenericParameters = "Method {0} contains generic parameters"; // Metadata: 0x00436E66
	public const string MethodIsGeneric = "Method {0} is a generic method definition"; // Metadata: 0x00436E90
	public const string MethodNotPropertyAccessor = "The method \'{0}.{1}\' is not a property accessor"; // Metadata: 0x00436EBD
	public const string PropertyDoesNotHaveGetter = "The property \'{0}\' has no \'get\' accessor"; // Metadata: 0x00436EF0
	public const string PropertyDoesNotHaveSetter = "The property \'{0}\' has no \'set\' accessor"; // Metadata: 0x00436F1C
	public const string PropertyDoesNotHaveAccessor = "The property \'{0}\' has no \'get\' or \'set\' accessors"; // Metadata: 0x00436F48
	public const string NotAMemberOfType = "\'{0}\' is not a member of type \'{1}\'"; // Metadata: 0x00436F7E
	public const string NotAMemberOfAnyType = "\'{0}\' is not a member of any type"; // Metadata: 0x00436FA5
	public const string ExpressionNotSupportedForType = "The expression \'{0}\' is not supported for type \'{1}\'"; // Metadata: 0x00436FCA
	public const string UnsupportedExpressionType = "The expression type \'{0}\' is not supported"; // Metadata: 0x00437002
	public const string ParameterExpressionNotValidAsDelegate = "ParameterExpression of type \'{0}\' cannot be used for delegate parameter of type \'{1}\'"; // Metadata: 0x00437030
	public const string PropertyNotDefinedForType = "Property \'{0}\' is not defined for type \'{1}\'"; // Metadata: 0x00437089
	public const string InstancePropertyNotDefinedForType = "Instance property \'{0}\' is not defined for type \'{1}\'"; // Metadata: 0x004370B9
	public const string InstancePropertyWithoutParameterNotDefinedForType = "Instance property \'{0}\' that takes no argument is not defined for type \'{1}\'"; // Metadata: 0x004370F2
	public const string InstancePropertyWithSpecifiedParametersNotDefinedForType = "Instance property \'{0}{1}\' is not defined for type \'{2}\'"; // Metadata: 0x00437142
	public const string InstanceAndMethodTypeMismatch = "Method \'{0}\' declared on type \'{1}\' cannot be called with instance of type \'{2}\'"; // Metadata: 0x0043717E
	public const string TypeContainsGenericParameters = "Type {0} contains generic parameters"; // Metadata: 0x004371D2
	public const string TypeIsGeneric = "Type {0} is a generic type definition"; // Metadata: 0x004371FA
	public const string TypeMissingDefaultConstructor = "Type \'{0}\' does not have a default constructor"; // Metadata: 0x00437223
	public const string ElementInitializerMethodNotAdd = "Element initializer method must be named \'Add\'"; // Metadata: 0x00437255
	public const string ElementInitializerMethodNoRefOutParam = "Parameter \'{0}\' of element initializer method \'{1}\' must not be a pass by reference parameter"; // Metadata: 0x00437287
	public const string ElementInitializerMethodWithZeroArgs = "Element initializer method must have at least 1 parameter"; // Metadata: 0x004372E8
	public const string ElementInitializerMethodStatic = "Element initializer method must be an instance method"; // Metadata: 0x00437325
	public const string TypeNotIEnumerable = "Type \'{0}\' is not IEnumerable"; // Metadata: 0x0043735E
	public const string UnexpectedCoalesceOperator = "Unexpected coalesce operator."; // Metadata: 0x0043737F
	public const string InvalidCast = "Cannot cast from type \'{0}\' to type \'{1}"; // Metadata: 0x004373A0
	public const string UnhandledBinary = "Unhandled binary: {0}"; // Metadata: 0x004373CC
	public const string UnhandledBinding = "Unhandled binding "; // Metadata: 0x004373E5
	public const string UnhandledBindingType = "Unhandled Binding Type: {0}"; // Metadata: 0x004373FB
	public const string UnhandledConvert = "Unhandled convert: {0}"; // Metadata: 0x0043741A
	public const string UnhandledUnary = "Unhandled unary: {0}"; // Metadata: 0x00437434
	public const string UnknownBindingType = "Unknown binding type"; // Metadata: 0x0043744C
	public const string UserDefinedOpMustHaveConsistentTypes = "The user-defined operator method \'{1}\' for operator \'{0}\' must have identical parameter and return types."; // Metadata: 0x00437464
	public const string UserDefinedOpMustHaveValidReturnType = "The user-defined operator method \'{1}\' for operator \'{0}\' must return the same type as its parameter or a derived type."; // Metadata: 0x004374D1
	public const string LogicalOperatorMustHaveBooleanOperators = "The user-defined operator method \'{1}\' for operator \'{0}\' must have associated boolean True and False operators."; // Metadata: 0x0043754C
	public const string MethodWithArgsDoesNotExistOnType = "No method \'{0}\' on type \'{1}\' is compatible with the supplied arguments."; // Metadata: 0x004375C0
	public const string GenericMethodWithArgsDoesNotExistOnType = "No generic method \'{0}\' on type \'{1}\' is compatible with the supplied type arguments and arguments. No type arguments should be provided if the method is non-generic. "; // Metadata: 0x0043760C
	public const string MethodWithMoreThanOneMatch = "More than one method \'{0}\' on type \'{1}\' is compatible with the supplied arguments."; // Metadata: 0x004376B7
	public const string PropertyWithMoreThanOneMatch = "More than one property \'{0}\' on type \'{1}\' is compatible with the supplied arguments."; // Metadata: 0x0043770E
	public const string IncorrectNumberOfTypeArgsForFunc = "An incorrect number of type arguments were specified for the declaration of a Func type."; // Metadata: 0x00437767
	public const string IncorrectNumberOfTypeArgsForAction = "An incorrect number of type arguments were specified for the declaration of an Action type."; // Metadata: 0x004377C3
	public const string ArgumentCannotBeOfTypeVoid = "Argument type cannot be System.Void."; // Metadata: 0x00437822
	public const string OutOfRange = "{0} must be greater than or equal to {1}"; // Metadata: 0x0043784A
	public const string LabelTargetAlreadyDefined = "Cannot redefine label \'{0}\' in an inner block."; // Metadata: 0x00437876
	public const string LabelTargetUndefined = "Cannot jump to undefined label \'{0}\'."; // Metadata: 0x004378A8
	public const string ControlCannotLeaveFinally = "Control cannot leave a finally block."; // Metadata: 0x004378D1
	public const string ControlCannotLeaveFilterTest = "Control cannot leave a filter test."; // Metadata: 0x004378FA
	public const string AmbiguousJump = "Cannot jump to ambiguous label \'{0}\'."; // Metadata: 0x00437921
	public const string ControlCannotEnterTry = "Control cannot enter a try block."; // Metadata: 0x0043794A
	public const string ControlCannotEnterExpression = "Control cannot enter an expression--only statements can be jumped into."; // Metadata: 0x0043796F
	public const string NonLocalJumpWithValue = "Cannot jump to non-local label \'{0}\' with a value. Only jumps to labels defined in outer blocks can pass values."; // Metadata: 0x004379BA
	public const string ExtensionNotReduced = "Extension should have been reduced."; // Metadata: 0x00437A2E
	public const string CannotCompileConstant = "CompileToMethod cannot compile constant \'{0}\' because it is a non-trivial value, such as a live object. Instead, create an expression tree that can construct this value."; // Metadata: 0x00437A55
	public const string CannotCompileDynamic = "Dynamic expressions are not supported by CompileToMethod. Instead, create an expression tree that uses System.Runtime.CompilerServices.CallSite."; // Metadata: 0x00437B02
	public const string InvalidLvalue = "Invalid lvalue for assignment: {0}."; // Metadata: 0x00437B96
	public const string UnknownLiftType = "unknown lift type: \'{0}\'."; // Metadata: 0x00437BBD
	public const string UndefinedVariable = "variable \'{0}\' of type \'{1}\' referenced from scope \'{2}\', but it is not defined"; // Metadata: 0x00437BDA
	public const string CannotCloseOverByRef = "Cannot close over byref parameter \'{0}\' referenced in lambda \'{1}\'"; // Metadata: 0x00437C2D
	public const string UnexpectedVarArgsCall = "Unexpected VarArgs call to method \'{0}\'"; // Metadata: 0x00437C73
	public const string RethrowRequiresCatch = "Rethrow statement is valid only inside a Catch block."; // Metadata: 0x00437C9E
	public const string TryNotAllowedInFilter = "Try expression is not allowed inside a filter body."; // Metadata: 0x00437CD7
	public const string MustRewriteToSameNode = "When called from \'{0}\', rewriting a node of type \'{1}\' must return a non-null value of the same type. Alternatively, override \'{2}\' and change it to not visit children of this type."; // Metadata: 0x00437D0E
	public const string MustRewriteChildToSameType = "Rewriting child expression from type \'{0}\' to type \'{1}\' is not allowed, because it would change the meaning of the operation. If this is intentional, override \'{2}\' and change it to allow this rewrite."; // Metadata: 0x00437DC7
	public const string MustRewriteWithoutMethod = "Rewritten expression calls operator method \'{0}\', but the original node had no operator method. If this is intentional, override \'{1}\' and change it to allow this rewrite."; // Metadata: 0x00437E95
	public const string InvalidNullValue = "The value null is not of type \'{0}\' and cannot be used in this collection."; // Metadata: 0x00437F44
	public const string InvalidObjectType = "The value \'{0}\' is not of type \'{1}\' and cannot be used in this collection."; // Metadata: 0x00437F92
	public const string TryNotSupportedForMethodsWithRefArgs = "TryExpression is not supported as an argument to method \'{0}\' because it has an argument with by-ref type. Construct the tree so the TryExpression is not nested inside of this expression."; // Metadata: 0x00437FE1
	public const string TryNotSupportedForValueTypeInstances = "TryExpression is not supported as a child expression when accessing a member on type \'{0}\' because it is a value type. Construct the tree so the TryExpression is not nested inside of this expression."; // Metadata: 0x004380A0
	public const string EnumerationIsDone = "Enumeration has either not started or has already finished."; // Metadata: 0x0043816B
	public const string TestValueTypeDoesNotMatchComparisonMethodParameter = "Test value of type \'{0}\' cannot be used for the comparison method parameter of type \'{1}\'"; // Metadata: 0x004381AA
	public const string SwitchValueTypeDoesNotMatchComparisonMethodParameter = "Switch value of type \'{0}\' cannot be used for the comparison method parameter of type \'{1}\'"; // Metadata: 0x00438207
	public const string PdbGeneratorNeedsExpressionCompiler = "DebugInfoGenerator created by CreatePdbGenerator can only be used with LambdaExpression.CompileToMethod."; // Metadata: 0x00438266
	public const string InvalidArgumentValue = "Invalid argument value"; // Metadata: 0x004382D2
	public const string NonEmptyCollectionRequired = "Non-empty collection required"; // Metadata: 0x004382EC
	public const string CollectionModifiedWhileEnumerating = "Collection was modified; enumeration operation may not execute."; // Metadata: 0x0043830D
	public const string ExpressionMustBeReadable = "Expression must be readable"; // Metadata: 0x00438350
	public const string ExpressionTypeDoesNotMatchMethodParameter = "Expression of type \'{0}\' cannot be used for parameter of type \'{1}\' of method \'{2}\'"; // Metadata: 0x0043836F
	public const string ExpressionTypeDoesNotMatchParameter = "Expression of type \'{0}\' cannot be used for parameter of type \'{1}\'"; // Metadata: 0x004383C6
	public const string ExpressionTypeDoesNotMatchConstructorParameter = "Expression of type \'{0}\' cannot be used for constructor parameter of type \'{1}\'"; // Metadata: 0x0043840D
	public const string IncorrectNumberOfMethodCallArguments = "Incorrect number of arguments supplied for call to method \'{0}\'"; // Metadata: 0x00438460
	public const string IncorrectNumberOfLambdaArguments = "Incorrect number of arguments supplied for lambda invocation"; // Metadata: 0x004384A3
	public const string IncorrectNumberOfConstructorArguments = "Incorrect number of arguments for constructor"; // Metadata: 0x004384E3
	public const string OperatorNotImplementedForType = "The operator \'{0}\' is not implemented for type \'{1}\'"; // Metadata: 0x00438514
	public const string NonStaticConstructorRequired = "The constructor should not be static"; // Metadata: 0x0043854C
	public const string NonAbstractConstructorRequired = "Can\'t compile a NewExpression with a constructor declared on an abstract class"; // Metadata: 0x00438574
	public const string FirstArgumentMustBeCallSite = "First argument of delegate must be CallSite"; // Metadata: 0x004385C6
	public const string NoOrInvalidRuleProduced = "No or Invalid rule produced"; // Metadata: 0x004385F5
	public const string TypeMustBeDerivedFromSystemDelegate = "Type must be derived from System.Delegate"; // Metadata: 0x00438614
	public const string TypeParameterIsNotDelegate = "Type parameter is {0}. Expected a delegate."; // Metadata: 0x00438641
	public const string ArgumentTypeCannotBeVoid = "Argument type cannot be void"; // Metadata: 0x00438670
	public const string ArgCntMustBeGreaterThanNameCnt = "Argument count must be greater than number of named arguments."; // Metadata: 0x00438690
	public const string BinderNotCompatibleWithCallSite = "The result type \'{0}\' of the binder \'{1}\' is not compatible with the result type \'{2}\' expected by the call site."; // Metadata: 0x004386D2
	public const string BindingCannotBeNull = "Bind cannot return null."; // Metadata: 0x00438747
	public const string DynamicBinderResultNotAssignable = "The result type \'{0}\' of the dynamic binding produced by binder \'{1}\' is not compatible with the result type \'{2}\' expected by the call site."; // Metadata: 0x00438763
	public const string DynamicBindingNeedsRestrictions = "The result of the dynamic binding produced by the object with type \'{0}\' for the binder \'{1}\' needs at least one restriction."; // Metadata: 0x004387F4
	public const string DynamicObjectResultNotAssignable = "The result type \'{0}\' of the dynamic binding produced by the object with type \'{1}\' for the binder \'{2}\' is not compatible with the result type \'{3}\' expected by the call site."; // Metadata: 0x00438875
	public const string InvalidMetaObjectCreated = "An IDynamicMetaObjectProvider {0} created an invalid DynamicMetaObject instance."; // Metadata: 0x00438929
	public const string AmbiguousMatchInExpandoObject = "More than one key matching \'{0}\' was found in the ExpandoObject."; // Metadata: 0x0043897D
	public const string CollectionReadOnly = "Collection is read-only."; // Metadata: 0x004389C1
	public const string KeyDoesNotExistInExpando = "The specified key \'{0}\' does not exist in the ExpandoObject."; // Metadata: 0x004389DD
	public const string SameKeyExistsInExpando = "An element with the same key \'{0}\' already exists in the ExpandoObject."; // Metadata: 0x00438A1D
	public const string EmptyEnumerable = "Enumeration yielded no results"; // Metadata: 0x00438A68
	public const string MoreThanOneElement = "Sequence contains more than one element"; // Metadata: 0x00438A8A
	public const string MoreThanOneMatch = "Sequence contains more than one matching element"; // Metadata: 0x00438AB5
	public const string NoElements = "Sequence contains no elements"; // Metadata: 0x00438AE9
	public const string NoMatch = "Sequence contains no matching element"; // Metadata: 0x00438B0A
	public const string ParallelPartitionable_NullReturn = "The return value must not be null."; // Metadata: 0x00438B33
	public const string ParallelPartitionable_IncorretElementCount = "The returned array\'s length must equal the number of partitions requested."; // Metadata: 0x00438B59
	public const string ParallelPartitionable_NullElement = "Elements returned must not be null."; // Metadata: 0x00438BA7
	public const string PLINQ_CommonEnumerator_Current_NotStarted = "Enumeration has not started. MoveNext must be called to initiate enumeration."; // Metadata: 0x00438BCE
	public const string PLINQ_ExternalCancellationRequested = "The query has been canceled via the token supplied to WithCancellation."; // Metadata: 0x00438C1F
	public const string PLINQ_DisposeRequested = "The query enumerator has been disposed."; // Metadata: 0x00438C6A
	public const string ParallelQuery_DuplicateTaskScheduler = "The WithTaskScheduler operator may be used at most once in a query."; // Metadata: 0x00438C95
	public const string ParallelQuery_DuplicateDOP = "The WithDegreeOfParallelism operator may be used at most once in a query."; // Metadata: 0x00438CDC
	public const string ParallelQuery_DuplicateExecutionMode = "The WithExecutionMode operator may be used at most once in a query."; // Metadata: 0x00438D29
	public const string PartitionerQueryOperator_NullPartitionList = "Partitioner returned null instead of a list of partitions."; // Metadata: 0x00438D70
	public const string PartitionerQueryOperator_WrongNumberOfPartitions = "Partitioner returned a wrong number of partitions."; // Metadata: 0x00438DAE
	public const string PartitionerQueryOperator_NullPartition = "Partitioner returned a null partition."; // Metadata: 0x00438DE4
	public const string ParallelQuery_DuplicateWithCancellation = "The WithCancellation operator may by used at most once in a query."; // Metadata: 0x00438E0E
	public const string ParallelQuery_DuplicateMergeOptions = "The WithMergeOptions operator may be used at most once in a query."; // Metadata: 0x00438E54
	public const string PLINQ_EnumerationPreviouslyFailed = "The query enumerator previously threw an exception."; // Metadata: 0x00438E9A
	public const string ParallelQuery_PartitionerNotOrderable = "AsOrdered may not be used with a partitioner that is not orderable."; // Metadata: 0x00438ED1
	public const string ParallelQuery_InvalidAsOrderedCall = "AsOrdered may only be called on the result of AsParallel, ParallelEnumerable.Range, or ParallelEnumerable.Repeat."; // Metadata: 0x00438F18
	public const string ParallelQuery_InvalidNonGenericAsOrderedCall = "Non-generic AsOrdered may only be called on the result of the non-generic AsParallel."; // Metadata: 0x00438F8D
	public const string ParallelEnumerable_BinaryOpMustUseAsParallel = "The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>."; // Metadata: 0x00438FE6
	public const string ParallelEnumerable_WithQueryExecutionMode_InvalidMode = "The executionMode argument contains an invalid value."; // Metadata: 0x004390F6
	public const string ParallelEnumerable_WithMergeOptions_InvalidOptions = "The mergeOptions argument contains an invalid value."; // Metadata: 0x0043912F
	public const string ArgumentNotIEnumerableGeneric = "{0} is not IEnumerable<>"; // Metadata: 0x00439167
	public const string ArgumentNotValid = "Argument {0} is not valid"; // Metadata: 0x00439183
	public const string NoMethodOnType = "There is no method \'{0}\' on type \'{1}\'"; // Metadata: 0x004391A0
	public const string NoMethodOnTypeMatchingArguments = "There is no method \'{0}\' on type \'{1}\' that matches the specified arguments"; // Metadata: 0x004391CA
	public const string EnumeratingNullEnumerableExpression = "Cannot enumerate a query created from a null IEnumerable<>"; // Metadata: 0x00439219
	public const string MethodBuilderDoesNotHaveTypeBuilder = "MethodBuilder does not have a valid TypeBuilder"; // Metadata: 0x00439257

	// Methods
	internal static string GetString(string name, params /* 0x00A51D3C-0x00A51D4C */ object[] args) => default; // 0x0153C30C-0x0153C38C
	internal static string GetString(CultureInfo culture, string name, params /* 0x00A51D4C-0x00A51D5C */ object[] args) => default; // 0x0153C38C-0x0153C394
	internal static string GetString(string name) => default; // 0x0153C394-0x0153C398
	internal static string GetString(CultureInfo culture, string name) => default; // 0x0153C398-0x0153C3A0
	internal static string Format(string resourceFormat, params /* 0x00A51D5C-0x00A51D6C */ object[] args) => default; // 0x0153C3A0-0x0153C438
	internal static string Format(string resourceFormat, object p1) => default; // 0x0153C438-0x0153C4B8
	internal static string Format(string resourceFormat, object p1, object p2) => default; // 0x0153C4B8-0x0153C540
	internal static string Format(string resourceFormat, object p1, object p2, object p3) => default; // 0x0153C540-0x0153C5D8
}

namespace Il2CppTests.TestSources
{
	public class FeatureTest // TypeDefIndex: 7685
	{
		// Properties
		public string AutoProp { get; set; } // 0x0208A11C-0x0208A124 0x0208A124-0x0208A12C
	
		// Constructors
		public FeatureTest() {} // 0x0208A394-0x0208A39C
	
		// Methods
		public void AnonType() {} // 0x0208A12C-0x0208A1C4
		public int Linq() => default; // 0x0208A1C4-0x0208A394
	}
}
